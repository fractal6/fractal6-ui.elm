-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.BlobHasFilter
import Fractal.Enum.BlobOrderable
import Fractal.Enum.BlobType
import Fractal.Enum.CommentHasFilter
import Fractal.Enum.CommentOrderable
import Fractal.Enum.ContractHasFilter
import Fractal.Enum.ContractOrderable
import Fractal.Enum.ContractStatus
import Fractal.Enum.ContractType
import Fractal.Enum.EventFragmentHasFilter
import Fractal.Enum.EventFragmentOrderable
import Fractal.Enum.EventHasFilter
import Fractal.Enum.EventKindType
import Fractal.Enum.EventOrderable
import Fractal.Enum.HTTPMethod
import Fractal.Enum.LabelHasFilter
import Fractal.Enum.LabelOrderable
import Fractal.Enum.MandateHasFilter
import Fractal.Enum.MandateOrderable
import Fractal.Enum.Mode
import Fractal.Enum.NodeFragmentHasFilter
import Fractal.Enum.NodeFragmentOrderable
import Fractal.Enum.NodeHasFilter
import Fractal.Enum.NodeMode
import Fractal.Enum.NodeOrderable
import Fractal.Enum.NodeType
import Fractal.Enum.NodeVisibility
import Fractal.Enum.OrgaAggHasFilter
import Fractal.Enum.OrgaAggOrderable
import Fractal.Enum.PendingUserHasFilter
import Fractal.Enum.PendingUserOrderable
import Fractal.Enum.PostHasFilter
import Fractal.Enum.PostOrderable
import Fractal.Enum.RoleExtHasFilter
import Fractal.Enum.RoleExtOrderable
import Fractal.Enum.RoleType
import Fractal.Enum.TensionAction
import Fractal.Enum.TensionEvent
import Fractal.Enum.TensionHasFilter
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionStatus
import Fractal.Enum.TensionType
import Fractal.Enum.UserEventHasFilter
import Fractal.Enum.UserEventOrderable
import Fractal.Enum.UserHasFilter
import Fractal.Enum.UserOrderable
import Fractal.Enum.UserRightsHasFilter
import Fractal.Enum.UserRightsOrderable
import Fractal.Enum.UserType
import Fractal.Enum.VoteHasFilter
import Fractal.Enum.VoteOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddBlobInput :
    AddBlobInputRequiredFields
    -> (AddBlobInputOptionalFields -> AddBlobInputOptionalFields)
    -> AddBlobInput
buildAddBlobInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    AddBlobInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = required____.tension, blob_type = required____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias AddBlobInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    }


type alias AddBlobInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `AddBlobInput` attributes. Note that this type
needs to use the `AddBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddBlobInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the AddBlobInput input object.
-}
type AddBlobInput
    = AddBlobInput AddBlobInputRaw


{-| Encode a AddBlobInput into a value that can be used as an argument.
-}
encodeAddBlobInput : AddBlobInput -> Value
encodeAddBlobInput (AddBlobInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString input____.blob_type |> Just ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildAddCommentInput :
    AddCommentInputRequiredFields
    -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields)
    -> AddCommentInput
buildAddCommentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, void_ = Absent }
    in
    AddCommentInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, void_ = optionals____.void_ }


type alias AddCommentInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    }


type alias AddCommentInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "_VOID", Encode.string |> Encode.optional input____.void_ ) ]


buildAddContractInput :
    AddContractInputRequiredFields
    -> (AddContractInputOptionalFields -> AddContractInputOptionalFields)
    -> AddContractInput
buildAddContractInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, closedAt = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    AddContractInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contractid = required____.contractid, tension = required____.tension, status = required____.status, contract_type = required____.contract_type, closedAt = optionals____.closedAt, event = required____.event, participants = required____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias AddContractInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , contractid : String
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , event : EventFragmentRef
    , participants : List VoteRef
    }


type alias AddContractInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `AddContractInput` attributes. Note that this type
needs to use the `AddContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddContractInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : String
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : EventFragmentRef
    , participants : List VoteRef
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the AddContractInput input object.
-}
type AddContractInput
    = AddContractInput AddContractInputRaw


{-| Encode a AddContractInput into a value that can be used as an argument.
-}
encodeAddContractInput : AddContractInput -> Value
encodeAddContractInput (AddContractInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contractid", Encode.string input____.contractid |> Just ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString input____.status |> Just ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString input____.contract_type |> Just ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef input____.event |> Just ), ( "participants", (encodeVoteRef |> Encode.list) input____.participants |> Just ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildAddEventFragmentInput :
    AddEventFragmentInputRequiredFields
    -> (AddEventFragmentInputOptionalFields -> AddEventFragmentInputOptionalFields)
    -> AddEventFragmentInput
buildAddEventFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { old = Absent, new = Absent }
    in
    { event_type = required____.event_type, old = optionals____.old, new = optionals____.new }


type alias AddEventFragmentInputRequiredFields =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent }


type alias AddEventFragmentInputOptionalFields =
    { old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventFragmentInput input object.
-}
type alias AddEventFragmentInput =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a AddEventFragmentInput into a value that can be used as an argument.
-}
encodeAddEventFragmentInput : AddEventFragmentInput -> Value
encodeAddEventFragmentInput input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input____.event_type |> Just ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildAddEventInput :
    AddEventInputRequiredFields
    -> (AddEventInputOptionalFields -> AddEventInputOptionalFields)
    -> AddEventInput
buildAddEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, old = Absent, new = Absent }
    in
    AddEventInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = required____.tension, event_type = required____.event_type, old = optionals____.old, new = optionals____.new }


type alias AddEventInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    }


type alias AddEventInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `AddEventInput` attributes. Note that this type
needs to use the `AddEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddEventInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventInput input object.
-}
type AddEventInput
    = AddEventInput AddEventInputRaw


{-| Encode a AddEventInput into a value that can be used as an argument.
-}
encodeAddEventInput : AddEventInput -> Value
encodeAddEventInput (AddEventInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input____.event_type |> Just ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildAddLabelInput :
    AddLabelInputRequiredFields
    -> (AddLabelInputOptionalFields -> AddLabelInputOptionalFields)
    -> AddLabelInput
buildAddLabelInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    AddLabelInput { rootnameid = required____.rootnameid, name = required____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes, n_tensions = optionals____.n_tensions }


type alias AddLabelInputRequiredFields =
    { rootnameid : String
    , name : String
    }


type alias AddLabelInputOptionalFields =
    { description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `AddLabelInput` attributes. Note that this type
needs to use the `AddLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddLabelInputRaw =
    { rootnameid : String
    , name : String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the AddLabelInput input object.
-}
type AddLabelInput
    = AddLabelInput AddLabelInputRaw


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput (AddLabelInput input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "name", Encode.string input____.name |> Just ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input____.n_tensions ) ]


buildAddMandateInput :
    AddMandateInputRequiredFields
    -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields)
    -> AddMandateInput
buildAddMandateInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = required____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias AddMandateInputRequiredFields =
    { purpose : String }


type alias AddMandateInputOptionalFields =
    { responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the AddMandateInput input object.
-}
type alias AddMandateInput =
    { purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput input____ =
    Encode.maybeObject
        [ ( "purpose", Encode.string input____.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildAddNodeFragmentInput :
    (AddNodeFragmentInputOptionalFields -> AddNodeFragmentInputOptionalFields)
    -> AddNodeFragmentInput
buildAddNodeFragmentInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, children = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, second_link = Absent, role_type = Absent }
    in
    AddNodeFragmentInput { nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, children = optionals____.children, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, second_link = optionals____.second_link, role_type = optionals____.role_type }


type alias AddNodeFragmentInputOptionalFields =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `AddNodeFragmentInput` attributes. Note that this type
needs to use the `AddNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeFragmentInputRaw =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the AddNodeFragmentInput input object.
-}
type AddNodeFragmentInput
    = AddNodeFragmentInput AddNodeFragmentInputRaw


{-| Encode a AddNodeFragmentInput into a value that can be used as an argument.
-}
encodeAddNodeFragmentInput : AddNodeFragmentInput -> Value
encodeAddNodeFragmentInput (AddNodeFragmentInput input____) =
    Encode.maybeObject
        [ ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input____.children ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "second_link", Encode.string |> Encode.optional input____.second_link ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ) ]


buildAddNodeInput :
    AddNodeInputRequiredFields
    -> (AddNodeInputOptionalFields -> AddNodeInputOptionalFields)
    -> AddNodeInput
buildAddNodeInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, parent = Absent, children = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, labels = Absent, isPersonal = Absent, userCanJoin = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, role_ext = Absent, contracts = Absent, orga_agg = Absent }
    in
    AddNodeInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, name = required____.name, nameid = required____.nameid, rootnameid = required____.rootnameid, parent = optionals____.parent, children = optionals____.children, type_ = required____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, about = optionals____.about, mandate = optionals____.mandate, docs = optionals____.docs, source = optionals____.source, labels = optionals____.labels, visibility = required____.visibility, mode = required____.mode, rights = required____.rights, isArchived = required____.isArchived, isRoot = required____.isRoot, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, first_link = optionals____.first_link, second_link = optionals____.second_link, skills = optionals____.skills, role_type = optionals____.role_type, role_ext = optionals____.role_ext, contracts = optionals____.contracts, orga_agg = optionals____.orga_agg }


type alias AddNodeInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , type_ : Fractal.Enum.NodeType.NodeType
    , visibility : Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : Fractal.Enum.NodeMode.NodeMode
    , rights : Int
    , isArchived : Bool
    , isRoot : Bool
    }


type alias AddNodeInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `AddNodeInput` attributes. Note that this type
needs to use the `AddNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : String
    , nameid : String
    , rootnameid : String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , visibility : Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : Fractal.Enum.NodeMode.NodeMode
    , rights : Int
    , isArchived : Bool
    , isRoot : Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the AddNodeInput input object.
-}
type AddNodeInput
    = AddNodeInput AddNodeInputRaw


{-| Encode a AddNodeInput into a value that can be used as an argument.
-}
encodeAddNodeInput : AddNodeInput -> Value
encodeAddNodeInput (AddNodeInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "name", Encode.string input____.name |> Just ), ( "nameid", Encode.string input____.nameid |> Just ), ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString input____.type_ |> Just ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input____.docs ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString input____.visibility |> Just ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString input____.mode |> Just ), ( "rights", Encode.int input____.rights |> Just ), ( "isArchived", Encode.bool input____.isArchived |> Just ), ( "isRoot", Encode.bool input____.isRoot |> Just ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "second_link", encodeUserRef |> Encode.optional input____.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input____.orga_agg ) ]


buildAddOrgaAggInput :
    (AddOrgaAggInputOptionalFields -> AddOrgaAggInputOptionalFields)
    -> AddOrgaAggInput
buildAddOrgaAggInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals____.n_members, n_guests = optionals____.n_guests }


type alias AddOrgaAggInputOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the AddOrgaAggInput input object.
-}
type alias AddOrgaAggInput =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a AddOrgaAggInput into a value that can be used as an argument.
-}
encodeAddOrgaAggInput : AddOrgaAggInput -> Value
encodeAddOrgaAggInput input____ =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input____.n_members ), ( "n_guests", Encode.int |> Encode.optional input____.n_guests ) ]


buildAddPendingUserInput :
    (AddPendingUserInputOptionalFields -> AddPendingUserInputOptionalFields)
    -> AddPendingUserInput
buildAddPendingUserInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { email = Absent }
    in
    { email = optionals____.email }


type alias AddPendingUserInputOptionalFields =
    { email : OptionalArgument String }


{-| Type for the AddPendingUserInput input object.
-}
type alias AddPendingUserInput =
    { email : OptionalArgument String }


{-| Encode a AddPendingUserInput into a value that can be used as an argument.
-}
encodeAddPendingUserInput : AddPendingUserInput -> Value
encodeAddPendingUserInput input____ =
    Encode.maybeObject
        [ ( "email", Encode.string |> Encode.optional input____.email ) ]


buildAddRoleExtInput :
    AddRoleExtInputRequiredFields
    -> (AddRoleExtInputOptionalFields -> AddRoleExtInputOptionalFields)
    -> AddRoleExtInput
buildAddRoleExtInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { about = Absent, color = Absent, mandate = Absent, nodes = Absent, n_nodes = Absent }
    in
    AddRoleExtInput { rootnameid = required____.rootnameid, name = required____.name, about = optionals____.about, role_type = required____.role_type, color = optionals____.color, mandate = optionals____.mandate, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes }


type alias AddRoleExtInputRequiredFields =
    { rootnameid : String
    , name : String
    , role_type : Fractal.Enum.RoleType.RoleType
    }


type alias AddRoleExtInputOptionalFields =
    { about : OptionalArgument String
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type alias for the `AddRoleExtInput` attributes. Note that this type
needs to use the `AddRoleExtInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddRoleExtInputRaw =
    { rootnameid : String
    , name : String
    , about : OptionalArgument String
    , role_type : Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type for the AddRoleExtInput input object.
-}
type AddRoleExtInput
    = AddRoleExtInput AddRoleExtInputRaw


{-| Encode a AddRoleExtInput into a value that can be used as an argument.
-}
encodeAddRoleExtInput : AddRoleExtInput -> Value
encodeAddRoleExtInput (AddRoleExtInput input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "name", Encode.string input____.name |> Just ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString input____.role_type |> Just ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ) ]


buildAddTensionInput :
    AddTensionInputRequiredFields
    -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields)
    -> AddTensionInput
buildAddTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, action = Absent, comments = Absent, assignees = Absent, labels = Absent, blobs = Absent, contracts = Absent, suscribers = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    AddTensionInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = required____.emitter, emitterid = required____.emitterid, receiver = required____.receiver, receiverid = required____.receiverid, title = required____.title, type_ = required____.type_, status = required____.status, action = optionals____.action, comments = optionals____.comments, assignees = optionals____.assignees, labels = optionals____.labels, blobs = optionals____.blobs, history = required____.history, contracts = optionals____.contracts, suscribers = optionals____.suscribers, n_comments = optionals____.n_comments, n_open_contracts = optionals____.n_open_contracts }


type alias AddTensionInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , history : List EventRef
    }


type alias AddTensionInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : List EventRef
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef input____.emitter |> Just ), ( "emitterid", Encode.string input____.emitterid |> Just ), ( "receiver", encodeNodeRef input____.receiver |> Just ), ( "receiverid", Encode.string input____.receiverid |> Just ), ( "title", Encode.string input____.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input____.type_ |> Just ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString input____.status |> Just ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) input____.history |> Just ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "suscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.suscribers ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input____.n_open_contracts ) ]


buildAddUserEventInput :
    AddUserEventInputRequiredFields
    -> AddUserEventInput
buildAddUserEventInput required____ =
    AddUserEventInput { createdAt = required____.createdAt, isRead = required____.isRead, user = required____.user, event = required____.event }


type alias AddUserEventInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , isRead : Bool
    , user : UserRef
    , event : EventKindRef
    }


{-| Type alias for the `AddUserEventInput` attributes. Note that this type
needs to use the `AddUserEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserEventInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , isRead : Bool
    , user : UserRef
    , event : EventKindRef
    }


{-| Type for the AddUserEventInput input object.
-}
type AddUserEventInput
    = AddUserEventInput AddUserEventInputRaw


{-| Encode a AddUserEventInput into a value that can be used as an argument.
-}
encodeAddUserEventInput : AddUserEventInput -> Value
encodeAddUserEventInput (AddUserEventInput input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "isRead", Encode.bool input____.isRead |> Just ), ( "user", encodeUserRef input____.user |> Just ), ( "event", encodeEventKindRef input____.event |> Just ) ]


buildAddUserInput :
    AddUserInputRequiredFields
    -> (AddUserInputOptionalFields -> AddUserInputOptionalFields)
    -> AddUserInput
buildAddUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { name = Absent, emailHash = Absent, bio = Absent, utc = Absent, notifyByEmail = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, subscriptions = Absent, events = Absent }
    in
    AddUserInput { createdAt = required____.createdAt, lastAck = required____.lastAck, username = required____.username, name = optionals____.name, password = required____.password, email = required____.email, emailHash = optionals____.emailHash, emailValidated = required____.emailValidated, bio = optionals____.bio, utc = optionals____.utc, notifyByEmail = optionals____.notifyByEmail, rights = required____.rights, roles = optionals____.roles, backed_roles = optionals____.backed_roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, subscriptions = optionals____.subscriptions, events = optionals____.events }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , password : String
    , email : String
    , emailValidated : Bool
    , rights : UserRightsRef
    }


type alias AddUserInputOptionalFields =
    { name : OptionalArgument String
    , emailHash : OptionalArgument String
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , name : OptionalArgument String
    , password : String
    , email : String
    , emailHash : OptionalArgument String
    , emailValidated : Bool
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , rights : UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.lastAck |> Just ), ( "username", Encode.string input____.username |> Just ), ( "name", Encode.string |> Encode.optional input____.name ), ( "password", Encode.string input____.password |> Just ), ( "email", Encode.string input____.email |> Just ), ( "emailHash", Encode.string |> Encode.optional input____.emailHash ), ( "emailValidated", Encode.bool input____.emailValidated |> Just ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "notifyByEmail", Encode.bool |> Encode.optional input____.notifyByEmail ), ( "rights", encodeUserRightsRef input____.rights |> Just ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ) ]


buildAddUserRightsInput :
    AddUserRightsInputRequiredFields
    -> AddUserRightsInput
buildAddUserRightsInput required____ =
    { canLogin = required____.canLogin, canCreateRoot = required____.canCreateRoot, maxPublicOrga = required____.maxPublicOrga, type_ = required____.type_ }


type alias AddUserRightsInputRequiredFields =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , type_ : Fractal.Enum.UserType.UserType
    }


{-| Type for the AddUserRightsInput input object.
-}
type alias AddUserRightsInput =
    { canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , type_ : Fractal.Enum.UserType.UserType
    }


{-| Encode a AddUserRightsInput into a value that can be used as an argument.
-}
encodeAddUserRightsInput : AddUserRightsInput -> Value
encodeAddUserRightsInput input____ =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool input____.canLogin |> Just ), ( "canCreateRoot", Encode.bool input____.canCreateRoot |> Just ), ( "maxPublicOrga", Encode.int input____.maxPublicOrga |> Just ), ( "type_", Encode.enum Fractal.Enum.UserType.toString input____.type_ |> Just ) ]


buildAddVoteInput :
    AddVoteInputRequiredFields
    -> (AddVoteInputOptionalFields -> AddVoteInputOptionalFields)
    -> AddVoteInput
buildAddVoteInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent }
    in
    AddVoteInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, voteid = required____.voteid, contract = required____.contract, node = required____.node, data = required____.data }


type alias AddVoteInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , voteid : String
    , contract : ContractRef
    , node : NodeRef
    , data : List Int
    }


type alias AddVoteInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `AddVoteInput` attributes. Note that this type
needs to use the `AddVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddVoteInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : String
    , contract : ContractRef
    , node : NodeRef
    , data : List Int
    }


{-| Type for the AddVoteInput input object.
-}
type AddVoteInput
    = AddVoteInput AddVoteInputRaw


{-| Encode a AddVoteInput into a value that can be used as an argument.
-}
encodeAddVoteInput : AddVoteInput -> Value
encodeAddVoteInput (AddVoteInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "voteid", Encode.string input____.voteid |> Just ), ( "contract", encodeContractRef input____.contract |> Just ), ( "node", encodeNodeRef input____.node |> Just ), ( "data", (Encode.int |> Encode.list) input____.data |> Just ) ]


buildAuthRule :
    (AuthRuleOptionalFields -> AuthRuleOptionalFields)
    -> AuthRule
buildAuthRule fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and = Absent, or = Absent, not = Absent, rule = Absent }
    in
    AuthRule { and = optionals____.and, or = optionals____.or, not = optionals____.not, rule = optionals____.rule }


type alias AuthRuleOptionalFields =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type alias for the `AuthRule` attributes. Note that this type
needs to use the `AuthRule` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AuthRuleRaw =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type for the AuthRule input object.
-}
type AuthRule
    = AuthRule AuthRuleRaw


{-| Encode a AuthRule into a value that can be used as an argument.
-}
encodeAuthRule : AuthRule -> Value
encodeAuthRule (AuthRule input____) =
    Encode.maybeObject
        [ ( "and", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeAuthRule |> Encode.optional input____.not ), ( "rule", Encode.string |> Encode.optional input____.rule ) ]


buildBlobFilter :
    (BlobFilterOptionalFields -> BlobFilterOptionalFields)
    -> BlobFilter
buildBlobFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    BlobFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias BlobFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type alias for the `BlobFilter` attributes. Note that this type
needs to use the `BlobFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type for the BlobFilter input object.
-}
type BlobFilter
    = BlobFilter BlobFilterRaw


{-| Encode a BlobFilter into a value that can be used as an argument.
-}
encodeBlobFilter : BlobFilter -> Value
encodeBlobFilter (BlobFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "blob_type", encodeBlobType_hash |> Encode.optional input____.blob_type ), ( "pushedFlag", encodeDateTimeFilter |> Encode.optional input____.pushedFlag ), ( "archivedFlag", encodeDateTimeFilter |> Encode.optional input____.archivedFlag ), ( "has", (Encode.enum Fractal.Enum.BlobHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeBlobFilter |> Encode.optional input____.not ) ]


buildBlobOrder :
    (BlobOrderOptionalFields -> BlobOrderOptionalFields)
    -> BlobOrder
buildBlobOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    BlobOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias BlobOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type alias for the `BlobOrder` attributes. Note that this type
needs to use the `BlobOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobOrderRaw =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type for the BlobOrder input object.
-}
type BlobOrder
    = BlobOrder BlobOrderRaw


{-| Encode a BlobOrder into a value that can be used as an argument.
-}
encodeBlobOrder : BlobOrder -> Value
encodeBlobOrder (BlobOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeBlobOrder |> Encode.optional input____.then_ ) ]


buildBlobPatch :
    (BlobPatchOptionalFields -> BlobPatchOptionalFields)
    -> BlobPatch
buildBlobPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias BlobPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobPatch` attributes. Note that this type
needs to use the `BlobPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobPatch input object.
-}
type BlobPatch
    = BlobPatch BlobPatchRaw


{-| Encode a BlobPatch into a value that can be used as an argument.
-}
encodeBlobPatch : BlobPatch -> Value
encodeBlobPatch (BlobPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildBlobRef :
    (BlobRefOptionalFields -> BlobRefOptionalFields)
    -> BlobRef
buildBlobRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias BlobRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobRef` attributes. Note that this type
needs to use the `BlobRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobRef input object.
-}
type BlobRef
    = BlobRef BlobRefRaw


{-| Encode a BlobRef into a value that can be used as an argument.
-}
encodeBlobRef : BlobRef -> Value
encodeBlobRef (BlobRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildBlobType_hash :
    (BlobType_hashOptionalFields -> BlobType_hashOptionalFields)
    -> BlobType_hash
buildBlobType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias BlobType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Type for the BlobType\_hash input object.
-}
type alias BlobType_hash =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Encode a BlobType\_hash into a value that can be used as an argument.
-}
encodeBlobType_hash : BlobType_hash -> Value
encodeBlobType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.BlobType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildCommentFilter :
    (CommentFilterOptionalFields -> CommentFilterOptionalFields)
    -> CommentFilter
buildCommentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "has", (Encode.enum Fractal.Enum.CommentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeCommentFilter |> Encode.optional input____.not ) ]


buildCommentOrder :
    (CommentOrderOptionalFields -> CommentOrderOptionalFields)
    -> CommentOrder
buildCommentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeCommentOrder |> Encode.optional input____.then_ ) ]


buildCommentPatch :
    (CommentPatchOptionalFields -> CommentPatchOptionalFields)
    -> CommentPatch
buildCommentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, void_ = optionals____.void_ }


type alias CommentPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "_VOID", Encode.string |> Encode.optional input____.void_ ) ]


buildCommentRef :
    (CommentRefOptionalFields -> CommentRefOptionalFields)
    -> CommentRef
buildCommentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, void_ = Absent }
    in
    CommentRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, void_ = optionals____.void_ }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , void_ : OptionalArgument String
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "_VOID", Encode.string |> Encode.optional input____.void_ ) ]


buildContainsFilter :
    (ContainsFilterOptionalFields -> ContainsFilterOptionalFields)
    -> ContainsFilter
buildContainsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { point = Absent, polygon = Absent }
    in
    { point = optionals____.point, polygon = optionals____.polygon }


type alias ContainsFilterOptionalFields =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Type for the ContainsFilter input object.
-}
type alias ContainsFilter =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Encode a ContainsFilter into a value that can be used as an argument.
-}
encodeContainsFilter : ContainsFilter -> Value
encodeContainsFilter input____ =
    Encode.maybeObject
        [ ( "point", encodePointRef |> Encode.optional input____.point ), ( "polygon", encodePolygonRef |> Encode.optional input____.polygon ) ]


buildContractFilter :
    (ContractFilterOptionalFields -> ContractFilterOptionalFields)
    -> ContractFilter
buildContractFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, contractid = Absent, status = Absent, contract_type = Absent, closedAt = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ContractFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, contractid = optionals____.contractid, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ContractFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , contractid : OptionalArgument StringHashFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type alias for the `ContractFilter` attributes. Note that this type
needs to use the `ContractFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , contractid : OptionalArgument StringHashFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type for the ContractFilter input object.
-}
type ContractFilter
    = ContractFilter ContractFilterRaw


{-| Encode a ContractFilter into a value that can be used as an argument.
-}
encodeContractFilter : ContractFilter -> Value
encodeContractFilter (ContractFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "contractid", encodeStringHashFilter |> Encode.optional input____.contractid ), ( "status", encodeContractStatus_hash |> Encode.optional input____.status ), ( "contract_type", encodeContractType_hash |> Encode.optional input____.contract_type ), ( "closedAt", encodeDateTimeFilter |> Encode.optional input____.closedAt ), ( "has", (Encode.enum Fractal.Enum.ContractHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeContractFilter |> Encode.optional input____.not ) ]


buildContractOrder :
    (ContractOrderOptionalFields -> ContractOrderOptionalFields)
    -> ContractOrder
buildContractOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ContractOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ContractOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type alias for the `ContractOrder` attributes. Note that this type
needs to use the `ContractOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type for the ContractOrder input object.
-}
type ContractOrder
    = ContractOrder ContractOrderRaw


{-| Encode a ContractOrder into a value that can be used as an argument.
-}
encodeContractOrder : ContractOrder -> Value
encodeContractOrder (ContractOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeContractOrder |> Encode.optional input____.then_ ) ]


buildContractPatch :
    (ContractPatchOptionalFields -> ContractPatchOptionalFields)
    -> ContractPatch
buildContractPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, contractid = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, participants = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    ContractPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contractid = optionals____.contractid, tension = optionals____.tension, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, event = optionals____.event, participants = optionals____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias ContractPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractPatch` attributes. Note that this type
needs to use the `ContractPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractPatch input object.
-}
type ContractPatch
    = ContractPatch ContractPatchRaw


{-| Encode a ContractPatch into a value that can be used as an argument.
-}
encodeContractPatch : ContractPatch -> Value
encodeContractPatch (ContractPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contractid", Encode.string |> Encode.optional input____.contractid ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input____.event ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input____.participants ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildContractRef :
    (ContractRefOptionalFields -> ContractRefOptionalFields)
    -> ContractRef
buildContractRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, contractid = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, participants = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    ContractRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contractid = optionals____.contractid, tension = optionals____.tension, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, event = optionals____.event, participants = optionals____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias ContractRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractRef` attributes. Note that this type
needs to use the `ContractRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractRef input object.
-}
type ContractRef
    = ContractRef ContractRefRaw


{-| Encode a ContractRef into a value that can be used as an argument.
-}
encodeContractRef : ContractRef -> Value
encodeContractRef (ContractRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contractid", Encode.string |> Encode.optional input____.contractid ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input____.event ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input____.participants ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildContractStatus_hash :
    (ContractStatus_hashOptionalFields -> ContractStatus_hashOptionalFields)
    -> ContractStatus_hash
buildContractStatus_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias ContractStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Type for the ContractStatus\_hash input object.
-}
type alias ContractStatus_hash =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Encode a ContractStatus\_hash into a value that can be used as an argument.
-}
encodeContractStatus_hash : ContractStatus_hash -> Value
encodeContractStatus_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildContractType_hash :
    (ContractType_hashOptionalFields -> ContractType_hashOptionalFields)
    -> ContractType_hash
buildContractType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias ContractType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Type for the ContractType\_hash input object.
-}
type alias ContractType_hash =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Encode a ContractType\_hash into a value that can be used as an argument.
-}
encodeContractType_hash : ContractType_hash -> Value
encodeContractType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.ContractType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildCustomHTTP :
    CustomHTTPRequiredFields
    -> (CustomHTTPOptionalFields -> CustomHTTPOptionalFields)
    -> CustomHTTP
buildCustomHTTP required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { body = Absent, graphql = Absent, mode = Absent, forwardHeaders = Absent, secretHeaders = Absent, introspectionHeaders = Absent, skipIntrospection = Absent }
    in
    { url = required____.url, method = required____.method, body = optionals____.body, graphql = optionals____.graphql, mode = optionals____.mode, forwardHeaders = optionals____.forwardHeaders, secretHeaders = optionals____.secretHeaders, introspectionHeaders = optionals____.introspectionHeaders, skipIntrospection = optionals____.skipIntrospection }


type alias CustomHTTPRequiredFields =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    }


type alias CustomHTTPOptionalFields =
    { body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Type for the CustomHTTP input object.
-}
type alias CustomHTTP =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    , body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Encode a CustomHTTP into a value that can be used as an argument.
-}
encodeCustomHTTP : CustomHTTP -> Value
encodeCustomHTTP input____ =
    Encode.maybeObject
        [ ( "url", Encode.string input____.url |> Just ), ( "method", Encode.enum Fractal.Enum.HTTPMethod.toString input____.method |> Just ), ( "body", Encode.string |> Encode.optional input____.body ), ( "graphql", Encode.string |> Encode.optional input____.graphql ), ( "mode", Encode.enum Fractal.Enum.Mode.toString |> Encode.optional input____.mode ), ( "forwardHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.forwardHeaders ), ( "secretHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.secretHeaders ), ( "introspectionHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.introspectionHeaders ), ( "skipIntrospection", Encode.bool |> Encode.optional input____.skipIntrospection ) ]


buildDateTimeFilter :
    (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields)
    -> DateTimeFilter
buildDateTimeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.gt ), ( "between", encodeDateTimeRange |> Encode.optional input____.between ) ]


buildDateTimeRange :
    DateTimeRangeRequiredFields
    -> DateTimeRange
buildDateTimeRange required____ =
    { min = required____.min, max = required____.max }


type alias DateTimeRangeRequiredFields =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeRange input object.
-}
type alias DateTimeRange =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeRange into a value that can be used as an argument.
-}
encodeDateTimeRange : DateTimeRange -> Value
encodeDateTimeRange input____ =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.max |> Just ) ]


buildDgraphDefault :
    (DgraphDefaultOptionalFields -> DgraphDefaultOptionalFields)
    -> DgraphDefault
buildDgraphDefault fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { value = Absent }
    in
    { value = optionals____.value }


type alias DgraphDefaultOptionalFields =
    { value : OptionalArgument String }


{-| Type for the DgraphDefault input object.
-}
type alias DgraphDefault =
    { value : OptionalArgument String }


{-| Encode a DgraphDefault into a value that can be used as an argument.
-}
encodeDgraphDefault : DgraphDefault -> Value
encodeDgraphDefault input____ =
    Encode.maybeObject
        [ ( "value", Encode.string |> Encode.optional input____.value ) ]


buildEventFilter :
    (EventFilterOptionalFields -> EventFilterOptionalFields)
    -> EventFilter
buildEventFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, event_type = optionals____.event_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias EventFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type alias for the `EventFilter` attributes. Note that this type
needs to use the `EventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type for the EventFilter input object.
-}
type EventFilter
    = EventFilter EventFilterRaw


{-| Encode a EventFilter into a value that can be used as an argument.
-}
encodeEventFilter : EventFilter -> Value
encodeEventFilter (EventFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "event_type", encodeTensionEvent_hash |> Encode.optional input____.event_type ), ( "has", (Encode.enum Fractal.Enum.EventHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeEventFilter |> Encode.optional input____.not ) ]


buildEventFragmentFilter :
    (EventFragmentFilterOptionalFields -> EventFragmentFilterOptionalFields)
    -> EventFragmentFilter
buildEventFragmentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFragmentFilter { event_type = optionals____.event_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias EventFragmentFilterOptionalFields =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type alias for the `EventFragmentFilter` attributes. Note that this type
needs to use the `EventFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentFilterRaw =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type for the EventFragmentFilter input object.
-}
type EventFragmentFilter
    = EventFragmentFilter EventFragmentFilterRaw


{-| Encode a EventFragmentFilter into a value that can be used as an argument.
-}
encodeEventFragmentFilter : EventFragmentFilter -> Value
encodeEventFragmentFilter (EventFragmentFilter input____) =
    Encode.maybeObject
        [ ( "event_type", encodeTensionEvent_hash |> Encode.optional input____.event_type ), ( "has", (Encode.enum Fractal.Enum.EventFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeEventFragmentFilter |> Encode.optional input____.not ) ]


buildEventFragmentOrder :
    (EventFragmentOrderOptionalFields -> EventFragmentOrderOptionalFields)
    -> EventFragmentOrder
buildEventFragmentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventFragmentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias EventFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type alias for the `EventFragmentOrder` attributes. Note that this type
needs to use the `EventFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type for the EventFragmentOrder input object.
-}
type EventFragmentOrder
    = EventFragmentOrder EventFragmentOrderRaw


{-| Encode a EventFragmentOrder into a value that can be used as an argument.
-}
encodeEventFragmentOrder : EventFragmentOrder -> Value
encodeEventFragmentOrder (EventFragmentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeEventFragmentOrder |> Encode.optional input____.then_ ) ]


buildEventFragmentPatch :
    (EventFragmentPatchOptionalFields -> EventFragmentPatchOptionalFields)
    -> EventFragmentPatch
buildEventFragmentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventFragmentPatchOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentPatch input object.
-}
type alias EventFragmentPatch =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentPatch into a value that can be used as an argument.
-}
encodeEventFragmentPatch : EventFragmentPatch -> Value
encodeEventFragmentPatch input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventFragmentRef :
    (EventFragmentRefOptionalFields -> EventFragmentRefOptionalFields)
    -> EventFragmentRef
buildEventFragmentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventFragmentRefOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentRef input object.
-}
type alias EventFragmentRef =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentRef into a value that can be used as an argument.
-}
encodeEventFragmentRef : EventFragmentRef -> Value
encodeEventFragmentRef input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventKindFilter :
    (EventKindFilterOptionalFields -> EventKindFilterOptionalFields)
    -> EventKindFilter
buildEventKindFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { memberTypes = Absent, eventFilter = Absent, contractFilter = Absent }
    in
    EventKindFilter { memberTypes = optionals____.memberTypes, eventFilter = optionals____.eventFilter, contractFilter = optionals____.contractFilter }


type alias EventKindFilterOptionalFields =
    { memberTypes : OptionalArgument (List Fractal.Enum.EventKindType.EventKindType)
    , eventFilter : OptionalArgument EventFilter
    , contractFilter : OptionalArgument ContractFilter
    }


{-| Type alias for the `EventKindFilter` attributes. Note that this type
needs to use the `EventKindFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventKindFilterRaw =
    { memberTypes : OptionalArgument (List Fractal.Enum.EventKindType.EventKindType)
    , eventFilter : OptionalArgument EventFilter
    , contractFilter : OptionalArgument ContractFilter
    }


{-| Type for the EventKindFilter input object.
-}
type EventKindFilter
    = EventKindFilter EventKindFilterRaw


{-| Encode a EventKindFilter into a value that can be used as an argument.
-}
encodeEventKindFilter : EventKindFilter -> Value
encodeEventKindFilter (EventKindFilter input____) =
    Encode.maybeObject
        [ ( "memberTypes", (Encode.enum Fractal.Enum.EventKindType.toString |> Encode.list) |> Encode.optional input____.memberTypes ), ( "eventFilter", encodeEventFilter |> Encode.optional input____.eventFilter ), ( "contractFilter", encodeContractFilter |> Encode.optional input____.contractFilter ) ]


buildEventKindRef :
    (EventKindRefOptionalFields -> EventKindRefOptionalFields)
    -> EventKindRef
buildEventKindRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eventRef = Absent, contractRef = Absent }
    in
    EventKindRef { eventRef = optionals____.eventRef, contractRef = optionals____.contractRef }


type alias EventKindRefOptionalFields =
    { eventRef : OptionalArgument EventRef
    , contractRef : OptionalArgument ContractRef
    }


{-| Type alias for the `EventKindRef` attributes. Note that this type
needs to use the `EventKindRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventKindRefRaw =
    { eventRef : OptionalArgument EventRef
    , contractRef : OptionalArgument ContractRef
    }


{-| Type for the EventKindRef input object.
-}
type EventKindRef
    = EventKindRef EventKindRefRaw


{-| Encode a EventKindRef into a value that can be used as an argument.
-}
encodeEventKindRef : EventKindRef -> Value
encodeEventKindRef (EventKindRef input____) =
    Encode.maybeObject
        [ ( "eventRef", encodeEventRef |> Encode.optional input____.eventRef ), ( "contractRef", encodeContractRef |> Encode.optional input____.contractRef ) ]


buildEventOrder :
    (EventOrderOptionalFields -> EventOrderOptionalFields)
    -> EventOrder
buildEventOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias EventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type alias for the `EventOrder` attributes. Note that this type
needs to use the `EventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type for the EventOrder input object.
-}
type EventOrder
    = EventOrder EventOrderRaw


{-| Encode a EventOrder into a value that can be used as an argument.
-}
encodeEventOrder : EventOrder -> Value
encodeEventOrder (EventOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeEventOrder |> Encode.optional input____.then_ ) ]


buildEventPatch :
    (EventPatchOptionalFields -> EventPatchOptionalFields)
    -> EventPatch
buildEventPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventPatch` attributes. Note that this type
needs to use the `EventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventPatch input object.
-}
type EventPatch
    = EventPatch EventPatchRaw


{-| Encode a EventPatch into a value that can be used as an argument.
-}
encodeEventPatch : EventPatch -> Value
encodeEventPatch (EventPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventRef :
    (EventRefOptionalFields -> EventRefOptionalFields)
    -> EventRef
buildEventRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, old = Absent, new = Absent }
    in
    EventRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventRef` attributes. Note that this type
needs to use the `EventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventRef input object.
-}
type EventRef
    = EventRef EventRefRaw


{-| Encode a EventRef into a value that can be used as an argument.
-}
encodeEventRef : EventRef -> Value
encodeEventRef (EventRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildFloatFilter :
    (FloatFilterOptionalFields -> FloatFilterOptionalFields)
    -> FloatFilter
buildFloatFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input____.eq ), ( "in", (Encode.float |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.float |> Encode.optional input____.le ), ( "lt", Encode.float |> Encode.optional input____.lt ), ( "ge", Encode.float |> Encode.optional input____.ge ), ( "gt", Encode.float |> Encode.optional input____.gt ), ( "between", encodeFloatRange |> Encode.optional input____.between ) ]


buildFloatRange :
    FloatRangeRequiredFields
    -> FloatRange
buildFloatRange required____ =
    { min = required____.min, max = required____.max }


type alias FloatRangeRequiredFields =
    { min : Float
    , max : Float
    }


{-| Type for the FloatRange input object.
-}
type alias FloatRange =
    { min : Float
    , max : Float
    }


{-| Encode a FloatRange into a value that can be used as an argument.
-}
encodeFloatRange : FloatRange -> Value
encodeFloatRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.float input____.min |> Just ), ( "max", Encode.float input____.max |> Just ) ]


buildGenerateMutationParams :
    (GenerateMutationParamsOptionalFields -> GenerateMutationParamsOptionalFields)
    -> GenerateMutationParams
buildGenerateMutationParams fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { add = Absent, update = Absent, delete = Absent }
    in
    { add = optionals____.add, update = optionals____.update, delete = optionals____.delete }


type alias GenerateMutationParamsOptionalFields =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Type for the GenerateMutationParams input object.
-}
type alias GenerateMutationParams =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Encode a GenerateMutationParams into a value that can be used as an argument.
-}
encodeGenerateMutationParams : GenerateMutationParams -> Value
encodeGenerateMutationParams input____ =
    Encode.maybeObject
        [ ( "add", Encode.bool |> Encode.optional input____.add ), ( "update", Encode.bool |> Encode.optional input____.update ), ( "delete", Encode.bool |> Encode.optional input____.delete ) ]


buildGenerateQueryParams :
    (GenerateQueryParamsOptionalFields -> GenerateQueryParamsOptionalFields)
    -> GenerateQueryParams
buildGenerateQueryParams fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { get = Absent, query = Absent, password = Absent, aggregate = Absent }
    in
    { get = optionals____.get, query = optionals____.query, password = optionals____.password, aggregate = optionals____.aggregate }


type alias GenerateQueryParamsOptionalFields =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Type for the GenerateQueryParams input object.
-}
type alias GenerateQueryParams =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Encode a GenerateQueryParams into a value that can be used as an argument.
-}
encodeGenerateQueryParams : GenerateQueryParams -> Value
encodeGenerateQueryParams input____ =
    Encode.maybeObject
        [ ( "get", Encode.bool |> Encode.optional input____.get ), ( "query", Encode.bool |> Encode.optional input____.query ), ( "password", Encode.bool |> Encode.optional input____.password ), ( "aggregate", Encode.bool |> Encode.optional input____.aggregate ) ]


buildInt64Filter :
    (Int64FilterOptionalFields -> Int64FilterOptionalFields)
    -> Int64Filter
buildInt64Filter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias Int64FilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Type for the Int64Filter input object.
-}
type alias Int64Filter =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Encode a Int64Filter into a value that can be used as an argument.
-}
encodeInt64Filter : Int64Filter -> Value
encodeInt64Filter input____ =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.gt ), ( "between", encodeInt64Range |> Encode.optional input____.between ) ]


buildInt64Range :
    Int64RangeRequiredFields
    -> Int64Range
buildInt64Range required____ =
    { min = required____.min, max = required____.max }


type alias Int64RangeRequiredFields =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Type for the Int64Range input object.
-}
type alias Int64Range =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Encode a Int64Range into a value that can be used as an argument.
-}
encodeInt64Range : Int64Range -> Value
encodeInt64Range input____ =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input____.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input____.max |> Just ) ]


buildIntFilter :
    (IntFilterOptionalFields -> IntFilterOptionalFields)
    -> IntFilter
buildIntFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input____.eq ), ( "in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.int |> Encode.optional input____.le ), ( "lt", Encode.int |> Encode.optional input____.lt ), ( "ge", Encode.int |> Encode.optional input____.ge ), ( "gt", Encode.int |> Encode.optional input____.gt ), ( "between", encodeIntRange |> Encode.optional input____.between ) ]


buildIntRange :
    IntRangeRequiredFields
    -> IntRange
buildIntRange required____ =
    { min = required____.min, max = required____.max }


type alias IntRangeRequiredFields =
    { min : Int
    , max : Int
    }


{-| Type for the IntRange input object.
-}
type alias IntRange =
    { min : Int
    , max : Int
    }


{-| Encode a IntRange into a value that can be used as an argument.
-}
encodeIntRange : IntRange -> Value
encodeIntRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.int input____.min |> Just ), ( "max", Encode.int input____.max |> Just ) ]


buildIntersectsFilter :
    (IntersectsFilterOptionalFields -> IntersectsFilterOptionalFields)
    -> IntersectsFilter
buildIntersectsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { polygon = Absent, multiPolygon = Absent }
    in
    { polygon = optionals____.polygon, multiPolygon = optionals____.multiPolygon }


type alias IntersectsFilterOptionalFields =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Type for the IntersectsFilter input object.
-}
type alias IntersectsFilter =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Encode a IntersectsFilter into a value that can be used as an argument.
-}
encodeIntersectsFilter : IntersectsFilter -> Value
encodeIntersectsFilter input____ =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef |> Encode.optional input____.polygon ), ( "multiPolygon", encodeMultiPolygonRef |> Encode.optional input____.multiPolygon ) ]


buildLabelFilter :
    (LabelFilterOptionalFields -> LabelFilterOptionalFields)
    -> LabelFilter
buildLabelFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input____.rootnameid ), ( "name", encodeStringHashFilter_StringTermFilter |> Encode.optional input____.name ), ( "has", (Encode.enum Fractal.Enum.LabelHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeLabelFilter |> Encode.optional input____.not ) ]


buildLabelOrder :
    (LabelOrderOptionalFields -> LabelOrderOptionalFields)
    -> LabelOrder
buildLabelOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeLabelOrder |> Encode.optional input____.then_ ) ]


buildLabelPatch :
    (LabelPatchOptionalFields -> LabelPatchOptionalFields)
    -> LabelPatch
buildLabelPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    LabelPatch { rootnameid = optionals____.rootnameid, name = optionals____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes, n_tensions = optionals____.n_tensions }


type alias LabelPatchOptionalFields =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `LabelPatch` attributes. Note that this type
needs to use the `LabelPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelPatchRaw =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the LabelPatch input object.
-}
type LabelPatch
    = LabelPatch LabelPatchRaw


{-| Encode a LabelPatch into a value that can be used as an argument.
-}
encodeLabelPatch : LabelPatch -> Value
encodeLabelPatch (LabelPatch input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input____.n_tensions ) ]


buildLabelRef :
    (LabelRefOptionalFields -> LabelRefOptionalFields)
    -> LabelRef
buildLabelRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent, n_nodes = Absent, n_tensions = Absent }
    in
    LabelRef { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes, n_tensions = optionals____.n_tensions }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type alias for the `LabelRef` attributes. Note that this type
needs to use the `LabelRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    , n_tensions : OptionalArgument Int
    }


{-| Type for the LabelRef input object.
-}
type LabelRef
    = LabelRef LabelRefRaw


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef (LabelRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ), ( "n_tensions", Encode.int |> Encode.optional input____.n_tensions ) ]


buildMandateFilter :
    (MandateFilterOptionalFields -> MandateFilterOptionalFields)
    -> MandateFilter
buildMandateFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, purpose = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals____.id, purpose = optionals____.purpose, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input____.purpose ), ( "has", (Encode.enum Fractal.Enum.MandateHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeMandateFilter |> Encode.optional input____.not ) ]


buildMandateOrder :
    (MandateOrderOptionalFields -> MandateOrderOptionalFields)
    -> MandateOrder
buildMandateOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeMandateOrder |> Encode.optional input____.then_ ) ]


buildMandatePatch :
    (MandatePatchOptionalFields -> MandatePatchOptionalFields)
    -> MandatePatch
buildMandatePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = optionals____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias MandatePatchOptionalFields =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandatePatch input object.
-}
type alias MandatePatch =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch input____ =
    Encode.maybeObject
        [ ( "purpose", Encode.string |> Encode.optional input____.purpose ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildMandateRef :
    (MandateRefOptionalFields -> MandateRefOptionalFields)
    -> MandateRef
buildMandateRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { id = optionals____.id, purpose = optionals____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandateRef input object.
-}
type alias MandateRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef input____ =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "purpose", Encode.string |> Encode.optional input____.purpose ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildMultiPolygonRef :
    MultiPolygonRefRequiredFields
    -> MultiPolygonRef
buildMultiPolygonRef required____ =
    { polygons = required____.polygons }


type alias MultiPolygonRefRequiredFields =
    { polygons : List PolygonRef }


{-| Type for the MultiPolygonRef input object.
-}
type alias MultiPolygonRef =
    { polygons : List PolygonRef }


{-| Encode a MultiPolygonRef into a value that can be used as an argument.
-}
encodeMultiPolygonRef : MultiPolygonRef -> Value
encodeMultiPolygonRef input____ =
    Encode.maybeObject
        [ ( "polygons", (encodePolygonRef |> Encode.list) input____.polygons |> Just ) ]


buildNearFilter :
    NearFilterRequiredFields
    -> NearFilter
buildNearFilter required____ =
    { distance = required____.distance, coordinate = required____.coordinate }


type alias NearFilterRequiredFields =
    { distance : Float
    , coordinate : PointRef
    }


{-| Type for the NearFilter input object.
-}
type alias NearFilter =
    { distance : Float
    , coordinate : PointRef
    }


{-| Encode a NearFilter into a value that can be used as an argument.
-}
encodeNearFilter : NearFilter -> Value
encodeNearFilter input____ =
    Encode.maybeObject
        [ ( "distance", Encode.float input____.distance |> Just ), ( "coordinate", encodePointRef input____.coordinate |> Just ) ]


buildNodeFilter :
    (NodeFilterOptionalFields -> NodeFilterOptionalFields)
    -> NodeFilter
buildNodeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, type_ = Absent, about = Absent, visibility = Absent, mode = Absent, isArchived = Absent, isRoot = Absent, isPersonal = Absent, skills = Absent, role_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals____.id, createdAt = optionals____.createdAt, name = optionals____.name, nameid = optionals____.nameid, rootnameid = optionals____.rootnameid, type_ = optionals____.type_, about = optionals____.about, visibility = optionals____.visibility, mode = optionals____.mode, isArchived = optionals____.isArchived, isRoot = optionals____.isRoot, isPersonal = optionals____.isPersonal, skills = optionals____.skills, role_type = optionals____.role_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , visibility : OptionalArgument NodeVisibility_hash
    , mode : OptionalArgument NodeMode_hash
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , name : OptionalArgument StringTermFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , type_ : OptionalArgument NodeType_hash
    , about : OptionalArgument StringFullTextFilter
    , visibility : OptionalArgument NodeVisibility_hash
    , mode : OptionalArgument NodeMode_hash
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , skills : OptionalArgument StringTermFilter
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "name", encodeStringTermFilter |> Encode.optional input____.name ), ( "nameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.nameid ), ( "rootnameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.rootnameid ), ( "type_", encodeNodeType_hash |> Encode.optional input____.type_ ), ( "about", encodeStringFullTextFilter |> Encode.optional input____.about ), ( "visibility", encodeNodeVisibility_hash |> Encode.optional input____.visibility ), ( "mode", encodeNodeMode_hash |> Encode.optional input____.mode ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "skills", encodeStringTermFilter |> Encode.optional input____.skills ), ( "role_type", encodeRoleType_hash |> Encode.optional input____.role_type ), ( "has", (Encode.enum Fractal.Enum.NodeHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeNodeFilter |> Encode.optional input____.not ) ]


buildNodeFragmentFilter :
    (NodeFragmentFilterOptionalFields -> NodeFragmentFilterOptionalFields)
    -> NodeFragmentFilter
buildNodeFragmentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFragmentFilter { id = optionals____.id, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias NodeFragmentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type alias for the `NodeFragmentFilter` attributes. Note that this type
needs to use the `NodeFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type for the NodeFragmentFilter input object.
-}
type NodeFragmentFilter
    = NodeFragmentFilter NodeFragmentFilterRaw


{-| Encode a NodeFragmentFilter into a value that can be used as an argument.
-}
encodeNodeFragmentFilter : NodeFragmentFilter -> Value
encodeNodeFragmentFilter (NodeFragmentFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "has", (Encode.enum Fractal.Enum.NodeFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeNodeFragmentFilter |> Encode.optional input____.not ) ]


buildNodeFragmentOrder :
    (NodeFragmentOrderOptionalFields -> NodeFragmentOrderOptionalFields)
    -> NodeFragmentOrder
buildNodeFragmentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeFragmentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias NodeFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type alias for the `NodeFragmentOrder` attributes. Note that this type
needs to use the `NodeFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type for the NodeFragmentOrder input object.
-}
type NodeFragmentOrder
    = NodeFragmentOrder NodeFragmentOrderRaw


{-| Encode a NodeFragmentOrder into a value that can be used as an argument.
-}
encodeNodeFragmentOrder : NodeFragmentOrder -> Value
encodeNodeFragmentOrder (NodeFragmentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeNodeFragmentOrder |> Encode.optional input____.then_ ) ]


buildNodeFragmentPatch :
    (NodeFragmentPatchOptionalFields -> NodeFragmentPatchOptionalFields)
    -> NodeFragmentPatch
buildNodeFragmentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, children = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, second_link = Absent, role_type = Absent }
    in
    NodeFragmentPatch { nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, children = optionals____.children, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, second_link = optionals____.second_link, role_type = optionals____.role_type }


type alias NodeFragmentPatchOptionalFields =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentPatch` attributes. Note that this type
needs to use the `NodeFragmentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentPatchRaw =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentPatch input object.
-}
type NodeFragmentPatch
    = NodeFragmentPatch NodeFragmentPatchRaw


{-| Encode a NodeFragmentPatch into a value that can be used as an argument.
-}
encodeNodeFragmentPatch : NodeFragmentPatch -> Value
encodeNodeFragmentPatch (NodeFragmentPatch input____) =
    Encode.maybeObject
        [ ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input____.children ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "second_link", Encode.string |> Encode.optional input____.second_link ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ) ]


buildNodeFragmentRef :
    (NodeFragmentRefOptionalFields -> NodeFragmentRefOptionalFields)
    -> NodeFragmentRef
buildNodeFragmentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, children = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, second_link = Absent, role_type = Absent }
    in
    NodeFragmentRef { id = optionals____.id, nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, children = optionals____.children, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, second_link = optionals____.second_link, role_type = optionals____.role_type }


type alias NodeFragmentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type alias for the `NodeFragmentRef` attributes. Note that this type
needs to use the `NodeFragmentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , children : OptionalArgument (List NodeFragmentRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , second_link : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    }


{-| Type for the NodeFragmentRef input object.
-}
type NodeFragmentRef
    = NodeFragmentRef NodeFragmentRefRaw


{-| Encode a NodeFragmentRef into a value that can be used as an argument.
-}
encodeNodeFragmentRef : NodeFragmentRef -> Value
encodeNodeFragmentRef (NodeFragmentRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "children", (encodeNodeFragmentRef |> Encode.list) |> Encode.optional input____.children ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "second_link", Encode.string |> Encode.optional input____.second_link ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ) ]


buildNodeMode_hash :
    (NodeMode_hashOptionalFields -> NodeMode_hashOptionalFields)
    -> NodeMode_hash
buildNodeMode_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeMode_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Type for the NodeMode\_hash input object.
-}
type alias NodeMode_hash =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Encode a NodeMode\_hash into a value that can be used as an argument.
-}
encodeNodeMode_hash : NodeMode_hash -> Value
encodeNodeMode_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeMode.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildNodeOrder :
    (NodeOrderOptionalFields -> NodeOrderOptionalFields)
    -> NodeOrder
buildNodeOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeNodeOrder |> Encode.optional input____.then_ ) ]


buildNodePatch :
    (NodePatchOptionalFields -> NodePatchOptionalFields)
    -> NodePatch
buildNodePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, labels = Absent, visibility = Absent, mode = Absent, rights = Absent, isArchived = Absent, isRoot = Absent, isPersonal = Absent, userCanJoin = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, role_ext = Absent, contracts = Absent, orga_agg = Absent }
    in
    NodePatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, name = optionals____.name, nameid = optionals____.nameid, rootnameid = optionals____.rootnameid, parent = optionals____.parent, children = optionals____.children, type_ = optionals____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, about = optionals____.about, mandate = optionals____.mandate, docs = optionals____.docs, source = optionals____.source, labels = optionals____.labels, visibility = optionals____.visibility, mode = optionals____.mode, rights = optionals____.rights, isArchived = optionals____.isArchived, isRoot = optionals____.isRoot, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, first_link = optionals____.first_link, second_link = optionals____.second_link, skills = optionals____.skills, role_type = optionals____.role_type, role_ext = optionals____.role_ext, contracts = optionals____.contracts, orga_agg = optionals____.orga_agg }


type alias NodePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "name", Encode.string |> Encode.optional input____.name ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input____.docs ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "rights", Encode.int |> Encode.optional input____.rights ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "second_link", encodeUserRef |> Encode.optional input____.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input____.orga_agg ) ]


buildNodeRef :
    (NodeRefOptionalFields -> NodeRefOptionalFields)
    -> NodeRef
buildNodeRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, name = Absent, nameid = Absent, rootnameid = Absent, parent = Absent, children = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, about = Absent, mandate = Absent, docs = Absent, source = Absent, labels = Absent, visibility = Absent, mode = Absent, rights = Absent, isArchived = Absent, isRoot = Absent, isPersonal = Absent, userCanJoin = Absent, first_link = Absent, second_link = Absent, skills = Absent, role_type = Absent, role_ext = Absent, contracts = Absent, orga_agg = Absent }
    in
    NodeRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, name = optionals____.name, nameid = optionals____.nameid, rootnameid = optionals____.rootnameid, parent = optionals____.parent, children = optionals____.children, type_ = optionals____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, about = optionals____.about, mandate = optionals____.mandate, docs = optionals____.docs, source = optionals____.source, labels = optionals____.labels, visibility = optionals____.visibility, mode = optionals____.mode, rights = optionals____.rights, isArchived = optionals____.isArchived, isRoot = optionals____.isRoot, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, first_link = optionals____.first_link, second_link = optionals____.second_link, skills = optionals____.skills, role_type = optionals____.role_type, role_ext = optionals____.role_ext, contracts = optionals____.contracts, orga_agg = optionals____.orga_agg }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type alias for the `NodeRef` attributes. Note that this type
needs to use the `NodeRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , parent : OptionalArgument NodeRef
    , children : OptionalArgument (List NodeRef)
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , docs : OptionalArgument (List (Maybe BlobRef))
    , source : OptionalArgument BlobRef
    , labels : OptionalArgument (List LabelRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isRoot : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , first_link : OptionalArgument UserRef
    , second_link : OptionalArgument UserRef
    , skills : OptionalArgument (List String)
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , role_ext : OptionalArgument RoleExtRef
    , contracts : OptionalArgument (List VoteRef)
    , orga_agg : OptionalArgument OrgaAggRef
    }


{-| Type for the NodeRef input object.
-}
type NodeRef
    = NodeRef NodeRefRaw


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef (NodeRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "name", Encode.string |> Encode.optional input____.name ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "docs", (encodeBlobRef |> Encode.maybe |> Encode.list) |> Encode.optional input____.docs ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "rights", Encode.int |> Encode.optional input____.rights ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "second_link", encodeUserRef |> Encode.optional input____.second_link ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "orga_agg", encodeOrgaAggRef |> Encode.optional input____.orga_agg ) ]


buildNodeType_hash :
    (NodeType_hashOptionalFields -> NodeType_hashOptionalFields)
    -> NodeType_hash
buildNodeType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Type for the NodeType\_hash input object.
-}
type alias NodeType_hash =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Encode a NodeType\_hash into a value that can be used as an argument.
-}
encodeNodeType_hash : NodeType_hash -> Value
encodeNodeType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildNodeVisibility_hash :
    (NodeVisibility_hashOptionalFields -> NodeVisibility_hashOptionalFields)
    -> NodeVisibility_hash
buildNodeVisibility_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeVisibility_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeVisibility.NodeVisibility))
    }


{-| Type for the NodeVisibility\_hash input object.
-}
type alias NodeVisibility_hash =
    { eq : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeVisibility.NodeVisibility))
    }


{-| Encode a NodeVisibility\_hash into a value that can be used as an argument.
-}
encodeNodeVisibility_hash : NodeVisibility_hash -> Value
encodeNodeVisibility_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildOrgaAggFilter :
    (OrgaAggFilterOptionalFields -> OrgaAggFilterOptionalFields)
    -> OrgaAggFilter
buildOrgaAggFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    OrgaAggFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias OrgaAggFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.OrgaAggHasFilter.OrgaAggHasFilter))
    , and : OptionalArgument (List (Maybe OrgaAggFilter))
    , or : OptionalArgument (List (Maybe OrgaAggFilter))
    , not : OptionalArgument OrgaAggFilter
    }


{-| Type alias for the `OrgaAggFilter` attributes. Note that this type
needs to use the `OrgaAggFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias OrgaAggFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.OrgaAggHasFilter.OrgaAggHasFilter))
    , and : OptionalArgument (List (Maybe OrgaAggFilter))
    , or : OptionalArgument (List (Maybe OrgaAggFilter))
    , not : OptionalArgument OrgaAggFilter
    }


{-| Type for the OrgaAggFilter input object.
-}
type OrgaAggFilter
    = OrgaAggFilter OrgaAggFilterRaw


{-| Encode a OrgaAggFilter into a value that can be used as an argument.
-}
encodeOrgaAggFilter : OrgaAggFilter -> Value
encodeOrgaAggFilter (OrgaAggFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.OrgaAggHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeOrgaAggFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeOrgaAggFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeOrgaAggFilter |> Encode.optional input____.not ) ]


buildOrgaAggOrder :
    (OrgaAggOrderOptionalFields -> OrgaAggOrderOptionalFields)
    -> OrgaAggOrder
buildOrgaAggOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    OrgaAggOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias OrgaAggOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , desc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , then_ : OptionalArgument OrgaAggOrder
    }


{-| Type alias for the `OrgaAggOrder` attributes. Note that this type
needs to use the `OrgaAggOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias OrgaAggOrderRaw =
    { asc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , desc : OptionalArgument Fractal.Enum.OrgaAggOrderable.OrgaAggOrderable
    , then_ : OptionalArgument OrgaAggOrder
    }


{-| Type for the OrgaAggOrder input object.
-}
type OrgaAggOrder
    = OrgaAggOrder OrgaAggOrderRaw


{-| Encode a OrgaAggOrder into a value that can be used as an argument.
-}
encodeOrgaAggOrder : OrgaAggOrder -> Value
encodeOrgaAggOrder (OrgaAggOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.OrgaAggOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.OrgaAggOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeOrgaAggOrder |> Encode.optional input____.then_ ) ]


buildOrgaAggPatch :
    (OrgaAggPatchOptionalFields -> OrgaAggPatchOptionalFields)
    -> OrgaAggPatch
buildOrgaAggPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals____.n_members, n_guests = optionals____.n_guests }


type alias OrgaAggPatchOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the OrgaAggPatch input object.
-}
type alias OrgaAggPatch =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a OrgaAggPatch into a value that can be used as an argument.
-}
encodeOrgaAggPatch : OrgaAggPatch -> Value
encodeOrgaAggPatch input____ =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input____.n_members ), ( "n_guests", Encode.int |> Encode.optional input____.n_guests ) ]


buildOrgaAggRef :
    (OrgaAggRefOptionalFields -> OrgaAggRefOptionalFields)
    -> OrgaAggRef
buildOrgaAggRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { n_members = Absent, n_guests = Absent }
    in
    { n_members = optionals____.n_members, n_guests = optionals____.n_guests }


type alias OrgaAggRefOptionalFields =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Type for the OrgaAggRef input object.
-}
type alias OrgaAggRef =
    { n_members : OptionalArgument Int
    , n_guests : OptionalArgument Int
    }


{-| Encode a OrgaAggRef into a value that can be used as an argument.
-}
encodeOrgaAggRef : OrgaAggRef -> Value
encodeOrgaAggRef input____ =
    Encode.maybeObject
        [ ( "n_members", Encode.int |> Encode.optional input____.n_members ), ( "n_guests", Encode.int |> Encode.optional input____.n_guests ) ]


buildPendingUserFilter :
    (PendingUserFilterOptionalFields -> PendingUserFilterOptionalFields)
    -> PendingUserFilter
buildPendingUserFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    PendingUserFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias PendingUserFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.PendingUserHasFilter.PendingUserHasFilter))
    , and : OptionalArgument (List (Maybe PendingUserFilter))
    , or : OptionalArgument (List (Maybe PendingUserFilter))
    , not : OptionalArgument PendingUserFilter
    }


{-| Type alias for the `PendingUserFilter` attributes. Note that this type
needs to use the `PendingUserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.PendingUserHasFilter.PendingUserHasFilter))
    , and : OptionalArgument (List (Maybe PendingUserFilter))
    , or : OptionalArgument (List (Maybe PendingUserFilter))
    , not : OptionalArgument PendingUserFilter
    }


{-| Type for the PendingUserFilter input object.
-}
type PendingUserFilter
    = PendingUserFilter PendingUserFilterRaw


{-| Encode a PendingUserFilter into a value that can be used as an argument.
-}
encodePendingUserFilter : PendingUserFilter -> Value
encodePendingUserFilter (PendingUserFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.PendingUserHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodePendingUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodePendingUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodePendingUserFilter |> Encode.optional input____.not ) ]


buildPendingUserOrder :
    (PendingUserOrderOptionalFields -> PendingUserOrderOptionalFields)
    -> PendingUserOrder
buildPendingUserOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PendingUserOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias PendingUserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , desc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , then_ : OptionalArgument PendingUserOrder
    }


{-| Type alias for the `PendingUserOrder` attributes. Note that this type
needs to use the `PendingUserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , desc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , then_ : OptionalArgument PendingUserOrder
    }


{-| Type for the PendingUserOrder input object.
-}
type PendingUserOrder
    = PendingUserOrder PendingUserOrderRaw


{-| Encode a PendingUserOrder into a value that can be used as an argument.
-}
encodePendingUserOrder : PendingUserOrder -> Value
encodePendingUserOrder (PendingUserOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PendingUserOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.PendingUserOrderable.toString |> Encode.optional input____.desc ), ( "then", encodePendingUserOrder |> Encode.optional input____.then_ ) ]


buildPendingUserPatch :
    (PendingUserPatchOptionalFields -> PendingUserPatchOptionalFields)
    -> PendingUserPatch
buildPendingUserPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { email = Absent }
    in
    { email = optionals____.email }


type alias PendingUserPatchOptionalFields =
    { email : OptionalArgument String }


{-| Type for the PendingUserPatch input object.
-}
type alias PendingUserPatch =
    { email : OptionalArgument String }


{-| Encode a PendingUserPatch into a value that can be used as an argument.
-}
encodePendingUserPatch : PendingUserPatch -> Value
encodePendingUserPatch input____ =
    Encode.maybeObject
        [ ( "email", Encode.string |> Encode.optional input____.email ) ]


buildPendingUserRef :
    (PendingUserRefOptionalFields -> PendingUserRefOptionalFields)
    -> PendingUserRef
buildPendingUserRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { email = Absent }
    in
    { email = optionals____.email }


type alias PendingUserRefOptionalFields =
    { email : OptionalArgument String }


{-| Type for the PendingUserRef input object.
-}
type alias PendingUserRef =
    { email : OptionalArgument String }


{-| Encode a PendingUserRef into a value that can be used as an argument.
-}
encodePendingUserRef : PendingUserRef -> Value
encodePendingUserRef input____ =
    Encode.maybeObject
        [ ( "email", Encode.string |> Encode.optional input____.email ) ]


buildPointGeoFilter :
    (PointGeoFilterOptionalFields -> PointGeoFilterOptionalFields)
    -> PointGeoFilter
buildPointGeoFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { near = Absent, within = Absent }
    in
    { near = optionals____.near, within = optionals____.within }


type alias PointGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Type for the PointGeoFilter input object.
-}
type alias PointGeoFilter =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Encode a PointGeoFilter into a value that can be used as an argument.
-}
encodePointGeoFilter : PointGeoFilter -> Value
encodePointGeoFilter input____ =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input____.near ), ( "within", encodeWithinFilter |> Encode.optional input____.within ) ]


buildPointListRef :
    PointListRefRequiredFields
    -> PointListRef
buildPointListRef required____ =
    { points = required____.points }


type alias PointListRefRequiredFields =
    { points : List PointRef }


{-| Type for the PointListRef input object.
-}
type alias PointListRef =
    { points : List PointRef }


{-| Encode a PointListRef into a value that can be used as an argument.
-}
encodePointListRef : PointListRef -> Value
encodePointListRef input____ =
    Encode.maybeObject
        [ ( "points", (encodePointRef |> Encode.list) input____.points |> Just ) ]


buildPointRef :
    PointRefRequiredFields
    -> PointRef
buildPointRef required____ =
    { longitude = required____.longitude, latitude = required____.latitude }


type alias PointRefRequiredFields =
    { longitude : Float
    , latitude : Float
    }


{-| Type for the PointRef input object.
-}
type alias PointRef =
    { longitude : Float
    , latitude : Float
    }


{-| Encode a PointRef into a value that can be used as an argument.
-}
encodePointRef : PointRef -> Value
encodePointRef input____ =
    Encode.maybeObject
        [ ( "longitude", Encode.float input____.longitude |> Just ), ( "latitude", Encode.float input____.latitude |> Just ) ]


buildPolygonGeoFilter :
    (PolygonGeoFilterOptionalFields -> PolygonGeoFilterOptionalFields)
    -> PolygonGeoFilter
buildPolygonGeoFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { near = Absent, within = Absent, contains = Absent, intersects = Absent }
    in
    { near = optionals____.near, within = optionals____.within, contains = optionals____.contains, intersects = optionals____.intersects }


type alias PolygonGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Type for the PolygonGeoFilter input object.
-}
type alias PolygonGeoFilter =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Encode a PolygonGeoFilter into a value that can be used as an argument.
-}
encodePolygonGeoFilter : PolygonGeoFilter -> Value
encodePolygonGeoFilter input____ =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input____.near ), ( "within", encodeWithinFilter |> Encode.optional input____.within ), ( "contains", encodeContainsFilter |> Encode.optional input____.contains ), ( "intersects", encodeIntersectsFilter |> Encode.optional input____.intersects ) ]


buildPolygonRef :
    PolygonRefRequiredFields
    -> PolygonRef
buildPolygonRef required____ =
    { coordinates = required____.coordinates }


type alias PolygonRefRequiredFields =
    { coordinates : List PointListRef }


{-| Type for the PolygonRef input object.
-}
type alias PolygonRef =
    { coordinates : List PointListRef }


{-| Encode a PolygonRef into a value that can be used as an argument.
-}
encodePolygonRef : PolygonRef -> Value
encodePolygonRef input____ =
    Encode.maybeObject
        [ ( "coordinates", (encodePointListRef |> Encode.list) input____.coordinates |> Just ) ]


buildPostFilter :
    (PostFilterOptionalFields -> PostFilterOptionalFields)
    -> PostFilter
buildPostFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "has", (Encode.enum Fractal.Enum.PostHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodePostFilter |> Encode.optional input____.not ) ]


buildPostOrder :
    (PostOrderOptionalFields -> PostOrderOptionalFields)
    -> PostOrder
buildPostOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input____.desc ), ( "then", encodePostOrder |> Encode.optional input____.then_ ) ]


buildPostPatch :
    (PostPatchOptionalFields -> PostPatchOptionalFields)
    -> PostPatch
buildPostPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent }
    in
    PostPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message }


type alias PostPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ) ]


buildPostRef :
    PostRefRequiredFields
    -> PostRef
buildPostRef required____ =
    { id = required____.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input____ =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input____.id |> Just ) ]


buildRoleExtFilter :
    (RoleExtFilterOptionalFields -> RoleExtFilterOptionalFields)
    -> RoleExtFilter
buildRoleExtFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    RoleExtFilter { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias RoleExtFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.RoleExtHasFilter.RoleExtHasFilter))
    , and : OptionalArgument (List (Maybe RoleExtFilter))
    , or : OptionalArgument (List (Maybe RoleExtFilter))
    , not : OptionalArgument RoleExtFilter
    }


{-| Type alias for the `RoleExtFilter` attributes. Note that this type
needs to use the `RoleExtFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.RoleExtHasFilter.RoleExtHasFilter))
    , and : OptionalArgument (List (Maybe RoleExtFilter))
    , or : OptionalArgument (List (Maybe RoleExtFilter))
    , not : OptionalArgument RoleExtFilter
    }


{-| Type for the RoleExtFilter input object.
-}
type RoleExtFilter
    = RoleExtFilter RoleExtFilterRaw


{-| Encode a RoleExtFilter into a value that can be used as an argument.
-}
encodeRoleExtFilter : RoleExtFilter -> Value
encodeRoleExtFilter (RoleExtFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input____.rootnameid ), ( "name", encodeStringHashFilter_StringTermFilter |> Encode.optional input____.name ), ( "has", (Encode.enum Fractal.Enum.RoleExtHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeRoleExtFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeRoleExtFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeRoleExtFilter |> Encode.optional input____.not ) ]


buildRoleExtOrder :
    (RoleExtOrderOptionalFields -> RoleExtOrderOptionalFields)
    -> RoleExtOrder
buildRoleExtOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    RoleExtOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias RoleExtOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , desc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , then_ : OptionalArgument RoleExtOrder
    }


{-| Type alias for the `RoleExtOrder` attributes. Note that this type
needs to use the `RoleExtOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtOrderRaw =
    { asc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , desc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , then_ : OptionalArgument RoleExtOrder
    }


{-| Type for the RoleExtOrder input object.
-}
type RoleExtOrder
    = RoleExtOrder RoleExtOrderRaw


{-| Encode a RoleExtOrder into a value that can be used as an argument.
-}
encodeRoleExtOrder : RoleExtOrder -> Value
encodeRoleExtOrder (RoleExtOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.RoleExtOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.RoleExtOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeRoleExtOrder |> Encode.optional input____.then_ ) ]


buildRoleExtPatch :
    (RoleExtPatchOptionalFields -> RoleExtPatchOptionalFields)
    -> RoleExtPatch
buildRoleExtPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { rootnameid = Absent, name = Absent, about = Absent, role_type = Absent, color = Absent, mandate = Absent, nodes = Absent, n_nodes = Absent }
    in
    RoleExtPatch { rootnameid = optionals____.rootnameid, name = optionals____.name, about = optionals____.about, role_type = optionals____.role_type, color = optionals____.color, mandate = optionals____.mandate, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes }


type alias RoleExtPatchOptionalFields =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type alias for the `RoleExtPatch` attributes. Note that this type
needs to use the `RoleExtPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtPatchRaw =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type for the RoleExtPatch input object.
-}
type RoleExtPatch
    = RoleExtPatch RoleExtPatchRaw


{-| Encode a RoleExtPatch into a value that can be used as an argument.
-}
encodeRoleExtPatch : RoleExtPatch -> Value
encodeRoleExtPatch (RoleExtPatch input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ) ]


buildRoleExtRef :
    (RoleExtRefOptionalFields -> RoleExtRefOptionalFields)
    -> RoleExtRef
buildRoleExtRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, about = Absent, role_type = Absent, color = Absent, mandate = Absent, nodes = Absent, n_nodes = Absent }
    in
    RoleExtRef { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, about = optionals____.about, role_type = optionals____.role_type, color = optionals____.color, mandate = optionals____.mandate, nodes = optionals____.nodes, n_nodes = optionals____.n_nodes }


type alias RoleExtRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type alias for the `RoleExtRef` attributes. Note that this type
needs to use the `RoleExtRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , nodes : OptionalArgument (List NodeRef)
    , n_nodes : OptionalArgument Int
    }


{-| Type for the RoleExtRef input object.
-}
type RoleExtRef
    = RoleExtRef RoleExtRefRaw


{-| Encode a RoleExtRef into a value that can be used as an argument.
-}
encodeRoleExtRef : RoleExtRef -> Value
encodeRoleExtRef (RoleExtRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ), ( "n_nodes", Encode.int |> Encode.optional input____.n_nodes ) ]


buildRoleType_hash :
    (RoleType_hashOptionalFields -> RoleType_hashOptionalFields)
    -> RoleType_hash
buildRoleType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias RoleType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Type for the RoleType\_hash input object.
-}
type alias RoleType_hash =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Encode a RoleType\_hash into a value that can be used as an argument.
-}
encodeRoleType_hash : RoleType_hash -> Value
encodeRoleType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.RoleType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildStringExactFilter :
    (StringExactFilterOptionalFields -> StringExactFilterOptionalFields)
    -> StringExactFilter
buildStringExactFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.string |> Encode.optional input____.le ), ( "lt", Encode.string |> Encode.optional input____.lt ), ( "ge", Encode.string |> Encode.optional input____.ge ), ( "gt", Encode.string |> Encode.optional input____.gt ), ( "between", encodeStringRange |> Encode.optional input____.between ) ]


buildStringFullTextFilter :
    (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields)
    -> StringFullTextFilter
buildStringFullTextFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals____.alloftext, anyoftext = optionals____.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input____ =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input____.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input____.anyoftext ) ]


buildStringHashFilter :
    (StringHashFilterOptionalFields -> StringHashFilterOptionalFields)
    -> StringHashFilter
buildStringHashFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildStringHashFilter_StringRegExpFilter :
    (StringHashFilter_StringRegExpFilterOptionalFields -> StringHashFilter_StringRegExpFilterOptionalFields)
    -> StringHashFilter_StringRegExpFilter
buildStringHashFilter_StringRegExpFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, regexp = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, regexp = optionals____.regexp }


type alias StringHashFilter_StringRegExpFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringRegExpFilter input object.
-}
type alias StringHashFilter_StringRegExpFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringRegExpFilter : StringHashFilter_StringRegExpFilter -> Value
encodeStringHashFilter_StringRegExpFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "regexp", Encode.string |> Encode.optional input____.regexp ) ]


buildStringHashFilter_StringTermFilter :
    (StringHashFilter_StringTermFilterOptionalFields -> StringHashFilter_StringTermFilterOptionalFields)
    -> StringHashFilter_StringTermFilter
buildStringHashFilter_StringTermFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, allofterms = Absent, anyofterms = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, allofterms = optionals____.allofterms, anyofterms = optionals____.anyofterms }


type alias StringHashFilter_StringTermFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringTermFilter input object.
-}
type alias StringHashFilter_StringTermFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringTermFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringTermFilter : StringHashFilter_StringTermFilter -> Value
encodeStringHashFilter_StringTermFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "allofterms", Encode.string |> Encode.optional input____.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input____.anyofterms ) ]


buildStringRange :
    StringRangeRequiredFields
    -> StringRange
buildStringRange required____ =
    { min = required____.min, max = required____.max }


type alias StringRangeRequiredFields =
    { min : String
    , max : String
    }


{-| Type for the StringRange input object.
-}
type alias StringRange =
    { min : String
    , max : String
    }


{-| Encode a StringRange into a value that can be used as an argument.
-}
encodeStringRange : StringRange -> Value
encodeStringRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.string input____.min |> Just ), ( "max", Encode.string input____.max |> Just ) ]


buildStringRegExpFilter :
    (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields)
    -> StringRegExpFilter
buildStringRegExpFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { regexp = Absent }
    in
    { regexp = optionals____.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input____ =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input____.regexp ) ]


buildStringTermFilter :
    (StringTermFilterOptionalFields -> StringTermFilterOptionalFields)
    -> StringTermFilter
buildStringTermFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals____.allofterms, anyofterms = optionals____.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input____ =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input____.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input____.anyofterms ) ]


buildTensionEvent_hash :
    (TensionEvent_hashOptionalFields -> TensionEvent_hashOptionalFields)
    -> TensionEvent_hash
buildTensionEvent_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionEvent_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Type for the TensionEvent\_hash input object.
-}
type alias TensionEvent_hash =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Encode a TensionEvent\_hash into a value that can be used as an argument.
-}
encodeTensionEvent_hash : TensionEvent_hash -> Value
encodeTensionEvent_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildTensionFilter :
    (TensionFilterOptionalFields -> TensionFilterOptionalFields)
    -> TensionFilter
buildTensionFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, emitterid = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, emitterid = optionals____.emitterid, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "emitterid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.emitterid ), ( "receiverid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.receiverid ), ( "title", encodeStringFullTextFilter |> Encode.optional input____.title ), ( "type_", encodeTensionType_hash |> Encode.optional input____.type_ ), ( "status", encodeTensionStatus_hash |> Encode.optional input____.status ), ( "has", (Encode.enum Fractal.Enum.TensionHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeTensionFilter |> Encode.optional input____.not ) ]


buildTensionOrder :
    (TensionOrderOptionalFields -> TensionOrderOptionalFields)
    -> TensionOrder
buildTensionOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeTensionOrder |> Encode.optional input____.then_ ) ]


buildTensionPatch :
    (TensionPatchOptionalFields -> TensionPatchOptionalFields)
    -> TensionPatch
buildTensionPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, action = Absent, comments = Absent, assignees = Absent, labels = Absent, blobs = Absent, history = Absent, contracts = Absent, suscribers = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    TensionPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = optionals____.emitter, emitterid = optionals____.emitterid, receiver = optionals____.receiver, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, action = optionals____.action, comments = optionals____.comments, assignees = optionals____.assignees, labels = optionals____.labels, blobs = optionals____.blobs, history = optionals____.history, contracts = optionals____.contracts, suscribers = optionals____.suscribers, n_comments = optionals____.n_comments, n_open_contracts = optionals____.n_open_contracts }


type alias TensionPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef |> Encode.optional input____.emitter ), ( "emitterid", Encode.string |> Encode.optional input____.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input____.receiver ), ( "receiverid", Encode.string |> Encode.optional input____.receiverid ), ( "title", Encode.string |> Encode.optional input____.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input____.history ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "suscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.suscribers ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input____.n_open_contracts ) ]


buildTensionRef :
    (TensionRefOptionalFields -> TensionRefOptionalFields)
    -> TensionRef
buildTensionRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, action = Absent, comments = Absent, assignees = Absent, labels = Absent, blobs = Absent, history = Absent, contracts = Absent, suscribers = Absent, n_comments = Absent, n_open_contracts = Absent }
    in
    TensionRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = optionals____.emitter, emitterid = optionals____.emitterid, receiver = optionals____.receiver, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, action = optionals____.action, comments = optionals____.comments, assignees = optionals____.assignees, labels = optionals____.labels, blobs = optionals____.blobs, history = optionals____.history, contracts = optionals____.contracts, suscribers = optionals____.suscribers, n_comments = optionals____.n_comments, n_open_contracts = optionals____.n_open_contracts }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , comments : OptionalArgument (List CommentRef)
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , suscribers : OptionalArgument (List UserRef)
    , n_comments : OptionalArgument Int
    , n_open_contracts : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef |> Encode.optional input____.emitter ), ( "emitterid", Encode.string |> Encode.optional input____.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input____.receiver ), ( "receiverid", Encode.string |> Encode.optional input____.receiverid ), ( "title", Encode.string |> Encode.optional input____.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input____.history ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "suscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.suscribers ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ), ( "n_open_contracts", Encode.int |> Encode.optional input____.n_open_contracts ) ]


buildTensionStatus_hash :
    (TensionStatus_hashOptionalFields -> TensionStatus_hashOptionalFields)
    -> TensionStatus_hash
buildTensionStatus_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Type for the TensionStatus\_hash input object.
-}
type alias TensionStatus_hash =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Encode a TensionStatus\_hash into a value that can be used as an argument.
-}
encodeTensionStatus_hash : TensionStatus_hash -> Value
encodeTensionStatus_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildTensionType_hash :
    (TensionType_hashOptionalFields -> TensionType_hashOptionalFields)
    -> TensionType_hash
buildTensionType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildUpdateBlobInput :
    UpdateBlobInputRequiredFields
    -> (UpdateBlobInputOptionalFields -> UpdateBlobInputOptionalFields)
    -> UpdateBlobInput
buildUpdateBlobInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateBlobInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateBlobInputRequiredFields =
    { filter : BlobFilter }


type alias UpdateBlobInputOptionalFields =
    { set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type alias for the `UpdateBlobInput` attributes. Note that this type
needs to use the `UpdateBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateBlobInputRaw =
    { filter : BlobFilter
    , set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type for the UpdateBlobInput input object.
-}
type UpdateBlobInput
    = UpdateBlobInput UpdateBlobInputRaw


{-| Encode a UpdateBlobInput into a value that can be used as an argument.
-}
encodeUpdateBlobInput : UpdateBlobInput -> Value
encodeUpdateBlobInput (UpdateBlobInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeBlobFilter input____.filter |> Just ), ( "set", encodeBlobPatch |> Encode.optional input____.set ), ( "remove", encodeBlobPatch |> Encode.optional input____.remove ) ]


buildUpdateCommentInput :
    UpdateCommentInputRequiredFields
    -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields)
    -> UpdateCommentInput
buildUpdateCommentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input____.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input____.set ), ( "remove", encodeCommentPatch |> Encode.optional input____.remove ) ]


buildUpdateContractInput :
    UpdateContractInputRequiredFields
    -> (UpdateContractInputOptionalFields -> UpdateContractInputOptionalFields)
    -> UpdateContractInput
buildUpdateContractInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateContractInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateContractInputRequiredFields =
    { filter : ContractFilter }


type alias UpdateContractInputOptionalFields =
    { set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type alias for the `UpdateContractInput` attributes. Note that this type
needs to use the `UpdateContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateContractInputRaw =
    { filter : ContractFilter
    , set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type for the UpdateContractInput input object.
-}
type UpdateContractInput
    = UpdateContractInput UpdateContractInputRaw


{-| Encode a UpdateContractInput into a value that can be used as an argument.
-}
encodeUpdateContractInput : UpdateContractInput -> Value
encodeUpdateContractInput (UpdateContractInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeContractFilter input____.filter |> Just ), ( "set", encodeContractPatch |> Encode.optional input____.set ), ( "remove", encodeContractPatch |> Encode.optional input____.remove ) ]


buildUpdateEventFragmentInput :
    UpdateEventFragmentInputRequiredFields
    -> (UpdateEventFragmentInputOptionalFields -> UpdateEventFragmentInputOptionalFields)
    -> UpdateEventFragmentInput
buildUpdateEventFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateEventFragmentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateEventFragmentInputRequiredFields =
    { filter : EventFragmentFilter }


type alias UpdateEventFragmentInputOptionalFields =
    { set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type alias for the `UpdateEventFragmentInput` attributes. Note that this type
needs to use the `UpdateEventFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventFragmentInputRaw =
    { filter : EventFragmentFilter
    , set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type for the UpdateEventFragmentInput input object.
-}
type UpdateEventFragmentInput
    = UpdateEventFragmentInput UpdateEventFragmentInputRaw


{-| Encode a UpdateEventFragmentInput into a value that can be used as an argument.
-}
encodeUpdateEventFragmentInput : UpdateEventFragmentInput -> Value
encodeUpdateEventFragmentInput (UpdateEventFragmentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeEventFragmentFilter input____.filter |> Just ), ( "set", encodeEventFragmentPatch |> Encode.optional input____.set ), ( "remove", encodeEventFragmentPatch |> Encode.optional input____.remove ) ]


buildUpdateEventInput :
    UpdateEventInputRequiredFields
    -> (UpdateEventInputOptionalFields -> UpdateEventInputOptionalFields)
    -> UpdateEventInput
buildUpdateEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateEventInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateEventInputRequiredFields =
    { filter : EventFilter }


type alias UpdateEventInputOptionalFields =
    { set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type alias for the `UpdateEventInput` attributes. Note that this type
needs to use the `UpdateEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventInputRaw =
    { filter : EventFilter
    , set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type for the UpdateEventInput input object.
-}
type UpdateEventInput
    = UpdateEventInput UpdateEventInputRaw


{-| Encode a UpdateEventInput into a value that can be used as an argument.
-}
encodeUpdateEventInput : UpdateEventInput -> Value
encodeUpdateEventInput (UpdateEventInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeEventFilter input____.filter |> Just ), ( "set", encodeEventPatch |> Encode.optional input____.set ), ( "remove", encodeEventPatch |> Encode.optional input____.remove ) ]


buildUpdateLabelInput :
    UpdateLabelInputRequiredFields
    -> (UpdateLabelInputOptionalFields -> UpdateLabelInputOptionalFields)
    -> UpdateLabelInput
buildUpdateLabelInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateLabelInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateLabelInputRequiredFields =
    { filter : LabelFilter }


type alias UpdateLabelInputOptionalFields =
    { set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type alias for the `UpdateLabelInput` attributes. Note that this type
needs to use the `UpdateLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateLabelInputRaw =
    { filter : LabelFilter
    , set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type for the UpdateLabelInput input object.
-}
type UpdateLabelInput
    = UpdateLabelInput UpdateLabelInputRaw


{-| Encode a UpdateLabelInput into a value that can be used as an argument.
-}
encodeUpdateLabelInput : UpdateLabelInput -> Value
encodeUpdateLabelInput (UpdateLabelInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeLabelFilter input____.filter |> Just ), ( "set", encodeLabelPatch |> Encode.optional input____.set ), ( "remove", encodeLabelPatch |> Encode.optional input____.remove ) ]


buildUpdateMandateInput :
    UpdateMandateInputRequiredFields
    -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields)
    -> UpdateMandateInput
buildUpdateMandateInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input____.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input____.set ), ( "remove", encodeMandatePatch |> Encode.optional input____.remove ) ]


buildUpdateNodeFragmentInput :
    UpdateNodeFragmentInputRequiredFields
    -> (UpdateNodeFragmentInputOptionalFields -> UpdateNodeFragmentInputOptionalFields)
    -> UpdateNodeFragmentInput
buildUpdateNodeFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateNodeFragmentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateNodeFragmentInputRequiredFields =
    { filter : NodeFragmentFilter }


type alias UpdateNodeFragmentInputOptionalFields =
    { set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type alias for the `UpdateNodeFragmentInput` attributes. Note that this type
needs to use the `UpdateNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeFragmentInputRaw =
    { filter : NodeFragmentFilter
    , set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type for the UpdateNodeFragmentInput input object.
-}
type UpdateNodeFragmentInput
    = UpdateNodeFragmentInput UpdateNodeFragmentInputRaw


{-| Encode a UpdateNodeFragmentInput into a value that can be used as an argument.
-}
encodeUpdateNodeFragmentInput : UpdateNodeFragmentInput -> Value
encodeUpdateNodeFragmentInput (UpdateNodeFragmentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFragmentFilter input____.filter |> Just ), ( "set", encodeNodeFragmentPatch |> Encode.optional input____.set ), ( "remove", encodeNodeFragmentPatch |> Encode.optional input____.remove ) ]


buildUpdateNodeInput :
    UpdateNodeInputRequiredFields
    -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields)
    -> UpdateNodeInput
buildUpdateNodeInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input____.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input____.set ), ( "remove", encodeNodePatch |> Encode.optional input____.remove ) ]


buildUpdateOrgaAggInput :
    UpdateOrgaAggInputRequiredFields
    -> (UpdateOrgaAggInputOptionalFields -> UpdateOrgaAggInputOptionalFields)
    -> UpdateOrgaAggInput
buildUpdateOrgaAggInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateOrgaAggInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateOrgaAggInputRequiredFields =
    { filter : OrgaAggFilter }


type alias UpdateOrgaAggInputOptionalFields =
    { set : OptionalArgument OrgaAggPatch
    , remove : OptionalArgument OrgaAggPatch
    }


{-| Type alias for the `UpdateOrgaAggInput` attributes. Note that this type
needs to use the `UpdateOrgaAggInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateOrgaAggInputRaw =
    { filter : OrgaAggFilter
    , set : OptionalArgument OrgaAggPatch
    , remove : OptionalArgument OrgaAggPatch
    }


{-| Type for the UpdateOrgaAggInput input object.
-}
type UpdateOrgaAggInput
    = UpdateOrgaAggInput UpdateOrgaAggInputRaw


{-| Encode a UpdateOrgaAggInput into a value that can be used as an argument.
-}
encodeUpdateOrgaAggInput : UpdateOrgaAggInput -> Value
encodeUpdateOrgaAggInput (UpdateOrgaAggInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeOrgaAggFilter input____.filter |> Just ), ( "set", encodeOrgaAggPatch |> Encode.optional input____.set ), ( "remove", encodeOrgaAggPatch |> Encode.optional input____.remove ) ]


buildUpdatePendingUserInput :
    UpdatePendingUserInputRequiredFields
    -> (UpdatePendingUserInputOptionalFields -> UpdatePendingUserInputOptionalFields)
    -> UpdatePendingUserInput
buildUpdatePendingUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdatePendingUserInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdatePendingUserInputRequiredFields =
    { filter : PendingUserFilter }


type alias UpdatePendingUserInputOptionalFields =
    { set : OptionalArgument PendingUserPatch
    , remove : OptionalArgument PendingUserPatch
    }


{-| Type alias for the `UpdatePendingUserInput` attributes. Note that this type
needs to use the `UpdatePendingUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePendingUserInputRaw =
    { filter : PendingUserFilter
    , set : OptionalArgument PendingUserPatch
    , remove : OptionalArgument PendingUserPatch
    }


{-| Type for the UpdatePendingUserInput input object.
-}
type UpdatePendingUserInput
    = UpdatePendingUserInput UpdatePendingUserInputRaw


{-| Encode a UpdatePendingUserInput into a value that can be used as an argument.
-}
encodeUpdatePendingUserInput : UpdatePendingUserInput -> Value
encodeUpdatePendingUserInput (UpdatePendingUserInput input____) =
    Encode.maybeObject
        [ ( "filter", encodePendingUserFilter input____.filter |> Just ), ( "set", encodePendingUserPatch |> Encode.optional input____.set ), ( "remove", encodePendingUserPatch |> Encode.optional input____.remove ) ]


buildUpdatePostInput :
    UpdatePostInputRequiredFields
    -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields)
    -> UpdatePostInput
buildUpdatePostInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input____) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input____.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input____.set ), ( "remove", encodePostPatch |> Encode.optional input____.remove ) ]


buildUpdateRoleExtInput :
    UpdateRoleExtInputRequiredFields
    -> (UpdateRoleExtInputOptionalFields -> UpdateRoleExtInputOptionalFields)
    -> UpdateRoleExtInput
buildUpdateRoleExtInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateRoleExtInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateRoleExtInputRequiredFields =
    { filter : RoleExtFilter }


type alias UpdateRoleExtInputOptionalFields =
    { set : OptionalArgument RoleExtPatch
    , remove : OptionalArgument RoleExtPatch
    }


{-| Type alias for the `UpdateRoleExtInput` attributes. Note that this type
needs to use the `UpdateRoleExtInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateRoleExtInputRaw =
    { filter : RoleExtFilter
    , set : OptionalArgument RoleExtPatch
    , remove : OptionalArgument RoleExtPatch
    }


{-| Type for the UpdateRoleExtInput input object.
-}
type UpdateRoleExtInput
    = UpdateRoleExtInput UpdateRoleExtInputRaw


{-| Encode a UpdateRoleExtInput into a value that can be used as an argument.
-}
encodeUpdateRoleExtInput : UpdateRoleExtInput -> Value
encodeUpdateRoleExtInput (UpdateRoleExtInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeRoleExtFilter input____.filter |> Just ), ( "set", encodeRoleExtPatch |> Encode.optional input____.set ), ( "remove", encodeRoleExtPatch |> Encode.optional input____.remove ) ]


buildUpdateTensionInput :
    UpdateTensionInputRequiredFields
    -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields)
    -> UpdateTensionInput
buildUpdateTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input____.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input____.set ), ( "remove", encodeTensionPatch |> Encode.optional input____.remove ) ]


buildUpdateUserEventInput :
    UpdateUserEventInputRequiredFields
    -> (UpdateUserEventInputOptionalFields -> UpdateUserEventInputOptionalFields)
    -> UpdateUserEventInput
buildUpdateUserEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserEventInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserEventInputRequiredFields =
    { filter : UserEventFilter }


type alias UpdateUserEventInputOptionalFields =
    { set : OptionalArgument UserEventPatch
    , remove : OptionalArgument UserEventPatch
    }


{-| Type alias for the `UpdateUserEventInput` attributes. Note that this type
needs to use the `UpdateUserEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserEventInputRaw =
    { filter : UserEventFilter
    , set : OptionalArgument UserEventPatch
    , remove : OptionalArgument UserEventPatch
    }


{-| Type for the UpdateUserEventInput input object.
-}
type UpdateUserEventInput
    = UpdateUserEventInput UpdateUserEventInputRaw


{-| Encode a UpdateUserEventInput into a value that can be used as an argument.
-}
encodeUpdateUserEventInput : UpdateUserEventInput -> Value
encodeUpdateUserEventInput (UpdateUserEventInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserEventFilter input____.filter |> Just ), ( "set", encodeUserEventPatch |> Encode.optional input____.set ), ( "remove", encodeUserEventPatch |> Encode.optional input____.remove ) ]


buildUpdateUserInput :
    UpdateUserInputRequiredFields
    -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields)
    -> UpdateUserInput
buildUpdateUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input____.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input____.set ), ( "remove", encodeUserPatch |> Encode.optional input____.remove ) ]


buildUpdateUserRightsInput :
    UpdateUserRightsInputRequiredFields
    -> (UpdateUserRightsInputOptionalFields -> UpdateUserRightsInputOptionalFields)
    -> UpdateUserRightsInput
buildUpdateUserRightsInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserRightsInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserRightsInputRequiredFields =
    { filter : UserRightsFilter }


type alias UpdateUserRightsInputOptionalFields =
    { set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type alias for the `UpdateUserRightsInput` attributes. Note that this type
needs to use the `UpdateUserRightsInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserRightsInputRaw =
    { filter : UserRightsFilter
    , set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type for the UpdateUserRightsInput input object.
-}
type UpdateUserRightsInput
    = UpdateUserRightsInput UpdateUserRightsInputRaw


{-| Encode a UpdateUserRightsInput into a value that can be used as an argument.
-}
encodeUpdateUserRightsInput : UpdateUserRightsInput -> Value
encodeUpdateUserRightsInput (UpdateUserRightsInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserRightsFilter input____.filter |> Just ), ( "set", encodeUserRightsPatch |> Encode.optional input____.set ), ( "remove", encodeUserRightsPatch |> Encode.optional input____.remove ) ]


buildUpdateVoteInput :
    UpdateVoteInputRequiredFields
    -> (UpdateVoteInputOptionalFields -> UpdateVoteInputOptionalFields)
    -> UpdateVoteInput
buildUpdateVoteInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateVoteInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateVoteInputRequiredFields =
    { filter : VoteFilter }


type alias UpdateVoteInputOptionalFields =
    { set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type alias for the `UpdateVoteInput` attributes. Note that this type
needs to use the `UpdateVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateVoteInputRaw =
    { filter : VoteFilter
    , set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type for the UpdateVoteInput input object.
-}
type UpdateVoteInput
    = UpdateVoteInput UpdateVoteInputRaw


{-| Encode a UpdateVoteInput into a value that can be used as an argument.
-}
encodeUpdateVoteInput : UpdateVoteInput -> Value
encodeUpdateVoteInput (UpdateVoteInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeVoteFilter input____.filter |> Just ), ( "set", encodeVotePatch |> Encode.optional input____.set ), ( "remove", encodeVotePatch |> Encode.optional input____.remove ) ]


buildUserEventFilter :
    (UserEventFilterOptionalFields -> UserEventFilterOptionalFields)
    -> UserEventFilter
buildUserEventFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, isRead = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserEventFilter { createdAt = optionals____.createdAt, isRead = optionals____.isRead, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserEventFilterOptionalFields =
    { createdAt : OptionalArgument DateTimeFilter
    , isRead : OptionalArgument Bool
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserEventHasFilter.UserEventHasFilter))
    , and : OptionalArgument (List (Maybe UserEventFilter))
    , or : OptionalArgument (List (Maybe UserEventFilter))
    , not : OptionalArgument UserEventFilter
    }


{-| Type alias for the `UserEventFilter` attributes. Note that this type
needs to use the `UserEventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventFilterRaw =
    { createdAt : OptionalArgument DateTimeFilter
    , isRead : OptionalArgument Bool
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserEventHasFilter.UserEventHasFilter))
    , and : OptionalArgument (List (Maybe UserEventFilter))
    , or : OptionalArgument (List (Maybe UserEventFilter))
    , not : OptionalArgument UserEventFilter
    }


{-| Type for the UserEventFilter input object.
-}
type UserEventFilter
    = UserEventFilter UserEventFilterRaw


{-| Encode a UserEventFilter into a value that can be used as an argument.
-}
encodeUserEventFilter : UserEventFilter -> Value
encodeUserEventFilter (UserEventFilter input____) =
    Encode.maybeObject
        [ ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "has", (Encode.enum Fractal.Enum.UserEventHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserEventFilter |> Encode.optional input____.not ) ]


buildUserEventOrder :
    (UserEventOrderOptionalFields -> UserEventOrderOptionalFields)
    -> UserEventOrder
buildUserEventOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserEventOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserEventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , desc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , then_ : OptionalArgument UserEventOrder
    }


{-| Type alias for the `UserEventOrder` attributes. Note that this type
needs to use the `UserEventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , desc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , then_ : OptionalArgument UserEventOrder
    }


{-| Type for the UserEventOrder input object.
-}
type UserEventOrder
    = UserEventOrder UserEventOrderRaw


{-| Encode a UserEventOrder into a value that can be used as an argument.
-}
encodeUserEventOrder : UserEventOrder -> Value
encodeUserEventOrder (UserEventOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserEventOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserEventOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserEventOrder |> Encode.optional input____.then_ ) ]


buildUserEventPatch :
    (UserEventPatchOptionalFields -> UserEventPatchOptionalFields)
    -> UserEventPatch
buildUserEventPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, isRead = Absent, user = Absent, event = Absent }
    in
    UserEventPatch { createdAt = optionals____.createdAt, isRead = optionals____.isRead, user = optionals____.user, event = optionals____.event }


type alias UserEventPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument EventKindRef
    }


{-| Type alias for the `UserEventPatch` attributes. Note that this type
needs to use the `UserEventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument EventKindRef
    }


{-| Type for the UserEventPatch input object.
-}
type UserEventPatch
    = UserEventPatch UserEventPatchRaw


{-| Encode a UserEventPatch into a value that can be used as an argument.
-}
encodeUserEventPatch : UserEventPatch -> Value
encodeUserEventPatch (UserEventPatch input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "user", encodeUserRef |> Encode.optional input____.user ), ( "event", encodeEventKindRef |> Encode.optional input____.event ) ]


buildUserEventRef :
    (UserEventRefOptionalFields -> UserEventRefOptionalFields)
    -> UserEventRef
buildUserEventRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, isRead = Absent, user = Absent, event = Absent }
    in
    UserEventRef { createdAt = optionals____.createdAt, isRead = optionals____.isRead, user = optionals____.user, event = optionals____.event }


type alias UserEventRefOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument EventKindRef
    }


{-| Type alias for the `UserEventRef` attributes. Note that this type
needs to use the `UserEventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventRefRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument EventKindRef
    }


{-| Type for the UserEventRef input object.
-}
type UserEventRef
    = UserEventRef UserEventRefRaw


{-| Encode a UserEventRef into a value that can be used as an argument.
-}
encodeUserEventRef : UserEventRef -> Value
encodeUserEventRef (UserEventRef input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "user", encodeUserRef |> Encode.optional input____.user ), ( "event", encodeEventKindRef |> Encode.optional input____.event ) ]


buildUserFilter :
    (UserFilterOptionalFields -> UserFilterOptionalFields)
    -> UserFilter
buildUserFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, username = Absent, name = Absent, email = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals____.id, username = optionals____.username, name = optionals____.name, email = optionals____.email, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringRegExpFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringRegExpFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "username", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.username ), ( "name", encodeStringRegExpFilter |> Encode.optional input____.name ), ( "email", encodeStringHashFilter |> Encode.optional input____.email ), ( "has", (Encode.enum Fractal.Enum.UserHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserFilter |> Encode.optional input____.not ) ]


buildUserOrder :
    (UserOrderOptionalFields -> UserOrderOptionalFields)
    -> UserOrder
buildUserOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserOrder |> Encode.optional input____.then_ ) ]


buildUserPatch :
    (UserPatchOptionalFields -> UserPatchOptionalFields)
    -> UserPatch
buildUserPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, lastAck = Absent, username = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, bio = Absent, utc = Absent, notifyByEmail = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, subscriptions = Absent, events = Absent }
    in
    UserPatch { createdAt = optionals____.createdAt, lastAck = optionals____.lastAck, username = optionals____.username, name = optionals____.name, password = optionals____.password, email = optionals____.email, emailHash = optionals____.emailHash, emailValidated = optionals____.emailValidated, bio = optionals____.bio, utc = optionals____.utc, notifyByEmail = optionals____.notifyByEmail, rights = optionals____.rights, roles = optionals____.roles, backed_roles = optionals____.backed_roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, subscriptions = optionals____.subscriptions, events = optionals____.events }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lastAck ), ( "username", Encode.string |> Encode.optional input____.username ), ( "name", Encode.string |> Encode.optional input____.name ), ( "password", Encode.string |> Encode.optional input____.password ), ( "email", Encode.string |> Encode.optional input____.email ), ( "emailHash", Encode.string |> Encode.optional input____.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input____.emailValidated ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "notifyByEmail", Encode.bool |> Encode.optional input____.notifyByEmail ), ( "rights", encodeUserRightsRef |> Encode.optional input____.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ) ]


buildUserRef :
    (UserRefOptionalFields -> UserRefOptionalFields)
    -> UserRef
buildUserRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, lastAck = Absent, username = Absent, name = Absent, password = Absent, email = Absent, emailHash = Absent, emailValidated = Absent, bio = Absent, utc = Absent, notifyByEmail = Absent, rights = Absent, roles = Absent, backed_roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, subscriptions = Absent, events = Absent }
    in
    UserRef { id = optionals____.id, createdAt = optionals____.createdAt, lastAck = optionals____.lastAck, username = optionals____.username, name = optionals____.name, password = optionals____.password, email = optionals____.email, emailHash = optionals____.emailHash, emailValidated = optionals____.emailValidated, bio = optionals____.bio, utc = optionals____.utc, notifyByEmail = optionals____.notifyByEmail, rights = optionals____.rights, roles = optionals____.roles, backed_roles = optionals____.backed_roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, subscriptions = optionals____.subscriptions, events = optionals____.events }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , emailHash : OptionalArgument String
    , emailValidated : OptionalArgument Bool
    , bio : OptionalArgument String
    , utc : OptionalArgument String
    , notifyByEmail : OptionalArgument Bool
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , backed_roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscriptions : OptionalArgument (List TensionRef)
    , events : OptionalArgument (List UserEventRef)
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lastAck ), ( "username", Encode.string |> Encode.optional input____.username ), ( "name", Encode.string |> Encode.optional input____.name ), ( "password", Encode.string |> Encode.optional input____.password ), ( "email", Encode.string |> Encode.optional input____.email ), ( "emailHash", Encode.string |> Encode.optional input____.emailHash ), ( "emailValidated", Encode.bool |> Encode.optional input____.emailValidated ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "notifyByEmail", Encode.bool |> Encode.optional input____.notifyByEmail ), ( "rights", encodeUserRightsRef |> Encode.optional input____.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "backed_roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.backed_roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ) ]


buildUserRightsFilter :
    (UserRightsFilterOptionalFields -> UserRightsFilterOptionalFields)
    -> UserRightsFilter
buildUserRightsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserRightsFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserRightsFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type alias for the `UserRightsFilter` attributes. Note that this type
needs to use the `UserRightsFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type for the UserRightsFilter input object.
-}
type UserRightsFilter
    = UserRightsFilter UserRightsFilterRaw


{-| Encode a UserRightsFilter into a value that can be used as an argument.
-}
encodeUserRightsFilter : UserRightsFilter -> Value
encodeUserRightsFilter (UserRightsFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.UserRightsHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserRightsFilter |> Encode.optional input____.not ) ]


buildUserRightsOrder :
    (UserRightsOrderOptionalFields -> UserRightsOrderOptionalFields)
    -> UserRightsOrder
buildUserRightsOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserRightsOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserRightsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type alias for the `UserRightsOrder` attributes. Note that this type
needs to use the `UserRightsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type for the UserRightsOrder input object.
-}
type UserRightsOrder
    = UserRightsOrder UserRightsOrderRaw


{-| Encode a UserRightsOrder into a value that can be used as an argument.
-}
encodeUserRightsOrder : UserRightsOrder -> Value
encodeUserRightsOrder (UserRightsOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserRightsOrder |> Encode.optional input____.then_ ) ]


buildUserRightsPatch :
    (UserRightsPatchOptionalFields -> UserRightsPatchOptionalFields)
    -> UserRightsPatch
buildUserRightsPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, type_ = Absent }
    in
    { canLogin = optionals____.canLogin, canCreateRoot = optionals____.canCreateRoot, maxPublicOrga = optionals____.maxPublicOrga, type_ = optionals____.type_ }


type alias UserRightsPatchOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Type for the UserRightsPatch input object.
-}
type alias UserRightsPatch =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Encode a UserRightsPatch into a value that can be used as an argument.
-}
encodeUserRightsPatch : UserRightsPatch -> Value
encodeUserRightsPatch input____ =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input____.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input____.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input____.maxPublicOrga ), ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input____.type_ ) ]


buildUserRightsRef :
    (UserRightsRefOptionalFields -> UserRightsRefOptionalFields)
    -> UserRightsRef
buildUserRightsRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, type_ = Absent }
    in
    { canLogin = optionals____.canLogin, canCreateRoot = optionals____.canCreateRoot, maxPublicOrga = optionals____.maxPublicOrga, type_ = optionals____.type_ }


type alias UserRightsRefOptionalFields =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Type for the UserRightsRef input object.
-}
type alias UserRightsRef =
    { canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , type_ : OptionalArgument Fractal.Enum.UserType.UserType
    }


{-| Encode a UserRightsRef into a value that can be used as an argument.
-}
encodeUserRightsRef : UserRightsRef -> Value
encodeUserRightsRef input____ =
    Encode.maybeObject
        [ ( "canLogin", Encode.bool |> Encode.optional input____.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input____.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input____.maxPublicOrga ), ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input____.type_ ) ]


buildVoteFilter :
    (VoteFilterOptionalFields -> VoteFilterOptionalFields)
    -> VoteFilter
buildVoteFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, voteid = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    VoteFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, voteid = optionals____.voteid, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias VoteFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type alias for the `VoteFilter` attributes. Note that this type
needs to use the `VoteFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type for the VoteFilter input object.
-}
type VoteFilter
    = VoteFilter VoteFilterRaw


{-| Encode a VoteFilter into a value that can be used as an argument.
-}
encodeVoteFilter : VoteFilter -> Value
encodeVoteFilter (VoteFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "voteid", encodeStringHashFilter |> Encode.optional input____.voteid ), ( "has", (Encode.enum Fractal.Enum.VoteHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeVoteFilter |> Encode.optional input____.not ) ]


buildVoteOrder :
    (VoteOrderOptionalFields -> VoteOrderOptionalFields)
    -> VoteOrder
buildVoteOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    VoteOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias VoteOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type alias for the `VoteOrder` attributes. Note that this type
needs to use the `VoteOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteOrderRaw =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type for the VoteOrder input object.
-}
type VoteOrder
    = VoteOrder VoteOrderRaw


{-| Encode a VoteOrder into a value that can be used as an argument.
-}
encodeVoteOrder : VoteOrder -> Value
encodeVoteOrder (VoteOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeVoteOrder |> Encode.optional input____.then_ ) ]


buildVotePatch :
    (VotePatchOptionalFields -> VotePatchOptionalFields)
    -> VotePatch
buildVotePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, voteid = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VotePatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, voteid = optionals____.voteid, contract = optionals____.contract, node = optionals____.node, data = optionals____.data }


type alias VotePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VotePatch` attributes. Note that this type
needs to use the `VotePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VotePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VotePatch input object.
-}
type VotePatch
    = VotePatch VotePatchRaw


{-| Encode a VotePatch into a value that can be used as an argument.
-}
encodeVotePatch : VotePatch -> Value
encodeVotePatch (VotePatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "voteid", Encode.string |> Encode.optional input____.voteid ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "node", encodeNodeRef |> Encode.optional input____.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input____.data ) ]


buildVoteRef :
    (VoteRefOptionalFields -> VoteRefOptionalFields)
    -> VoteRef
buildVoteRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, voteid = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VoteRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, voteid = optionals____.voteid, contract = optionals____.contract, node = optionals____.node, data = optionals____.data }


type alias VoteRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VoteRef` attributes. Note that this type
needs to use the `VoteRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VoteRef input object.
-}
type VoteRef
    = VoteRef VoteRefRaw


{-| Encode a VoteRef into a value that can be used as an argument.
-}
encodeVoteRef : VoteRef -> Value
encodeVoteRef (VoteRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "voteid", Encode.string |> Encode.optional input____.voteid ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "node", encodeNodeRef |> Encode.optional input____.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input____.data ) ]


buildWithinFilter :
    WithinFilterRequiredFields
    -> WithinFilter
buildWithinFilter required____ =
    { polygon = required____.polygon }


type alias WithinFilterRequiredFields =
    { polygon : PolygonRef }


{-| Type for the WithinFilter input object.
-}
type alias WithinFilter =
    { polygon : PolygonRef }


{-| Encode a WithinFilter into a value that can be used as an argument.
-}
encodeWithinFilter : WithinFilter -> Value
encodeWithinFilter input____ =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef input____.polygon |> Just ) ]
