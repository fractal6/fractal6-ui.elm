-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.InputObject exposing (..)

import Fractal.Enum.BlobHasFilter
import Fractal.Enum.BlobOrderable
import Fractal.Enum.BlobType
import Fractal.Enum.CommentHasFilter
import Fractal.Enum.CommentOrderable
import Fractal.Enum.ContractHasFilter
import Fractal.Enum.ContractOrderable
import Fractal.Enum.ContractStatus
import Fractal.Enum.ContractType
import Fractal.Enum.EventCountHasFilter
import Fractal.Enum.EventCountOrderable
import Fractal.Enum.EventFragmentHasFilter
import Fractal.Enum.EventFragmentOrderable
import Fractal.Enum.EventHasFilter
import Fractal.Enum.EventKindType
import Fractal.Enum.EventOrderable
import Fractal.Enum.HTTPMethod
import Fractal.Enum.LabelHasFilter
import Fractal.Enum.LabelOrderable
import Fractal.Enum.Lang
import Fractal.Enum.MandateHasFilter
import Fractal.Enum.MandateOrderable
import Fractal.Enum.Mode
import Fractal.Enum.NodeFragmentHasFilter
import Fractal.Enum.NodeFragmentOrderable
import Fractal.Enum.NodeHasFilter
import Fractal.Enum.NodeMode
import Fractal.Enum.NodeOrderable
import Fractal.Enum.NodeType
import Fractal.Enum.NodeVisibility
import Fractal.Enum.NotifHasFilter
import Fractal.Enum.NotifOrderable
import Fractal.Enum.PendingUserHasFilter
import Fractal.Enum.PendingUserOrderable
import Fractal.Enum.PostHasFilter
import Fractal.Enum.PostOrderable
import Fractal.Enum.ProjectColumnHasFilter
import Fractal.Enum.ProjectColumnOrderable
import Fractal.Enum.ProjectFieldHasFilter
import Fractal.Enum.ProjectFieldType
import Fractal.Enum.ProjectFieldValueHasFilter
import Fractal.Enum.ProjectFieldValueOrderable
import Fractal.Enum.ProjectHasFilter
import Fractal.Enum.ProjectOrderable
import Fractal.Enum.ProjectStatus
import Fractal.Enum.ProjectTensionHasFilter
import Fractal.Enum.ProjectTensionOrderable
import Fractal.Enum.ReactionHasFilter
import Fractal.Enum.ReactionOrderable
import Fractal.Enum.RoleExtHasFilter
import Fractal.Enum.RoleExtOrderable
import Fractal.Enum.RoleType
import Fractal.Enum.TensionAction
import Fractal.Enum.TensionEvent
import Fractal.Enum.TensionHasFilter
import Fractal.Enum.TensionOrderable
import Fractal.Enum.TensionStatus
import Fractal.Enum.TensionType
import Fractal.Enum.UserEventHasFilter
import Fractal.Enum.UserEventOrderable
import Fractal.Enum.UserHasFilter
import Fractal.Enum.UserOrderable
import Fractal.Enum.UserRightsHasFilter
import Fractal.Enum.UserRightsOrderable
import Fractal.Enum.UserType
import Fractal.Enum.VoteHasFilter
import Fractal.Enum.VoteOrderable
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAddBlobInput :
    AddBlobInputRequiredFields
    -> (AddBlobInputOptionalFields -> AddBlobInputOptionalFields)
    -> AddBlobInput
buildAddBlobInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    AddBlobInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = required____.tension, blob_type = required____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias AddBlobInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    }


type alias AddBlobInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `AddBlobInput` attributes. Note that this type
needs to use the `AddBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddBlobInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , blob_type : Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the AddBlobInput input object.
-}
type AddBlobInput
    = AddBlobInput AddBlobInputRaw


{-| Encode a AddBlobInput into a value that can be used as an argument.
-}
encodeAddBlobInput : AddBlobInput -> Value
encodeAddBlobInput (AddBlobInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString input____.blob_type |> Just ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildAddCommentInput :
    AddCommentInputRequiredFields
    -> (AddCommentInputOptionalFields -> AddCommentInputOptionalFields)
    -> AddCommentInput
buildAddCommentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, reactions = Absent }
    in
    AddCommentInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, reactions = optionals____.reactions }


type alias AddCommentInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    }


type alias AddCommentInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type alias for the `AddCommentInput` attributes. Note that this type
needs to use the `AddCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddCommentInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type for the AddCommentInput input object.
-}
type AddCommentInput
    = AddCommentInput AddCommentInputRaw


{-| Encode a AddCommentInput into a value that can be used as an argument.
-}
encodeAddCommentInput : AddCommentInput -> Value
encodeAddCommentInput (AddCommentInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ) ]


buildAddContractInput :
    AddContractInputRequiredFields
    -> (AddContractInputOptionalFields -> AddContractInputOptionalFields)
    -> AddContractInput
buildAddContractInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, closedAt = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    AddContractInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contractid = required____.contractid, tension = required____.tension, status = required____.status, contract_type = required____.contract_type, closedAt = optionals____.closedAt, event = required____.event, participants = required____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias AddContractInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , contractid : String
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , event : EventFragmentRef
    , participants : List VoteRef
    }


type alias AddContractInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `AddContractInput` attributes. Note that this type
needs to use the `AddContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddContractInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : String
    , tension : TensionRef
    , status : Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : EventFragmentRef
    , participants : List VoteRef
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the AddContractInput input object.
-}
type AddContractInput
    = AddContractInput AddContractInputRaw


{-| Encode a AddContractInput into a value that can be used as an argument.
-}
encodeAddContractInput : AddContractInput -> Value
encodeAddContractInput (AddContractInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contractid", Encode.string input____.contractid |> Just ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString input____.status |> Just ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString input____.contract_type |> Just ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef input____.event |> Just ), ( "participants", (encodeVoteRef |> Encode.list) input____.participants |> Just ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildAddEventCountInput :
    (AddEventCountInputOptionalFields -> AddEventCountInputOptionalFields)
    -> AddEventCountInput
buildAddEventCountInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { unread_events = Absent, pending_contracts = Absent, assigned_tensions = Absent }
    in
    { unread_events = optionals____.unread_events, pending_contracts = optionals____.pending_contracts, assigned_tensions = optionals____.assigned_tensions }


type alias AddEventCountInputOptionalFields =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Type for the AddEventCountInput input object.
-}
type alias AddEventCountInput =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Encode a AddEventCountInput into a value that can be used as an argument.
-}
encodeAddEventCountInput : AddEventCountInput -> Value
encodeAddEventCountInput input____ =
    Encode.maybeObject
        [ ( "unread_events", Encode.int |> Encode.optional input____.unread_events ), ( "pending_contracts", Encode.int |> Encode.optional input____.pending_contracts ), ( "assigned_tensions", Encode.int |> Encode.optional input____.assigned_tensions ) ]


buildAddEventFragmentInput :
    AddEventFragmentInputRequiredFields
    -> (AddEventFragmentInputOptionalFields -> AddEventFragmentInputOptionalFields)
    -> AddEventFragmentInput
buildAddEventFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { old = Absent, new = Absent }
    in
    { event_type = required____.event_type, old = optionals____.old, new = optionals____.new }


type alias AddEventFragmentInputRequiredFields =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent }


type alias AddEventFragmentInputOptionalFields =
    { old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventFragmentInput input object.
-}
type alias AddEventFragmentInput =
    { event_type : Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a AddEventFragmentInput into a value that can be used as an argument.
-}
encodeAddEventFragmentInput : AddEventFragmentInput -> Value
encodeAddEventFragmentInput input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input____.event_type |> Just ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildAddEventInput :
    AddEventInputRequiredFields
    -> (AddEventInputOptionalFields -> AddEventInputOptionalFields)
    -> AddEventInput
buildAddEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, mentioned = Absent, old = Absent, new = Absent }
    in
    AddEventInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = required____.tension, event_type = required____.event_type, mentioned = optionals____.mentioned, old = optionals____.old, new = optionals____.new }


type alias AddEventInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    }


type alias AddEventInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `AddEventInput` attributes. Note that this type
needs to use the `AddEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddEventInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : TensionRef
    , event_type : Fractal.Enum.TensionEvent.TensionEvent
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the AddEventInput input object.
-}
type AddEventInput
    = AddEventInput AddEventInputRaw


{-| Encode a AddEventInput into a value that can be used as an argument.
-}
encodeAddEventInput : AddEventInput -> Value
encodeAddEventInput (AddEventInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef input____.tension |> Just ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString input____.event_type |> Just ), ( "mentioned", encodeTensionRef |> Encode.optional input____.mentioned ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildAddLabelInput :
    AddLabelInputRequiredFields
    -> (AddLabelInputOptionalFields -> AddLabelInputOptionalFields)
    -> AddLabelInput
buildAddLabelInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, color = Absent, tensions = Absent, nodes = Absent }
    in
    AddLabelInput { rootnameid = required____.rootnameid, name = required____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes }


type alias AddLabelInputRequiredFields =
    { rootnameid : String
    , name : String
    }


type alias AddLabelInputOptionalFields =
    { description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `AddLabelInput` attributes. Note that this type
needs to use the `AddLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddLabelInputRaw =
    { rootnameid : String
    , name : String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the AddLabelInput input object.
-}
type AddLabelInput
    = AddLabelInput AddLabelInputRaw


{-| Encode a AddLabelInput into a value that can be used as an argument.
-}
encodeAddLabelInput : AddLabelInput -> Value
encodeAddLabelInput (AddLabelInput input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "name", Encode.string input____.name |> Just ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildAddMandateInput :
    AddMandateInputRequiredFields
    -> (AddMandateInputOptionalFields -> AddMandateInputOptionalFields)
    -> AddMandateInput
buildAddMandateInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = required____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias AddMandateInputRequiredFields =
    { purpose : String }


type alias AddMandateInputOptionalFields =
    { responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the AddMandateInput input object.
-}
type alias AddMandateInput =
    { purpose : String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a AddMandateInput into a value that can be used as an argument.
-}
encodeAddMandateInput : AddMandateInput -> Value
encodeAddMandateInput input____ =
    Encode.maybeObject
        [ ( "purpose", Encode.string input____.purpose |> Just ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildAddNodeFragmentInput :
    (AddNodeFragmentInputOptionalFields -> AddNodeFragmentInputOptionalFields)
    -> AddNodeFragmentInput
buildAddNodeFragmentInput fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, role_ext = Absent, role_type = Absent, color = Absent }
    in
    { nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color }


type alias AddNodeFragmentInputOptionalFields =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Type for the AddNodeFragmentInput input object.
-}
type alias AddNodeFragmentInput =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Encode a AddNodeFragmentInput into a value that can be used as an argument.
-}
encodeAddNodeFragmentInput : AddNodeFragmentInput -> Value
encodeAddNodeFragmentInput input____ =
    Encode.maybeObject
        [ ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "role_ext", Encode.string |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ) ]


buildAddNodeInput :
    AddNodeInputRequiredFields
    -> (AddNodeInputOptionalFields -> AddNodeInputOptionalFields)
    -> AddNodeInput
buildAddNodeInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, source = Absent, about = Absent, skills = Absent, parent = Absent, tensions_out = Absent, tensions_in = Absent, isPersonal = Absent, userCanJoin = Absent, guestCanCreateTension = Absent, watchers = Absent, children = Absent, labels = Absent, roles = Absent, projects = Absent, pinned = Absent, role_ext = Absent, role_type = Absent, color = Absent, first_link = Absent, contracts = Absent, events_history = Absent }
    in
    AddNodeInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, nameid = required____.nameid, rootnameid = required____.rootnameid, source = optionals____.source, name = required____.name, about = optionals____.about, skills = optionals____.skills, isRoot = required____.isRoot, parent = optionals____.parent, type_ = required____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, visibility = required____.visibility, mode = required____.mode, rights = required____.rights, isArchived = required____.isArchived, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, guestCanCreateTension = optionals____.guestCanCreateTension, watchers = optionals____.watchers, children = optionals____.children, labels = optionals____.labels, roles = optionals____.roles, projects = optionals____.projects, pinned = optionals____.pinned, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color, first_link = optionals____.first_link, contracts = optionals____.contracts, events_history = optionals____.events_history }


type alias AddNodeInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , nameid : String
    , rootnameid : String
    , name : String
    , isRoot : Bool
    , type_ : Fractal.Enum.NodeType.NodeType
    , visibility : Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : Fractal.Enum.NodeMode.NodeMode
    , rights : Int
    , isArchived : Bool
    }


type alias AddNodeInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , source : OptionalArgument BlobRef
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , parent : OptionalArgument NodeRef
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type alias for the `AddNodeInput` attributes. Note that this type
needs to use the `AddNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNodeInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , nameid : String
    , rootnameid : String
    , source : OptionalArgument BlobRef
    , name : String
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , isRoot : Bool
    , parent : OptionalArgument NodeRef
    , type_ : Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , visibility : Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : Fractal.Enum.NodeMode.NodeMode
    , rights : Int
    , isArchived : Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type for the AddNodeInput input object.
-}
type AddNodeInput
    = AddNodeInput AddNodeInputRaw


{-| Encode a AddNodeInput into a value that can be used as an argument.
-}
encodeAddNodeInput : AddNodeInput -> Value
encodeAddNodeInput (AddNodeInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "nameid", Encode.string input____.nameid |> Just ), ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "name", Encode.string input____.name |> Just ), ( "about", Encode.string |> Encode.optional input____.about ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "isRoot", Encode.bool input____.isRoot |> Just ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString input____.type_ |> Just ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString input____.visibility |> Just ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString input____.mode |> Just ), ( "rights", Encode.int input____.rights |> Just ), ( "isArchived", Encode.bool input____.isArchived |> Just ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "guestCanCreateTension", Encode.bool |> Encode.optional input____.guestCanCreateTension ), ( "watchers", (encodeUserRef |> Encode.list) |> Encode.optional input____.watchers ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "roles", (encodeRoleExtRef |> Encode.list) |> Encode.optional input____.roles ), ( "projects", (encodeProjectRef |> Encode.list) |> Encode.optional input____.projects ), ( "pinned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.pinned ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "events_history", (encodeEventRef |> Encode.list) |> Encode.optional input____.events_history ) ]


buildAddNotifInput :
    AddNotifInputRequiredFields
    -> (AddNotifInputOptionalFields -> AddNotifInputOptionalFields)
    -> AddNotifInput
buildAddNotifInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, tension_ = Absent, contract = Absent, link = Absent }
    in
    AddNotifInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension_ = optionals____.tension_, contract = optionals____.contract, link = optionals____.link }


type alias AddNotifInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    }


type alias AddNotifInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type alias for the `AddNotifInput` attributes. Note that this type
needs to use the `AddNotifInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddNotifInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type for the AddNotifInput input object.
-}
type AddNotifInput
    = AddNotifInput AddNotifInputRaw


{-| Encode a AddNotifInput into a value that can be used as an argument.
-}
encodeAddNotifInput : AddNotifInput -> Value
encodeAddNotifInput (AddNotifInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension_", encodeTensionRef |> Encode.optional input____.tension_ ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "link", Encode.string |> Encode.optional input____.link ) ]


buildAddPendingUserInput :
    AddPendingUserInputRequiredFields
    -> (AddPendingUserInputOptionalFields -> AddPendingUserInputOptionalFields)
    -> AddPendingUserInput
buildAddPendingUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, password = Absent, email_token = Absent, token = Absent, contracts = Absent, subscribe = Absent }
    in
    AddPendingUserInput { updatedAt = optionals____.updatedAt, username = required____.username, password = optionals____.password, email = required____.email, email_token = optionals____.email_token, token = optionals____.token, contracts = optionals____.contracts, subscribe = optionals____.subscribe }


type alias AddPendingUserInputRequiredFields =
    { username : String
    , email : String
    }


type alias AddPendingUserInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , password : OptionalArgument String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type alias for the `AddPendingUserInput` attributes. Note that this type
needs to use the `AddPendingUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddPendingUserInputRaw =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : String
    , password : OptionalArgument String
    , email : String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type for the AddPendingUserInput input object.
-}
type AddPendingUserInput
    = AddPendingUserInput AddPendingUserInputRaw


{-| Encode a AddPendingUserInput into a value that can be used as an argument.
-}
encodeAddPendingUserInput : AddPendingUserInput -> Value
encodeAddPendingUserInput (AddPendingUserInput input____) =
    Encode.maybeObject
        [ ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "username", Encode.string input____.username |> Just ), ( "password", Encode.string |> Encode.optional input____.password ), ( "email", Encode.string input____.email |> Just ), ( "email_token", Encode.string |> Encode.optional input____.email_token ), ( "token", Encode.string |> Encode.optional input____.token ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribe", Encode.bool |> Encode.optional input____.subscribe ) ]


buildAddProjectColumnInput :
    AddProjectColumnInputRequiredFields
    -> (AddProjectColumnInputOptionalFields -> AddProjectColumnInputOptionalFields)
    -> AddProjectColumnInput
buildAddProjectColumnInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { about = Absent, tensions = Absent }
    in
    AddProjectColumnInput { name = required____.name, about = optionals____.about, pos = required____.pos, tensions = optionals____.tensions, project = required____.project }


type alias AddProjectColumnInputRequiredFields =
    { name : String
    , pos : Int
    , project : ProjectRef
    }


type alias AddProjectColumnInputOptionalFields =
    { about : OptionalArgument String
    , tensions : OptionalArgument (List ProjectTensionRef)
    }


{-| Type alias for the `AddProjectColumnInput` attributes. Note that this type
needs to use the `AddProjectColumnInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddProjectColumnInputRaw =
    { name : String
    , about : OptionalArgument String
    , pos : Int
    , tensions : OptionalArgument (List ProjectTensionRef)
    , project : ProjectRef
    }


{-| Type for the AddProjectColumnInput input object.
-}
type AddProjectColumnInput
    = AddProjectColumnInput AddProjectColumnInputRaw


{-| Encode a AddProjectColumnInput into a value that can be used as an argument.
-}
encodeAddProjectColumnInput : AddProjectColumnInput -> Value
encodeAddProjectColumnInput (AddProjectColumnInput input____) =
    Encode.maybeObject
        [ ( "name", Encode.string input____.name |> Just ), ( "about", Encode.string |> Encode.optional input____.about ), ( "pos", Encode.int input____.pos |> Just ), ( "tensions", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "project", encodeProjectRef input____.project |> Just ) ]


buildAddProjectFieldInput :
    AddProjectFieldInputRequiredFields
    -> (AddProjectFieldInputOptionalFields -> AddProjectFieldInputOptionalFields)
    -> AddProjectFieldInput
buildAddProjectFieldInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { values = Absent }
    in
    AddProjectFieldInput { type_ = required____.type_, isVisible = required____.isVisible, values = optionals____.values }


type alias AddProjectFieldInputRequiredFields =
    { type_ : Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : Bool
    }


type alias AddProjectFieldInputOptionalFields =
    { values : OptionalArgument (List ProjectFieldValueRef) }


{-| Type alias for the `AddProjectFieldInput` attributes. Note that this type
needs to use the `AddProjectFieldInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddProjectFieldInputRaw =
    { type_ : Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : Bool
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the AddProjectFieldInput input object.
-}
type AddProjectFieldInput
    = AddProjectFieldInput AddProjectFieldInputRaw


{-| Encode a AddProjectFieldInput into a value that can be used as an argument.
-}
encodeAddProjectFieldInput : AddProjectFieldInput -> Value
encodeAddProjectFieldInput (AddProjectFieldInput input____) =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.ProjectFieldType.toString input____.type_ |> Just ), ( "isVisible", Encode.bool input____.isVisible |> Just ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildAddProjectFieldValueInput :
    AddProjectFieldValueInputRequiredFields
    -> AddProjectFieldValueInput
buildAddProjectFieldValueInput required____ =
    AddProjectFieldValueInput { field = required____.field, value = required____.value }


type alias AddProjectFieldValueInputRequiredFields =
    { field : ProjectFieldRef
    , value : String
    }


{-| Type alias for the `AddProjectFieldValueInput` attributes. Note that this type
needs to use the `AddProjectFieldValueInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddProjectFieldValueInputRaw =
    { field : ProjectFieldRef
    , value : String
    }


{-| Type for the AddProjectFieldValueInput input object.
-}
type AddProjectFieldValueInput
    = AddProjectFieldValueInput AddProjectFieldValueInputRaw


{-| Encode a AddProjectFieldValueInput into a value that can be used as an argument.
-}
encodeAddProjectFieldValueInput : AddProjectFieldValueInput -> Value
encodeAddProjectFieldValueInput (AddProjectFieldValueInput input____) =
    Encode.maybeObject
        [ ( "field", encodeProjectFieldRef input____.field |> Just ), ( "value", Encode.string input____.value |> Just ) ]


buildAddProjectInput :
    AddProjectInputRequiredFields
    -> (AddProjectInputOptionalFields -> AddProjectInputOptionalFields)
    -> AddProjectInput
buildAddProjectInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, columns = Absent, fields = Absent, leaders = Absent, nodes = Absent }
    in
    AddProjectInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = required____.updatedAt, rootnameid = required____.rootnameid, parentnameid = required____.parentnameid, nameid = required____.nameid, name = required____.name, description = optionals____.description, status = required____.status, columns = optionals____.columns, fields = optionals____.fields, leaders = optionals____.leaders, nodes = optionals____.nodes }


type alias AddProjectInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : Fractal.ScalarCodecs.DateTime
    , rootnameid : String
    , parentnameid : String
    , nameid : String
    , name : String
    , status : Fractal.Enum.ProjectStatus.ProjectStatus
    }


type alias AddProjectInputOptionalFields =
    { description : OptionalArgument String
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `AddProjectInput` attributes. Note that this type
needs to use the `AddProjectInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddProjectInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : Fractal.ScalarCodecs.DateTime
    , rootnameid : String
    , parentnameid : String
    , nameid : String
    , name : String
    , description : OptionalArgument String
    , status : Fractal.Enum.ProjectStatus.ProjectStatus
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the AddProjectInput input object.
-}
type AddProjectInput
    = AddProjectInput AddProjectInputRaw


{-| Encode a AddProjectInput into a value that can be used as an argument.
-}
encodeAddProjectInput : AddProjectInput -> Value
encodeAddProjectInput (AddProjectInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.updatedAt |> Just ), ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "parentnameid", Encode.string input____.parentnameid |> Just ), ( "nameid", Encode.string input____.nameid |> Just ), ( "name", Encode.string input____.name |> Just ), ( "description", Encode.string |> Encode.optional input____.description ), ( "status", Encode.enum Fractal.Enum.ProjectStatus.toString input____.status |> Just ), ( "columns", (encodeProjectColumnRef |> Encode.list) |> Encode.optional input____.columns ), ( "fields", (encodeProjectFieldRef |> Encode.list) |> Encode.optional input____.fields ), ( "leaders", (encodeNodeRef |> Encode.list) |> Encode.optional input____.leaders ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildAddProjectTensionInput :
    AddProjectTensionInputRequiredFields
    -> (AddProjectTensionInputOptionalFields -> AddProjectTensionInputOptionalFields)
    -> AddProjectTensionInput
buildAddProjectTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { values = Absent }
    in
    AddProjectTensionInput { tension = required____.tension, pos = required____.pos, pc = required____.pc, values = optionals____.values }


type alias AddProjectTensionInputRequiredFields =
    { tension : TensionRef
    , pos : Int
    , pc : ProjectColumnRef
    }


type alias AddProjectTensionInputOptionalFields =
    { values : OptionalArgument (List ProjectFieldValueRef) }


{-| Type alias for the `AddProjectTensionInput` attributes. Note that this type
needs to use the `AddProjectTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddProjectTensionInputRaw =
    { tension : TensionRef
    , pos : Int
    , pc : ProjectColumnRef
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the AddProjectTensionInput input object.
-}
type AddProjectTensionInput
    = AddProjectTensionInput AddProjectTensionInputRaw


{-| Encode a AddProjectTensionInput into a value that can be used as an argument.
-}
encodeAddProjectTensionInput : AddProjectTensionInput -> Value
encodeAddProjectTensionInput (AddProjectTensionInput input____) =
    Encode.maybeObject
        [ ( "tension", encodeTensionRef input____.tension |> Just ), ( "pos", Encode.int input____.pos |> Just ), ( "pc", encodeProjectColumnRef input____.pc |> Just ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildAddReactionInput :
    AddReactionInputRequiredFields
    -> AddReactionInput
buildAddReactionInput required____ =
    AddReactionInput { reactionid = required____.reactionid, user = required____.user, comment = required____.comment, type_ = required____.type_ }


type alias AddReactionInputRequiredFields =
    { reactionid : String
    , user : UserRef
    , comment : CommentRef
    , type_ : Int
    }


{-| Type alias for the `AddReactionInput` attributes. Note that this type
needs to use the `AddReactionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddReactionInputRaw =
    { reactionid : String
    , user : UserRef
    , comment : CommentRef
    , type_ : Int
    }


{-| Type for the AddReactionInput input object.
-}
type AddReactionInput
    = AddReactionInput AddReactionInputRaw


{-| Encode a AddReactionInput into a value that can be used as an argument.
-}
encodeAddReactionInput : AddReactionInput -> Value
encodeAddReactionInput (AddReactionInput input____) =
    Encode.maybeObject
        [ ( "reactionid", Encode.string input____.reactionid |> Just ), ( "user", encodeUserRef input____.user |> Just ), ( "comment", encodeCommentRef input____.comment |> Just ), ( "type_", Encode.int input____.type_ |> Just ) ]


buildAddRoleExtInput :
    AddRoleExtInputRequiredFields
    -> (AddRoleExtInputOptionalFields -> AddRoleExtInputOptionalFields)
    -> AddRoleExtInput
buildAddRoleExtInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { about = Absent, color = Absent, mandate = Absent, roles = Absent, nodes = Absent }
    in
    AddRoleExtInput { rootnameid = required____.rootnameid, name = required____.name, about = optionals____.about, role_type = required____.role_type, color = optionals____.color, mandate = optionals____.mandate, roles = optionals____.roles, nodes = optionals____.nodes }


type alias AddRoleExtInputRequiredFields =
    { rootnameid : String
    , name : String
    , role_type : Fractal.Enum.RoleType.RoleType
    }


type alias AddRoleExtInputOptionalFields =
    { about : OptionalArgument String
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `AddRoleExtInput` attributes. Note that this type
needs to use the `AddRoleExtInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddRoleExtInputRaw =
    { rootnameid : String
    , name : String
    , about : OptionalArgument String
    , role_type : Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the AddRoleExtInput input object.
-}
type AddRoleExtInput
    = AddRoleExtInput AddRoleExtInputRaw


{-| Encode a AddRoleExtInput into a value that can be used as an argument.
-}
encodeAddRoleExtInput : AddRoleExtInput -> Value
encodeAddRoleExtInput (AddRoleExtInput input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string input____.rootnameid |> Just ), ( "name", Encode.string input____.name |> Just ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString input____.role_type |> Just ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildAddTensionInput :
    AddTensionInputRequiredFields
    -> (AddTensionInputOptionalFields -> AddTensionInputOptionalFields)
    -> AddTensionInput
buildAddTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent, action = Absent, assignees = Absent, labels = Absent, comments = Absent, blobs = Absent, history = Absent, mentions = Absent, contracts = Absent, subscribers = Absent, projects = Absent, n_comments = Absent }
    in
    AddTensionInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = required____.emitter, emitterid = required____.emitterid, receiver = required____.receiver, receiverid = required____.receiverid, title = required____.title, type_ = required____.type_, status = required____.status, action = optionals____.action, assignees = optionals____.assignees, labels = optionals____.labels, comments = optionals____.comments, blobs = optionals____.blobs, history = optionals____.history, mentions = optionals____.mentions, contracts = optionals____.contracts, subscribers = optionals____.subscribers, projects = optionals____.projects, n_comments = optionals____.n_comments }


type alias AddTensionInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    }


type alias AddTensionInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `AddTensionInput` attributes. Note that this type
needs to use the `AddTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddTensionInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : NodeRef
    , emitterid : String
    , receiver : NodeRef
    , receiverid : String
    , title : String
    , type_ : Fractal.Enum.TensionType.TensionType
    , status : Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the AddTensionInput input object.
-}
type AddTensionInput
    = AddTensionInput AddTensionInputRaw


{-| Encode a AddTensionInput into a value that can be used as an argument.
-}
encodeAddTensionInput : AddTensionInput -> Value
encodeAddTensionInput (AddTensionInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef input____.emitter |> Just ), ( "emitterid", Encode.string input____.emitterid |> Just ), ( "receiver", encodeNodeRef input____.receiver |> Just ), ( "receiverid", Encode.string input____.receiverid |> Just ), ( "title", Encode.string input____.title |> Just ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString input____.type_ |> Just ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString input____.status |> Just ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input____.history ), ( "mentions", (encodeEventRef |> Encode.list) |> Encode.optional input____.mentions ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.subscribers ), ( "projects", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.projects ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ) ]


buildAddUserEventInput :
    AddUserEventInputRequiredFields
    -> (AddUserEventInputOptionalFields -> AddUserEventInputOptionalFields)
    -> AddUserEventInput
buildAddUserEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event = Absent }
    in
    AddUserEventInput { createdAt = required____.createdAt, isRead = required____.isRead, user = required____.user, event = optionals____.event }


type alias AddUserEventInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , isRead : Bool
    , user : UserRef
    }


type alias AddUserEventInputOptionalFields =
    { event : OptionalArgument (List EventKindRef) }


{-| Type alias for the `AddUserEventInput` attributes. Note that this type
needs to use the `AddUserEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserEventInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , isRead : Bool
    , user : UserRef
    , event : OptionalArgument (List EventKindRef)
    }


{-| Type for the AddUserEventInput input object.
-}
type AddUserEventInput
    = AddUserEventInput AddUserEventInputRaw


{-| Encode a AddUserEventInput into a value that can be used as an argument.
-}
encodeAddUserEventInput : AddUserEventInput -> Value
encodeAddUserEventInput (AddUserEventInput input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "isRead", Encode.bool input____.isRead |> Just ), ( "user", encodeUserRef input____.user |> Just ), ( "event", (encodeEventKindRef |> Encode.list) |> Encode.optional input____.event ) ]


buildAddUserInput :
    AddUserInputRequiredFields
    -> (AddUserInputOptionalFields -> AddUserInputOptionalFields)
    -> AddUserInput
buildAddUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { name = Absent, bio = Absent, location = Absent, utc = Absent, links = Absent, skills = Absent, subscriptions = Absent, watching = Absent, roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, reactions = Absent, events = Absent, markAllAsRead = Absent, event_count = Absent }
    in
    AddUserInput { createdAt = required____.createdAt, lastAck = required____.lastAck, username = required____.username, name = optionals____.name, email = required____.email, password = required____.password, bio = optionals____.bio, location = optionals____.location, utc = optionals____.utc, links = optionals____.links, skills = optionals____.skills, notifyByEmail = required____.notifyByEmail, lang = required____.lang, subscriptions = optionals____.subscriptions, watching = optionals____.watching, rights = required____.rights, roles = optionals____.roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, reactions = optionals____.reactions, events = optionals____.events, markAllAsRead = optionals____.markAllAsRead, event_count = optionals____.event_count }


type alias AddUserInputRequiredFields =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , email : String
    , password : String
    , notifyByEmail : Bool
    , lang : Fractal.Enum.Lang.Lang
    , rights : UserRightsRef
    }


type alias AddUserInputOptionalFields =
    { name : OptionalArgument String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type alias for the `AddUserInput` attributes. Note that this type
needs to use the `AddUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddUserInputRaw =
    { createdAt : Fractal.ScalarCodecs.DateTime
    , lastAck : Fractal.ScalarCodecs.DateTime
    , username : String
    , name : OptionalArgument String
    , email : String
    , password : String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , notifyByEmail : Bool
    , lang : Fractal.Enum.Lang.Lang
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , rights : UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type for the AddUserInput input object.
-}
type AddUserInput
    = AddUserInput AddUserInputRaw


{-| Encode a AddUserInput into a value that can be used as an argument.
-}
encodeAddUserInput : AddUserInput -> Value
encodeAddUserInput (AddUserInput input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.lastAck |> Just ), ( "username", Encode.string input____.username |> Just ), ( "name", Encode.string |> Encode.optional input____.name ), ( "email", Encode.string input____.email |> Just ), ( "password", Encode.string input____.password |> Just ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "location", Encode.string |> Encode.optional input____.location ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "links", (Encode.string |> Encode.list) |> Encode.optional input____.links ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "notifyByEmail", Encode.bool input____.notifyByEmail |> Just ), ( "lang", Encode.enum Fractal.Enum.Lang.toString input____.lang |> Just ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "watching", (encodeNodeRef |> Encode.list) |> Encode.optional input____.watching ), ( "rights", encodeUserRightsRef input____.rights |> Just ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ), ( "markAllAsRead", Encode.string |> Encode.optional input____.markAllAsRead ), ( "event_count", encodeEventCountRef |> Encode.optional input____.event_count ) ]


buildAddUserRightsInput :
    AddUserRightsInputRequiredFields
    -> AddUserRightsInput
buildAddUserRightsInput required____ =
    { type_ = required____.type_, canLogin = required____.canLogin, canCreateRoot = required____.canCreateRoot, maxPublicOrga = required____.maxPublicOrga, maxPrivateOrga = required____.maxPrivateOrga, hasEmailNotifications = required____.hasEmailNotifications }


type alias AddUserRightsInputRequiredFields =
    { type_ : Fractal.Enum.UserType.UserType
    , canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , maxPrivateOrga : Int
    , hasEmailNotifications : Bool
    }


{-| Type for the AddUserRightsInput input object.
-}
type alias AddUserRightsInput =
    { type_ : Fractal.Enum.UserType.UserType
    , canLogin : Bool
    , canCreateRoot : Bool
    , maxPublicOrga : Int
    , maxPrivateOrga : Int
    , hasEmailNotifications : Bool
    }


{-| Encode a AddUserRightsInput into a value that can be used as an argument.
-}
encodeAddUserRightsInput : AddUserRightsInput -> Value
encodeAddUserRightsInput input____ =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.UserType.toString input____.type_ |> Just ), ( "canLogin", Encode.bool input____.canLogin |> Just ), ( "canCreateRoot", Encode.bool input____.canCreateRoot |> Just ), ( "maxPublicOrga", Encode.int input____.maxPublicOrga |> Just ), ( "maxPrivateOrga", Encode.int input____.maxPrivateOrga |> Just ), ( "hasEmailNotifications", Encode.bool input____.hasEmailNotifications |> Just ) ]


buildAddVoteInput :
    AddVoteInputRequiredFields
    -> (AddVoteInputOptionalFields -> AddVoteInputOptionalFields)
    -> AddVoteInput
buildAddVoteInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, message = Absent }
    in
    AddVoteInput { createdBy = required____.createdBy, createdAt = required____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, voteid = required____.voteid, contract = required____.contract, node = required____.node, data = required____.data }


type alias AddVoteInputRequiredFields =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , voteid : String
    , contract : ContractRef
    , node : NodeRef
    , data : List Int
    }


type alias AddVoteInputOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `AddVoteInput` attributes. Note that this type
needs to use the `AddVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AddVoteInputRaw =
    { createdBy : UserRef
    , createdAt : Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : String
    , contract : ContractRef
    , node : NodeRef
    , data : List Int
    }


{-| Type for the AddVoteInput input object.
-}
type AddVoteInput
    = AddVoteInput AddVoteInputRaw


{-| Encode a AddVoteInput into a value that can be used as an argument.
-}
encodeAddVoteInput : AddVoteInput -> Value
encodeAddVoteInput (AddVoteInput input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef input____.createdBy |> Just ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.createdAt |> Just ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "voteid", Encode.string input____.voteid |> Just ), ( "contract", encodeContractRef input____.contract |> Just ), ( "node", encodeNodeRef input____.node |> Just ), ( "data", (Encode.int |> Encode.list) input____.data |> Just ) ]


buildAuthRule :
    (AuthRuleOptionalFields -> AuthRuleOptionalFields)
    -> AuthRule
buildAuthRule fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and = Absent, or = Absent, not = Absent, rule = Absent }
    in
    AuthRule { and = optionals____.and, or = optionals____.or, not = optionals____.not, rule = optionals____.rule }


type alias AuthRuleOptionalFields =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type alias for the `AuthRule` attributes. Note that this type
needs to use the `AuthRule` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias AuthRuleRaw =
    { and : OptionalArgument (List (Maybe AuthRule))
    , or : OptionalArgument (List (Maybe AuthRule))
    , not : OptionalArgument AuthRule
    , rule : OptionalArgument String
    }


{-| Type for the AuthRule input object.
-}
type AuthRule
    = AuthRule AuthRuleRaw


{-| Encode a AuthRule into a value that can be used as an argument.
-}
encodeAuthRule : AuthRule -> Value
encodeAuthRule (AuthRule input____) =
    Encode.maybeObject
        [ ( "and", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeAuthRule |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeAuthRule |> Encode.optional input____.not ), ( "rule", Encode.string |> Encode.optional input____.rule ) ]


buildBlobFilter :
    (BlobFilterOptionalFields -> BlobFilterOptionalFields)
    -> BlobFilter
buildBlobFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    BlobFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias BlobFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type alias for the `BlobFilter` attributes. Note that this type
needs to use the `BlobFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , blob_type : OptionalArgument BlobType_hash
    , pushedFlag : OptionalArgument DateTimeFilter
    , archivedFlag : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.BlobHasFilter.BlobHasFilter))
    , and : OptionalArgument (List (Maybe BlobFilter))
    , or : OptionalArgument (List (Maybe BlobFilter))
    , not : OptionalArgument BlobFilter
    }


{-| Type for the BlobFilter input object.
-}
type BlobFilter
    = BlobFilter BlobFilterRaw


{-| Encode a BlobFilter into a value that can be used as an argument.
-}
encodeBlobFilter : BlobFilter -> Value
encodeBlobFilter (BlobFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "blob_type", encodeBlobType_hash |> Encode.optional input____.blob_type ), ( "pushedFlag", encodeDateTimeFilter |> Encode.optional input____.pushedFlag ), ( "archivedFlag", encodeDateTimeFilter |> Encode.optional input____.archivedFlag ), ( "has", (Encode.enum Fractal.Enum.BlobHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeBlobFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeBlobFilter |> Encode.optional input____.not ) ]


buildBlobOrder :
    (BlobOrderOptionalFields -> BlobOrderOptionalFields)
    -> BlobOrder
buildBlobOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    BlobOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias BlobOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type alias for the `BlobOrder` attributes. Note that this type
needs to use the `BlobOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobOrderRaw =
    { asc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , desc : OptionalArgument Fractal.Enum.BlobOrderable.BlobOrderable
    , then_ : OptionalArgument BlobOrder
    }


{-| Type for the BlobOrder input object.
-}
type BlobOrder
    = BlobOrder BlobOrderRaw


{-| Encode a BlobOrder into a value that can be used as an argument.
-}
encodeBlobOrder : BlobOrder -> Value
encodeBlobOrder (BlobOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.BlobOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeBlobOrder |> Encode.optional input____.then_ ) ]


buildBlobPatch :
    (BlobPatchOptionalFields -> BlobPatchOptionalFields)
    -> BlobPatch
buildBlobPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias BlobPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobPatch` attributes. Note that this type
needs to use the `BlobPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobPatch input object.
-}
type BlobPatch
    = BlobPatch BlobPatchRaw


{-| Encode a BlobPatch into a value that can be used as an argument.
-}
encodeBlobPatch : BlobPatch -> Value
encodeBlobPatch (BlobPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildBlobRef :
    (BlobRefOptionalFields -> BlobRefOptionalFields)
    -> BlobRef
buildBlobRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, blob_type = Absent, pushedFlag = Absent, archivedFlag = Absent, node = Absent, md = Absent }
    in
    BlobRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, blob_type = optionals____.blob_type, pushedFlag = optionals____.pushedFlag, archivedFlag = optionals____.archivedFlag, node = optionals____.node, md = optionals____.md }


type alias BlobRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type alias for the `BlobRef` attributes. Note that this type
needs to use the `BlobRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias BlobRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , blob_type : OptionalArgument Fractal.Enum.BlobType.BlobType
    , pushedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , archivedFlag : OptionalArgument Fractal.ScalarCodecs.DateTime
    , node : OptionalArgument NodeFragmentRef
    , md : OptionalArgument String
    }


{-| Type for the BlobRef input object.
-}
type BlobRef
    = BlobRef BlobRefRaw


{-| Encode a BlobRef into a value that can be used as an argument.
-}
encodeBlobRef : BlobRef -> Value
encodeBlobRef (BlobRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "blob_type", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.blob_type ), ( "pushedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.pushedFlag ), ( "archivedFlag", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.archivedFlag ), ( "node", encodeNodeFragmentRef |> Encode.optional input____.node ), ( "md", Encode.string |> Encode.optional input____.md ) ]


buildBlobType_hash :
    (BlobType_hashOptionalFields -> BlobType_hashOptionalFields)
    -> BlobType_hash
buildBlobType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias BlobType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Type for the BlobType\_hash input object.
-}
type alias BlobType_hash =
    { eq : OptionalArgument Fractal.Enum.BlobType.BlobType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.BlobType.BlobType))
    }


{-| Encode a BlobType\_hash into a value that can be used as an argument.
-}
encodeBlobType_hash : BlobType_hash -> Value
encodeBlobType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.BlobType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.BlobType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildCommentFilter :
    (CommentFilterOptionalFields -> CommentFilterOptionalFields)
    -> CommentFilter
buildCommentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    CommentFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias CommentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type alias for the `CommentFilter` attributes. Note that this type
needs to use the `CommentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.CommentHasFilter.CommentHasFilter))
    , and : OptionalArgument (List (Maybe CommentFilter))
    , or : OptionalArgument (List (Maybe CommentFilter))
    , not : OptionalArgument CommentFilter
    }


{-| Type for the CommentFilter input object.
-}
type CommentFilter
    = CommentFilter CommentFilterRaw


{-| Encode a CommentFilter into a value that can be used as an argument.
-}
encodeCommentFilter : CommentFilter -> Value
encodeCommentFilter (CommentFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "has", (Encode.enum Fractal.Enum.CommentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeCommentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeCommentFilter |> Encode.optional input____.not ) ]


buildCommentOrder :
    (CommentOrderOptionalFields -> CommentOrderOptionalFields)
    -> CommentOrder
buildCommentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    CommentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias CommentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type alias for the `CommentOrder` attributes. Note that this type
needs to use the `CommentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , desc : OptionalArgument Fractal.Enum.CommentOrderable.CommentOrderable
    , then_ : OptionalArgument CommentOrder
    }


{-| Type for the CommentOrder input object.
-}
type CommentOrder
    = CommentOrder CommentOrderRaw


{-| Encode a CommentOrder into a value that can be used as an argument.
-}
encodeCommentOrder : CommentOrder -> Value
encodeCommentOrder (CommentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.CommentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeCommentOrder |> Encode.optional input____.then_ ) ]


buildCommentPatch :
    (CommentPatchOptionalFields -> CommentPatchOptionalFields)
    -> CommentPatch
buildCommentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, reactions = Absent }
    in
    CommentPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, reactions = optionals____.reactions }


type alias CommentPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type alias for the `CommentPatch` attributes. Note that this type
needs to use the `CommentPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type for the CommentPatch input object.
-}
type CommentPatch
    = CommentPatch CommentPatchRaw


{-| Encode a CommentPatch into a value that can be used as an argument.
-}
encodeCommentPatch : CommentPatch -> Value
encodeCommentPatch (CommentPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ) ]


buildCommentRef :
    (CommentRefOptionalFields -> CommentRefOptionalFields)
    -> CommentRef
buildCommentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, reactions = Absent }
    in
    CommentRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, reactions = optionals____.reactions }


type alias CommentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type alias for the `CommentRef` attributes. Note that this type
needs to use the `CommentRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias CommentRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , reactions : OptionalArgument (List ReactionRef)
    }


{-| Type for the CommentRef input object.
-}
type CommentRef
    = CommentRef CommentRefRaw


{-| Encode a CommentRef into a value that can be used as an argument.
-}
encodeCommentRef : CommentRef -> Value
encodeCommentRef (CommentRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ) ]


buildContainsFilter :
    (ContainsFilterOptionalFields -> ContainsFilterOptionalFields)
    -> ContainsFilter
buildContainsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { point = Absent, polygon = Absent }
    in
    { point = optionals____.point, polygon = optionals____.polygon }


type alias ContainsFilterOptionalFields =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Type for the ContainsFilter input object.
-}
type alias ContainsFilter =
    { point : OptionalArgument PointRef
    , polygon : OptionalArgument PolygonRef
    }


{-| Encode a ContainsFilter into a value that can be used as an argument.
-}
encodeContainsFilter : ContainsFilter -> Value
encodeContainsFilter input____ =
    Encode.maybeObject
        [ ( "point", encodePointRef |> Encode.optional input____.point ), ( "polygon", encodePolygonRef |> Encode.optional input____.polygon ) ]


buildContractFilter :
    (ContractFilterOptionalFields -> ContractFilterOptionalFields)
    -> ContractFilter
buildContractFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, contractid = Absent, status = Absent, contract_type = Absent, closedAt = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ContractFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, contractid = optionals____.contractid, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ContractFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , contractid : OptionalArgument StringHashFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type alias for the `ContractFilter` attributes. Note that this type
needs to use the `ContractFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , contractid : OptionalArgument StringHashFilter
    , status : OptionalArgument ContractStatus_hash
    , contract_type : OptionalArgument ContractType_hash
    , closedAt : OptionalArgument DateTimeFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ContractHasFilter.ContractHasFilter))
    , and : OptionalArgument (List (Maybe ContractFilter))
    , or : OptionalArgument (List (Maybe ContractFilter))
    , not : OptionalArgument ContractFilter
    }


{-| Type for the ContractFilter input object.
-}
type ContractFilter
    = ContractFilter ContractFilterRaw


{-| Encode a ContractFilter into a value that can be used as an argument.
-}
encodeContractFilter : ContractFilter -> Value
encodeContractFilter (ContractFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "contractid", encodeStringHashFilter |> Encode.optional input____.contractid ), ( "status", encodeContractStatus_hash |> Encode.optional input____.status ), ( "contract_type", encodeContractType_hash |> Encode.optional input____.contract_type ), ( "closedAt", encodeDateTimeFilter |> Encode.optional input____.closedAt ), ( "has", (Encode.enum Fractal.Enum.ContractHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeContractFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeContractFilter |> Encode.optional input____.not ) ]


buildContractOrder :
    (ContractOrderOptionalFields -> ContractOrderOptionalFields)
    -> ContractOrder
buildContractOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ContractOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ContractOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type alias for the `ContractOrder` attributes. Note that this type
needs to use the `ContractOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , desc : OptionalArgument Fractal.Enum.ContractOrderable.ContractOrderable
    , then_ : OptionalArgument ContractOrder
    }


{-| Type for the ContractOrder input object.
-}
type ContractOrder
    = ContractOrder ContractOrderRaw


{-| Encode a ContractOrder into a value that can be used as an argument.
-}
encodeContractOrder : ContractOrder -> Value
encodeContractOrder (ContractOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ContractOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeContractOrder |> Encode.optional input____.then_ ) ]


buildContractPatch :
    (ContractPatchOptionalFields -> ContractPatchOptionalFields)
    -> ContractPatch
buildContractPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, participants = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    ContractPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, event = optionals____.event, participants = optionals____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias ContractPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractPatch` attributes. Note that this type
needs to use the `ContractPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractPatch input object.
-}
type ContractPatch
    = ContractPatch ContractPatchRaw


{-| Encode a ContractPatch into a value that can be used as an argument.
-}
encodeContractPatch : ContractPatch -> Value
encodeContractPatch (ContractPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input____.event ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input____.participants ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildContractRef :
    (ContractRefOptionalFields -> ContractRefOptionalFields)
    -> ContractRef
buildContractRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, contractid = Absent, tension = Absent, status = Absent, contract_type = Absent, closedAt = Absent, event = Absent, participants = Absent, candidates = Absent, pending_candidates = Absent, comments = Absent, isValidator = Absent }
    in
    ContractRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contractid = optionals____.contractid, tension = optionals____.tension, status = optionals____.status, contract_type = optionals____.contract_type, closedAt = optionals____.closedAt, event = optionals____.event, participants = optionals____.participants, candidates = optionals____.candidates, pending_candidates = optionals____.pending_candidates, comments = optionals____.comments, isValidator = optionals____.isValidator }


type alias ContractRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type alias for the `ContractRef` attributes. Note that this type
needs to use the `ContractRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ContractRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contractid : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , status : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , contract_type : OptionalArgument Fractal.Enum.ContractType.ContractType
    , closedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , event : OptionalArgument EventFragmentRef
    , participants : OptionalArgument (List VoteRef)
    , candidates : OptionalArgument (List UserRef)
    , pending_candidates : OptionalArgument (List PendingUserRef)
    , comments : OptionalArgument (List CommentRef)
    , isValidator : OptionalArgument Bool
    }


{-| Type for the ContractRef input object.
-}
type ContractRef
    = ContractRef ContractRefRaw


{-| Encode a ContractRef into a value that can be used as an argument.
-}
encodeContractRef : ContractRef -> Value
encodeContractRef (ContractRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contractid", Encode.string |> Encode.optional input____.contractid ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "status", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.status ), ( "contract_type", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.contract_type ), ( "closedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.closedAt ), ( "event", encodeEventFragmentRef |> Encode.optional input____.event ), ( "participants", (encodeVoteRef |> Encode.list) |> Encode.optional input____.participants ), ( "candidates", (encodeUserRef |> Encode.list) |> Encode.optional input____.candidates ), ( "pending_candidates", (encodePendingUserRef |> Encode.list) |> Encode.optional input____.pending_candidates ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "isValidator", Encode.bool |> Encode.optional input____.isValidator ) ]


buildContractStatus_hash :
    (ContractStatus_hashOptionalFields -> ContractStatus_hashOptionalFields)
    -> ContractStatus_hash
buildContractStatus_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias ContractStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Type for the ContractStatus\_hash input object.
-}
type alias ContractStatus_hash =
    { eq : OptionalArgument Fractal.Enum.ContractStatus.ContractStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractStatus.ContractStatus))
    }


{-| Encode a ContractStatus\_hash into a value that can be used as an argument.
-}
encodeContractStatus_hash : ContractStatus_hash -> Value
encodeContractStatus_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.ContractStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildContractType_hash :
    (ContractType_hashOptionalFields -> ContractType_hashOptionalFields)
    -> ContractType_hash
buildContractType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias ContractType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Type for the ContractType\_hash input object.
-}
type alias ContractType_hash =
    { eq : OptionalArgument Fractal.Enum.ContractType.ContractType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ContractType.ContractType))
    }


{-| Encode a ContractType\_hash into a value that can be used as an argument.
-}
encodeContractType_hash : ContractType_hash -> Value
encodeContractType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ContractType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.ContractType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildCustomHTTP :
    CustomHTTPRequiredFields
    -> (CustomHTTPOptionalFields -> CustomHTTPOptionalFields)
    -> CustomHTTP
buildCustomHTTP required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { body = Absent, graphql = Absent, mode = Absent, forwardHeaders = Absent, secretHeaders = Absent, introspectionHeaders = Absent, skipIntrospection = Absent }
    in
    { url = required____.url, method = required____.method, body = optionals____.body, graphql = optionals____.graphql, mode = optionals____.mode, forwardHeaders = optionals____.forwardHeaders, secretHeaders = optionals____.secretHeaders, introspectionHeaders = optionals____.introspectionHeaders, skipIntrospection = optionals____.skipIntrospection }


type alias CustomHTTPRequiredFields =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    }


type alias CustomHTTPOptionalFields =
    { body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Type for the CustomHTTP input object.
-}
type alias CustomHTTP =
    { url : String
    , method : Fractal.Enum.HTTPMethod.HTTPMethod
    , body : OptionalArgument String
    , graphql : OptionalArgument String
    , mode : OptionalArgument Fractal.Enum.Mode.Mode
    , forwardHeaders : OptionalArgument (List String)
    , secretHeaders : OptionalArgument (List String)
    , introspectionHeaders : OptionalArgument (List String)
    , skipIntrospection : OptionalArgument Bool
    }


{-| Encode a CustomHTTP into a value that can be used as an argument.
-}
encodeCustomHTTP : CustomHTTP -> Value
encodeCustomHTTP input____ =
    Encode.maybeObject
        [ ( "url", Encode.string input____.url |> Just ), ( "method", Encode.enum Fractal.Enum.HTTPMethod.toString input____.method |> Just ), ( "body", Encode.string |> Encode.optional input____.body ), ( "graphql", Encode.string |> Encode.optional input____.graphql ), ( "mode", Encode.enum Fractal.Enum.Mode.toString |> Encode.optional input____.mode ), ( "forwardHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.forwardHeaders ), ( "secretHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.secretHeaders ), ( "introspectionHeaders", (Encode.string |> Encode.list) |> Encode.optional input____.introspectionHeaders ), ( "skipIntrospection", Encode.bool |> Encode.optional input____.skipIntrospection ) ]


buildDateTimeFilter :
    (DateTimeFilterOptionalFields -> DateTimeFilterOptionalFields)
    -> DateTimeFilter
buildDateTimeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias DateTimeFilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Type for the DateTimeFilter input object.
-}
type alias DateTimeFilter =
    { eq : OptionalArgument Fractal.ScalarCodecs.DateTime
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.DateTime))
    , le : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , ge : OptionalArgument Fractal.ScalarCodecs.DateTime
    , gt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , between : OptionalArgument DateTimeRange
    }


{-| Encode a DateTimeFilter into a value that can be used as an argument.
-}
encodeDateTimeFilter : DateTimeFilter -> Value
encodeDateTimeFilter input____ =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.gt ), ( "between", encodeDateTimeRange |> Encode.optional input____.between ) ]


buildDateTimeRange :
    DateTimeRangeRequiredFields
    -> DateTimeRange
buildDateTimeRange required____ =
    { min = required____.min, max = required____.max }


type alias DateTimeRangeRequiredFields =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Type for the DateTimeRange input object.
-}
type alias DateTimeRange =
    { min : Fractal.ScalarCodecs.DateTime
    , max : Fractal.ScalarCodecs.DateTime
    }


{-| Encode a DateTimeRange into a value that can be used as an argument.
-}
encodeDateTimeRange : DateTimeRange -> Value
encodeDateTimeRange input____ =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) input____.max |> Just ) ]


buildEventCountFilter :
    (EventCountFilterOptionalFields -> EventCountFilterOptionalFields)
    -> EventCountFilter
buildEventCountFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventCountFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias EventCountFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.EventCountHasFilter.EventCountHasFilter))
    , and : OptionalArgument (List (Maybe EventCountFilter))
    , or : OptionalArgument (List (Maybe EventCountFilter))
    , not : OptionalArgument EventCountFilter
    }


{-| Type alias for the `EventCountFilter` attributes. Note that this type
needs to use the `EventCountFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventCountFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.EventCountHasFilter.EventCountHasFilter))
    , and : OptionalArgument (List (Maybe EventCountFilter))
    , or : OptionalArgument (List (Maybe EventCountFilter))
    , not : OptionalArgument EventCountFilter
    }


{-| Type for the EventCountFilter input object.
-}
type EventCountFilter
    = EventCountFilter EventCountFilterRaw


{-| Encode a EventCountFilter into a value that can be used as an argument.
-}
encodeEventCountFilter : EventCountFilter -> Value
encodeEventCountFilter (EventCountFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.EventCountHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeEventCountFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeEventCountFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeEventCountFilter |> Encode.optional input____.not ) ]


buildEventCountOrder :
    (EventCountOrderOptionalFields -> EventCountOrderOptionalFields)
    -> EventCountOrder
buildEventCountOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventCountOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias EventCountOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventCountOrderable.EventCountOrderable
    , desc : OptionalArgument Fractal.Enum.EventCountOrderable.EventCountOrderable
    , then_ : OptionalArgument EventCountOrder
    }


{-| Type alias for the `EventCountOrder` attributes. Note that this type
needs to use the `EventCountOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventCountOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventCountOrderable.EventCountOrderable
    , desc : OptionalArgument Fractal.Enum.EventCountOrderable.EventCountOrderable
    , then_ : OptionalArgument EventCountOrder
    }


{-| Type for the EventCountOrder input object.
-}
type EventCountOrder
    = EventCountOrder EventCountOrderRaw


{-| Encode a EventCountOrder into a value that can be used as an argument.
-}
encodeEventCountOrder : EventCountOrder -> Value
encodeEventCountOrder (EventCountOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventCountOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.EventCountOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeEventCountOrder |> Encode.optional input____.then_ ) ]


buildEventCountPatch :
    (EventCountPatchOptionalFields -> EventCountPatchOptionalFields)
    -> EventCountPatch
buildEventCountPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { unread_events = Absent, pending_contracts = Absent, assigned_tensions = Absent }
    in
    { unread_events = optionals____.unread_events, pending_contracts = optionals____.pending_contracts, assigned_tensions = optionals____.assigned_tensions }


type alias EventCountPatchOptionalFields =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Type for the EventCountPatch input object.
-}
type alias EventCountPatch =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Encode a EventCountPatch into a value that can be used as an argument.
-}
encodeEventCountPatch : EventCountPatch -> Value
encodeEventCountPatch input____ =
    Encode.maybeObject
        [ ( "unread_events", Encode.int |> Encode.optional input____.unread_events ), ( "pending_contracts", Encode.int |> Encode.optional input____.pending_contracts ), ( "assigned_tensions", Encode.int |> Encode.optional input____.assigned_tensions ) ]


buildEventCountRef :
    (EventCountRefOptionalFields -> EventCountRefOptionalFields)
    -> EventCountRef
buildEventCountRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { unread_events = Absent, pending_contracts = Absent, assigned_tensions = Absent }
    in
    { unread_events = optionals____.unread_events, pending_contracts = optionals____.pending_contracts, assigned_tensions = optionals____.assigned_tensions }


type alias EventCountRefOptionalFields =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Type for the EventCountRef input object.
-}
type alias EventCountRef =
    { unread_events : OptionalArgument Int
    , pending_contracts : OptionalArgument Int
    , assigned_tensions : OptionalArgument Int
    }


{-| Encode a EventCountRef into a value that can be used as an argument.
-}
encodeEventCountRef : EventCountRef -> Value
encodeEventCountRef input____ =
    Encode.maybeObject
        [ ( "unread_events", Encode.int |> Encode.optional input____.unread_events ), ( "pending_contracts", Encode.int |> Encode.optional input____.pending_contracts ), ( "assigned_tensions", Encode.int |> Encode.optional input____.assigned_tensions ) ]


buildEventFilter :
    (EventFilterOptionalFields -> EventFilterOptionalFields)
    -> EventFilter
buildEventFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, event_type = optionals____.event_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias EventFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type alias for the `EventFilter` attributes. Note that this type
needs to use the `EventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventHasFilter.EventHasFilter))
    , and : OptionalArgument (List (Maybe EventFilter))
    , or : OptionalArgument (List (Maybe EventFilter))
    , not : OptionalArgument EventFilter
    }


{-| Type for the EventFilter input object.
-}
type EventFilter
    = EventFilter EventFilterRaw


{-| Encode a EventFilter into a value that can be used as an argument.
-}
encodeEventFilter : EventFilter -> Value
encodeEventFilter (EventFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "event_type", encodeTensionEvent_hash |> Encode.optional input____.event_type ), ( "has", (Encode.enum Fractal.Enum.EventHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeEventFilter |> Encode.optional input____.not ) ]


buildEventFragmentFilter :
    (EventFragmentFilterOptionalFields -> EventFragmentFilterOptionalFields)
    -> EventFragmentFilter
buildEventFragmentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    EventFragmentFilter { event_type = optionals____.event_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias EventFragmentFilterOptionalFields =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type alias for the `EventFragmentFilter` attributes. Note that this type
needs to use the `EventFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentFilterRaw =
    { event_type : OptionalArgument TensionEvent_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.EventFragmentHasFilter.EventFragmentHasFilter))
    , and : OptionalArgument (List (Maybe EventFragmentFilter))
    , or : OptionalArgument (List (Maybe EventFragmentFilter))
    , not : OptionalArgument EventFragmentFilter
    }


{-| Type for the EventFragmentFilter input object.
-}
type EventFragmentFilter
    = EventFragmentFilter EventFragmentFilterRaw


{-| Encode a EventFragmentFilter into a value that can be used as an argument.
-}
encodeEventFragmentFilter : EventFragmentFilter -> Value
encodeEventFragmentFilter (EventFragmentFilter input____) =
    Encode.maybeObject
        [ ( "event_type", encodeTensionEvent_hash |> Encode.optional input____.event_type ), ( "has", (Encode.enum Fractal.Enum.EventFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeEventFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeEventFragmentFilter |> Encode.optional input____.not ) ]


buildEventFragmentOrder :
    (EventFragmentOrderOptionalFields -> EventFragmentOrderOptionalFields)
    -> EventFragmentOrder
buildEventFragmentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventFragmentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias EventFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type alias for the `EventFragmentOrder` attributes. Note that this type
needs to use the `EventFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.EventFragmentOrderable.EventFragmentOrderable
    , then_ : OptionalArgument EventFragmentOrder
    }


{-| Type for the EventFragmentOrder input object.
-}
type EventFragmentOrder
    = EventFragmentOrder EventFragmentOrderRaw


{-| Encode a EventFragmentOrder into a value that can be used as an argument.
-}
encodeEventFragmentOrder : EventFragmentOrder -> Value
encodeEventFragmentOrder (EventFragmentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.EventFragmentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeEventFragmentOrder |> Encode.optional input____.then_ ) ]


buildEventFragmentPatch :
    (EventFragmentPatchOptionalFields -> EventFragmentPatchOptionalFields)
    -> EventFragmentPatch
buildEventFragmentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventFragmentPatchOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentPatch input object.
-}
type alias EventFragmentPatch =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentPatch into a value that can be used as an argument.
-}
encodeEventFragmentPatch : EventFragmentPatch -> Value
encodeEventFragmentPatch input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventFragmentRef :
    (EventFragmentRefOptionalFields -> EventFragmentRefOptionalFields)
    -> EventFragmentRef
buildEventFragmentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { event_type = Absent, old = Absent, new = Absent }
    in
    { event_type = optionals____.event_type, old = optionals____.old, new = optionals____.new }


type alias EventFragmentRefOptionalFields =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventFragmentRef input object.
-}
type alias EventFragmentRef =
    { event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Encode a EventFragmentRef into a value that can be used as an argument.
-}
encodeEventFragmentRef : EventFragmentRef -> Value
encodeEventFragmentRef input____ =
    Encode.maybeObject
        [ ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventKindFilter :
    (EventKindFilterOptionalFields -> EventKindFilterOptionalFields)
    -> EventKindFilter
buildEventKindFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { memberTypes = Absent, eventFilter = Absent, contractFilter = Absent, notifFilter = Absent }
    in
    EventKindFilter { memberTypes = optionals____.memberTypes, eventFilter = optionals____.eventFilter, contractFilter = optionals____.contractFilter, notifFilter = optionals____.notifFilter }


type alias EventKindFilterOptionalFields =
    { memberTypes : OptionalArgument (List Fractal.Enum.EventKindType.EventKindType)
    , eventFilter : OptionalArgument EventFilter
    , contractFilter : OptionalArgument ContractFilter
    , notifFilter : OptionalArgument NotifFilter
    }


{-| Type alias for the `EventKindFilter` attributes. Note that this type
needs to use the `EventKindFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventKindFilterRaw =
    { memberTypes : OptionalArgument (List Fractal.Enum.EventKindType.EventKindType)
    , eventFilter : OptionalArgument EventFilter
    , contractFilter : OptionalArgument ContractFilter
    , notifFilter : OptionalArgument NotifFilter
    }


{-| Type for the EventKindFilter input object.
-}
type EventKindFilter
    = EventKindFilter EventKindFilterRaw


{-| Encode a EventKindFilter into a value that can be used as an argument.
-}
encodeEventKindFilter : EventKindFilter -> Value
encodeEventKindFilter (EventKindFilter input____) =
    Encode.maybeObject
        [ ( "memberTypes", (Encode.enum Fractal.Enum.EventKindType.toString |> Encode.list) |> Encode.optional input____.memberTypes ), ( "eventFilter", encodeEventFilter |> Encode.optional input____.eventFilter ), ( "contractFilter", encodeContractFilter |> Encode.optional input____.contractFilter ), ( "notifFilter", encodeNotifFilter |> Encode.optional input____.notifFilter ) ]


buildEventKindRef :
    (EventKindRefOptionalFields -> EventKindRefOptionalFields)
    -> EventKindRef
buildEventKindRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eventRef = Absent, contractRef = Absent, notifRef = Absent }
    in
    EventKindRef { eventRef = optionals____.eventRef, contractRef = optionals____.contractRef, notifRef = optionals____.notifRef }


type alias EventKindRefOptionalFields =
    { eventRef : OptionalArgument EventRef
    , contractRef : OptionalArgument ContractRef
    , notifRef : OptionalArgument NotifRef
    }


{-| Type alias for the `EventKindRef` attributes. Note that this type
needs to use the `EventKindRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventKindRefRaw =
    { eventRef : OptionalArgument EventRef
    , contractRef : OptionalArgument ContractRef
    , notifRef : OptionalArgument NotifRef
    }


{-| Type for the EventKindRef input object.
-}
type EventKindRef
    = EventKindRef EventKindRefRaw


{-| Encode a EventKindRef into a value that can be used as an argument.
-}
encodeEventKindRef : EventKindRef -> Value
encodeEventKindRef (EventKindRef input____) =
    Encode.maybeObject
        [ ( "eventRef", encodeEventRef |> Encode.optional input____.eventRef ), ( "contractRef", encodeContractRef |> Encode.optional input____.contractRef ), ( "notifRef", encodeNotifRef |> Encode.optional input____.notifRef ) ]


buildEventOrder :
    (EventOrderOptionalFields -> EventOrderOptionalFields)
    -> EventOrder
buildEventOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    EventOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias EventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type alias for the `EventOrder` attributes. Note that this type
needs to use the `EventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , desc : OptionalArgument Fractal.Enum.EventOrderable.EventOrderable
    , then_ : OptionalArgument EventOrder
    }


{-| Type for the EventOrder input object.
-}
type EventOrder
    = EventOrder EventOrderRaw


{-| Encode a EventOrder into a value that can be used as an argument.
-}
encodeEventOrder : EventOrder -> Value
encodeEventOrder (EventOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.EventOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeEventOrder |> Encode.optional input____.then_ ) ]


buildEventPatch :
    (EventPatchOptionalFields -> EventPatchOptionalFields)
    -> EventPatch
buildEventPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, mentioned = Absent, old = Absent, new = Absent }
    in
    EventPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, event_type = optionals____.event_type, mentioned = optionals____.mentioned, old = optionals____.old, new = optionals____.new }


type alias EventPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventPatch` attributes. Note that this type
needs to use the `EventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventPatch input object.
-}
type EventPatch
    = EventPatch EventPatchRaw


{-| Encode a EventPatch into a value that can be used as an argument.
-}
encodeEventPatch : EventPatch -> Value
encodeEventPatch (EventPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "mentioned", encodeTensionRef |> Encode.optional input____.mentioned ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildEventRef :
    (EventRefOptionalFields -> EventRefOptionalFields)
    -> EventRef
buildEventRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension = Absent, event_type = Absent, mentioned = Absent, old = Absent, new = Absent }
    in
    EventRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension = optionals____.tension, event_type = optionals____.event_type, mentioned = optionals____.mentioned, old = optionals____.old, new = optionals____.new }


type alias EventRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type alias for the `EventRef` attributes. Note that this type
needs to use the `EventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias EventRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension : OptionalArgument TensionRef
    , event_type : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , mentioned : OptionalArgument TensionRef
    , old : OptionalArgument String
    , new : OptionalArgument String
    }


{-| Type for the EventRef input object.
-}
type EventRef
    = EventRef EventRefRaw


{-| Encode a EventRef into a value that can be used as an argument.
-}
encodeEventRef : EventRef -> Value
encodeEventRef (EventRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "event_type", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.event_type ), ( "mentioned", encodeTensionRef |> Encode.optional input____.mentioned ), ( "old", Encode.string |> Encode.optional input____.old ), ( "new", Encode.string |> Encode.optional input____.new ) ]


buildFloatFilter :
    (FloatFilterOptionalFields -> FloatFilterOptionalFields)
    -> FloatFilter
buildFloatFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias FloatFilterOptionalFields =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Type for the FloatFilter input object.
-}
type alias FloatFilter =
    { eq : OptionalArgument Float
    , in_ : OptionalArgument (List (Maybe Float))
    , le : OptionalArgument Float
    , lt : OptionalArgument Float
    , ge : OptionalArgument Float
    , gt : OptionalArgument Float
    , between : OptionalArgument FloatRange
    }


{-| Encode a FloatFilter into a value that can be used as an argument.
-}
encodeFloatFilter : FloatFilter -> Value
encodeFloatFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.float |> Encode.optional input____.eq ), ( "in", (Encode.float |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.float |> Encode.optional input____.le ), ( "lt", Encode.float |> Encode.optional input____.lt ), ( "ge", Encode.float |> Encode.optional input____.ge ), ( "gt", Encode.float |> Encode.optional input____.gt ), ( "between", encodeFloatRange |> Encode.optional input____.between ) ]


buildFloatRange :
    FloatRangeRequiredFields
    -> FloatRange
buildFloatRange required____ =
    { min = required____.min, max = required____.max }


type alias FloatRangeRequiredFields =
    { min : Float
    , max : Float
    }


{-| Type for the FloatRange input object.
-}
type alias FloatRange =
    { min : Float
    , max : Float
    }


{-| Encode a FloatRange into a value that can be used as an argument.
-}
encodeFloatRange : FloatRange -> Value
encodeFloatRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.float input____.min |> Just ), ( "max", Encode.float input____.max |> Just ) ]


buildGenerateMutationParams :
    (GenerateMutationParamsOptionalFields -> GenerateMutationParamsOptionalFields)
    -> GenerateMutationParams
buildGenerateMutationParams fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { add = Absent, update = Absent, delete = Absent }
    in
    { add = optionals____.add, update = optionals____.update, delete = optionals____.delete }


type alias GenerateMutationParamsOptionalFields =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Type for the GenerateMutationParams input object.
-}
type alias GenerateMutationParams =
    { add : OptionalArgument Bool
    , update : OptionalArgument Bool
    , delete : OptionalArgument Bool
    }


{-| Encode a GenerateMutationParams into a value that can be used as an argument.
-}
encodeGenerateMutationParams : GenerateMutationParams -> Value
encodeGenerateMutationParams input____ =
    Encode.maybeObject
        [ ( "add", Encode.bool |> Encode.optional input____.add ), ( "update", Encode.bool |> Encode.optional input____.update ), ( "delete", Encode.bool |> Encode.optional input____.delete ) ]


buildGenerateQueryParams :
    (GenerateQueryParamsOptionalFields -> GenerateQueryParamsOptionalFields)
    -> GenerateQueryParams
buildGenerateQueryParams fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { get = Absent, query = Absent, password = Absent, aggregate = Absent }
    in
    { get = optionals____.get, query = optionals____.query, password = optionals____.password, aggregate = optionals____.aggregate }


type alias GenerateQueryParamsOptionalFields =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Type for the GenerateQueryParams input object.
-}
type alias GenerateQueryParams =
    { get : OptionalArgument Bool
    , query : OptionalArgument Bool
    , password : OptionalArgument Bool
    , aggregate : OptionalArgument Bool
    }


{-| Encode a GenerateQueryParams into a value that can be used as an argument.
-}
encodeGenerateQueryParams : GenerateQueryParams -> Value
encodeGenerateQueryParams input____ =
    Encode.maybeObject
        [ ( "get", Encode.bool |> Encode.optional input____.get ), ( "query", Encode.bool |> Encode.optional input____.query ), ( "password", Encode.bool |> Encode.optional input____.password ), ( "aggregate", Encode.bool |> Encode.optional input____.aggregate ) ]


buildInt64Filter :
    (Int64FilterOptionalFields -> Int64FilterOptionalFields)
    -> Int64Filter
buildInt64Filter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias Int64FilterOptionalFields =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Type for the Int64Filter input object.
-}
type alias Int64Filter =
    { eq : OptionalArgument Fractal.ScalarCodecs.Int64
    , in_ : OptionalArgument (List (Maybe Fractal.ScalarCodecs.Int64))
    , le : OptionalArgument Fractal.ScalarCodecs.Int64
    , lt : OptionalArgument Fractal.ScalarCodecs.Int64
    , ge : OptionalArgument Fractal.ScalarCodecs.Int64
    , gt : OptionalArgument Fractal.ScalarCodecs.Int64
    , between : OptionalArgument Int64Range
    }


{-| Encode a Int64Filter into a value that can be used as an argument.
-}
encodeInt64Filter : Int64Filter -> Value
encodeInt64Filter input____ =
    Encode.maybeObject
        [ ( "eq", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.eq ), ( "in", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.le ), ( "lt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.lt ), ( "ge", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.ge ), ( "gt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) |> Encode.optional input____.gt ), ( "between", encodeInt64Range |> Encode.optional input____.between ) ]


buildInt64Range :
    Int64RangeRequiredFields
    -> Int64Range
buildInt64Range required____ =
    { min = required____.min, max = required____.max }


type alias Int64RangeRequiredFields =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Type for the Int64Range input object.
-}
type alias Int64Range =
    { min : Fractal.ScalarCodecs.Int64
    , max : Fractal.ScalarCodecs.Int64
    }


{-| Encode a Int64Range into a value that can be used as an argument.
-}
encodeInt64Range : Int64Range -> Value
encodeInt64Range input____ =
    Encode.maybeObject
        [ ( "min", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input____.min |> Just ), ( "max", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecInt64) input____.max |> Just ) ]


buildIntFilter :
    (IntFilterOptionalFields -> IntFilterOptionalFields)
    -> IntFilter
buildIntFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias IntFilterOptionalFields =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Type for the IntFilter input object.
-}
type alias IntFilter =
    { eq : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , le : OptionalArgument Int
    , lt : OptionalArgument Int
    , ge : OptionalArgument Int
    , gt : OptionalArgument Int
    , between : OptionalArgument IntRange
    }


{-| Encode a IntFilter into a value that can be used as an argument.
-}
encodeIntFilter : IntFilter -> Value
encodeIntFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.int |> Encode.optional input____.eq ), ( "in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.int |> Encode.optional input____.le ), ( "lt", Encode.int |> Encode.optional input____.lt ), ( "ge", Encode.int |> Encode.optional input____.ge ), ( "gt", Encode.int |> Encode.optional input____.gt ), ( "between", encodeIntRange |> Encode.optional input____.between ) ]


buildIntRange :
    IntRangeRequiredFields
    -> IntRange
buildIntRange required____ =
    { min = required____.min, max = required____.max }


type alias IntRangeRequiredFields =
    { min : Int
    , max : Int
    }


{-| Type for the IntRange input object.
-}
type alias IntRange =
    { min : Int
    , max : Int
    }


{-| Encode a IntRange into a value that can be used as an argument.
-}
encodeIntRange : IntRange -> Value
encodeIntRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.int input____.min |> Just ), ( "max", Encode.int input____.max |> Just ) ]


buildIntersectsFilter :
    (IntersectsFilterOptionalFields -> IntersectsFilterOptionalFields)
    -> IntersectsFilter
buildIntersectsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { polygon = Absent, multiPolygon = Absent }
    in
    { polygon = optionals____.polygon, multiPolygon = optionals____.multiPolygon }


type alias IntersectsFilterOptionalFields =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Type for the IntersectsFilter input object.
-}
type alias IntersectsFilter =
    { polygon : OptionalArgument PolygonRef
    , multiPolygon : OptionalArgument MultiPolygonRef
    }


{-| Encode a IntersectsFilter into a value that can be used as an argument.
-}
encodeIntersectsFilter : IntersectsFilter -> Value
encodeIntersectsFilter input____ =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef |> Encode.optional input____.polygon ), ( "multiPolygon", encodeMultiPolygonRef |> Encode.optional input____.multiPolygon ) ]


buildLabelFilter :
    (LabelFilterOptionalFields -> LabelFilterOptionalFields)
    -> LabelFilter
buildLabelFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    LabelFilter { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias LabelFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type alias for the `LabelFilter` attributes. Note that this type
needs to use the `LabelFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.LabelHasFilter.LabelHasFilter))
    , and : OptionalArgument (List (Maybe LabelFilter))
    , or : OptionalArgument (List (Maybe LabelFilter))
    , not : OptionalArgument LabelFilter
    }


{-| Type for the LabelFilter input object.
-}
type LabelFilter
    = LabelFilter LabelFilterRaw


{-| Encode a LabelFilter into a value that can be used as an argument.
-}
encodeLabelFilter : LabelFilter -> Value
encodeLabelFilter (LabelFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input____.rootnameid ), ( "name", encodeStringHashFilter_StringTermFilter |> Encode.optional input____.name ), ( "has", (Encode.enum Fractal.Enum.LabelHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeLabelFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeLabelFilter |> Encode.optional input____.not ) ]


buildLabelOrder :
    (LabelOrderOptionalFields -> LabelOrderOptionalFields)
    -> LabelOrder
buildLabelOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    LabelOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias LabelOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type alias for the `LabelOrder` attributes. Note that this type
needs to use the `LabelOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelOrderRaw =
    { asc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , desc : OptionalArgument Fractal.Enum.LabelOrderable.LabelOrderable
    , then_ : OptionalArgument LabelOrder
    }


{-| Type for the LabelOrder input object.
-}
type LabelOrder
    = LabelOrder LabelOrderRaw


{-| Encode a LabelOrder into a value that can be used as an argument.
-}
encodeLabelOrder : LabelOrder -> Value
encodeLabelOrder (LabelOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.LabelOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeLabelOrder |> Encode.optional input____.then_ ) ]


buildLabelPatch :
    (LabelPatchOptionalFields -> LabelPatchOptionalFields)
    -> LabelPatch
buildLabelPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent }
    in
    LabelPatch { rootnameid = optionals____.rootnameid, name = optionals____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes }


type alias LabelPatchOptionalFields =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `LabelPatch` attributes. Note that this type
needs to use the `LabelPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelPatchRaw =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the LabelPatch input object.
-}
type LabelPatch
    = LabelPatch LabelPatchRaw


{-| Encode a LabelPatch into a value that can be used as an argument.
-}
encodeLabelPatch : LabelPatch -> Value
encodeLabelPatch (LabelPatch input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildLabelRef :
    (LabelRefOptionalFields -> LabelRefOptionalFields)
    -> LabelRef
buildLabelRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, description = Absent, color = Absent, tensions = Absent, nodes = Absent }
    in
    LabelRef { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, description = optionals____.description, color = optionals____.color, tensions = optionals____.tensions, nodes = optionals____.nodes }


type alias LabelRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `LabelRef` attributes. Note that this type
needs to use the `LabelRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias LabelRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , color : OptionalArgument String
    , tensions : OptionalArgument (List TensionRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the LabelRef input object.
-}
type LabelRef
    = LabelRef LabelRefRaw


{-| Encode a LabelRef into a value that can be used as an argument.
-}
encodeLabelRef : LabelRef -> Value
encodeLabelRef (LabelRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "color", Encode.string |> Encode.optional input____.color ), ( "tensions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildMandateFilter :
    (MandateFilterOptionalFields -> MandateFilterOptionalFields)
    -> MandateFilter
buildMandateFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, purpose = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    MandateFilter { id = optionals____.id, purpose = optionals____.purpose, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias MandateFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type alias for the `MandateFilter` attributes. Note that this type
needs to use the `MandateFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , purpose : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.MandateHasFilter.MandateHasFilter))
    , and : OptionalArgument (List (Maybe MandateFilter))
    , or : OptionalArgument (List (Maybe MandateFilter))
    , not : OptionalArgument MandateFilter
    }


{-| Type for the MandateFilter input object.
-}
type MandateFilter
    = MandateFilter MandateFilterRaw


{-| Encode a MandateFilter into a value that can be used as an argument.
-}
encodeMandateFilter : MandateFilter -> Value
encodeMandateFilter (MandateFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "purpose", encodeStringFullTextFilter |> Encode.optional input____.purpose ), ( "has", (Encode.enum Fractal.Enum.MandateHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeMandateFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeMandateFilter |> Encode.optional input____.not ) ]


buildMandateOrder :
    (MandateOrderOptionalFields -> MandateOrderOptionalFields)
    -> MandateOrder
buildMandateOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    MandateOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias MandateOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type alias for the `MandateOrder` attributes. Note that this type
needs to use the `MandateOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias MandateOrderRaw =
    { asc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , desc : OptionalArgument Fractal.Enum.MandateOrderable.MandateOrderable
    , then_ : OptionalArgument MandateOrder
    }


{-| Type for the MandateOrder input object.
-}
type MandateOrder
    = MandateOrder MandateOrderRaw


{-| Encode a MandateOrder into a value that can be used as an argument.
-}
encodeMandateOrder : MandateOrder -> Value
encodeMandateOrder (MandateOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.MandateOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeMandateOrder |> Encode.optional input____.then_ ) ]


buildMandatePatch :
    (MandatePatchOptionalFields -> MandatePatchOptionalFields)
    -> MandatePatch
buildMandatePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { purpose = optionals____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias MandatePatchOptionalFields =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandatePatch input object.
-}
type alias MandatePatch =
    { purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandatePatch into a value that can be used as an argument.
-}
encodeMandatePatch : MandatePatch -> Value
encodeMandatePatch input____ =
    Encode.maybeObject
        [ ( "purpose", Encode.string |> Encode.optional input____.purpose ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildMandateRef :
    (MandateRefOptionalFields -> MandateRefOptionalFields)
    -> MandateRef
buildMandateRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, purpose = Absent, responsabilities = Absent, domains = Absent, policies = Absent }
    in
    { id = optionals____.id, purpose = optionals____.purpose, responsabilities = optionals____.responsabilities, domains = optionals____.domains, policies = optionals____.policies }


type alias MandateRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Type for the MandateRef input object.
-}
type alias MandateRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , purpose : OptionalArgument String
    , responsabilities : OptionalArgument String
    , domains : OptionalArgument String
    , policies : OptionalArgument String
    }


{-| Encode a MandateRef into a value that can be used as an argument.
-}
encodeMandateRef : MandateRef -> Value
encodeMandateRef input____ =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "purpose", Encode.string |> Encode.optional input____.purpose ), ( "responsabilities", Encode.string |> Encode.optional input____.responsabilities ), ( "domains", Encode.string |> Encode.optional input____.domains ), ( "policies", Encode.string |> Encode.optional input____.policies ) ]


buildMultiPolygonRef :
    MultiPolygonRefRequiredFields
    -> MultiPolygonRef
buildMultiPolygonRef required____ =
    { polygons = required____.polygons }


type alias MultiPolygonRefRequiredFields =
    { polygons : List PolygonRef }


{-| Type for the MultiPolygonRef input object.
-}
type alias MultiPolygonRef =
    { polygons : List PolygonRef }


{-| Encode a MultiPolygonRef into a value that can be used as an argument.
-}
encodeMultiPolygonRef : MultiPolygonRef -> Value
encodeMultiPolygonRef input____ =
    Encode.maybeObject
        [ ( "polygons", (encodePolygonRef |> Encode.list) input____.polygons |> Just ) ]


buildNearFilter :
    NearFilterRequiredFields
    -> NearFilter
buildNearFilter required____ =
    { distance = required____.distance, coordinate = required____.coordinate }


type alias NearFilterRequiredFields =
    { distance : Float
    , coordinate : PointRef
    }


{-| Type for the NearFilter input object.
-}
type alias NearFilter =
    { distance : Float
    , coordinate : PointRef
    }


{-| Encode a NearFilter into a value that can be used as an argument.
-}
encodeNearFilter : NearFilter -> Value
encodeNearFilter input____ =
    Encode.maybeObject
        [ ( "distance", Encode.float input____.distance |> Just ), ( "coordinate", encodePointRef input____.coordinate |> Just ) ]


buildNodeFilter :
    (NodeFilterOptionalFields -> NodeFilterOptionalFields)
    -> NodeFilter
buildNodeFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, nameid = Absent, rootnameid = Absent, name = Absent, about = Absent, skills = Absent, isRoot = Absent, type_ = Absent, visibility = Absent, mode = Absent, isArchived = Absent, isPersonal = Absent, role_type = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFilter { id = optionals____.id, createdAt = optionals____.createdAt, nameid = optionals____.nameid, rootnameid = optionals____.rootnameid, name = optionals____.name, about = optionals____.about, skills = optionals____.skills, isRoot = optionals____.isRoot, type_ = optionals____.type_, visibility = optionals____.visibility, mode = optionals____.mode, isArchived = optionals____.isArchived, isPersonal = optionals____.isPersonal, role_type = optionals____.role_type, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias NodeFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringFullTextFilter
    , about : OptionalArgument StringFullTextFilter
    , skills : OptionalArgument StringTermFilter
    , isRoot : OptionalArgument Bool
    , type_ : OptionalArgument NodeType_hash
    , visibility : OptionalArgument NodeVisibility_hash
    , mode : OptionalArgument NodeMode_hash
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type alias for the `NodeFilter` attributes. Note that this type
needs to use the `NodeFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , nameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , rootnameid : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringFullTextFilter
    , about : OptionalArgument StringFullTextFilter
    , skills : OptionalArgument StringTermFilter
    , isRoot : OptionalArgument Bool
    , type_ : OptionalArgument NodeType_hash
    , visibility : OptionalArgument NodeVisibility_hash
    , mode : OptionalArgument NodeMode_hash
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , role_type : OptionalArgument RoleType_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeHasFilter.NodeHasFilter))
    , and : OptionalArgument (List (Maybe NodeFilter))
    , or : OptionalArgument (List (Maybe NodeFilter))
    , not : OptionalArgument NodeFilter
    }


{-| Type for the NodeFilter input object.
-}
type NodeFilter
    = NodeFilter NodeFilterRaw


{-| Encode a NodeFilter into a value that can be used as an argument.
-}
encodeNodeFilter : NodeFilter -> Value
encodeNodeFilter (NodeFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "nameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.nameid ), ( "rootnameid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.rootnameid ), ( "name", encodeStringFullTextFilter |> Encode.optional input____.name ), ( "about", encodeStringFullTextFilter |> Encode.optional input____.about ), ( "skills", encodeStringTermFilter |> Encode.optional input____.skills ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "type_", encodeNodeType_hash |> Encode.optional input____.type_ ), ( "visibility", encodeNodeVisibility_hash |> Encode.optional input____.visibility ), ( "mode", encodeNodeMode_hash |> Encode.optional input____.mode ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "role_type", encodeRoleType_hash |> Encode.optional input____.role_type ), ( "has", (Encode.enum Fractal.Enum.NodeHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeNodeFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeNodeFilter |> Encode.optional input____.not ) ]


buildNodeFragmentFilter :
    (NodeFragmentFilterOptionalFields -> NodeFragmentFilterOptionalFields)
    -> NodeFragmentFilter
buildNodeFragmentFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NodeFragmentFilter { id = optionals____.id, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias NodeFragmentFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type alias for the `NodeFragmentFilter` attributes. Note that this type
needs to use the `NodeFragmentFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.NodeFragmentHasFilter.NodeFragmentHasFilter))
    , and : OptionalArgument (List (Maybe NodeFragmentFilter))
    , or : OptionalArgument (List (Maybe NodeFragmentFilter))
    , not : OptionalArgument NodeFragmentFilter
    }


{-| Type for the NodeFragmentFilter input object.
-}
type NodeFragmentFilter
    = NodeFragmentFilter NodeFragmentFilterRaw


{-| Encode a NodeFragmentFilter into a value that can be used as an argument.
-}
encodeNodeFragmentFilter : NodeFragmentFilter -> Value
encodeNodeFragmentFilter (NodeFragmentFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "has", (Encode.enum Fractal.Enum.NodeFragmentHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeNodeFragmentFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeNodeFragmentFilter |> Encode.optional input____.not ) ]


buildNodeFragmentOrder :
    (NodeFragmentOrderOptionalFields -> NodeFragmentOrderOptionalFields)
    -> NodeFragmentOrder
buildNodeFragmentOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeFragmentOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias NodeFragmentOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type alias for the `NodeFragmentOrder` attributes. Note that this type
needs to use the `NodeFragmentOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeFragmentOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , desc : OptionalArgument Fractal.Enum.NodeFragmentOrderable.NodeFragmentOrderable
    , then_ : OptionalArgument NodeFragmentOrder
    }


{-| Type for the NodeFragmentOrder input object.
-}
type NodeFragmentOrder
    = NodeFragmentOrder NodeFragmentOrderRaw


{-| Encode a NodeFragmentOrder into a value that can be used as an argument.
-}
encodeNodeFragmentOrder : NodeFragmentOrder -> Value
encodeNodeFragmentOrder (NodeFragmentOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.NodeFragmentOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeNodeFragmentOrder |> Encode.optional input____.then_ ) ]


buildNodeFragmentPatch :
    (NodeFragmentPatchOptionalFields -> NodeFragmentPatchOptionalFields)
    -> NodeFragmentPatch
buildNodeFragmentPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, role_ext = Absent, role_type = Absent, color = Absent }
    in
    { nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color }


type alias NodeFragmentPatchOptionalFields =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Type for the NodeFragmentPatch input object.
-}
type alias NodeFragmentPatch =
    { nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Encode a NodeFragmentPatch into a value that can be used as an argument.
-}
encodeNodeFragmentPatch : NodeFragmentPatch -> Value
encodeNodeFragmentPatch input____ =
    Encode.maybeObject
        [ ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "role_ext", Encode.string |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ) ]


buildNodeFragmentRef :
    (NodeFragmentRefOptionalFields -> NodeFragmentRefOptionalFields)
    -> NodeFragmentRef
buildNodeFragmentRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, nameid = Absent, name = Absent, about = Absent, mandate = Absent, skills = Absent, visibility = Absent, mode = Absent, type_ = Absent, first_link = Absent, role_ext = Absent, role_type = Absent, color = Absent }
    in
    { id = optionals____.id, nameid = optionals____.nameid, name = optionals____.name, about = optionals____.about, mandate = optionals____.mandate, skills = optionals____.skills, visibility = optionals____.visibility, mode = optionals____.mode, type_ = optionals____.type_, first_link = optionals____.first_link, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color }


type alias NodeFragmentRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Type for the NodeFragmentRef input object.
-}
type alias NodeFragmentRef =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , skills : OptionalArgument (List String)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , first_link : OptionalArgument String
    , role_ext : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    }


{-| Encode a NodeFragmentRef into a value that can be used as an argument.
-}
encodeNodeFragmentRef : NodeFragmentRef -> Value
encodeNodeFragmentRef input____ =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "first_link", Encode.string |> Encode.optional input____.first_link ), ( "role_ext", Encode.string |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ) ]


buildNodeMode_hash :
    (NodeMode_hashOptionalFields -> NodeMode_hashOptionalFields)
    -> NodeMode_hash
buildNodeMode_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeMode_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Type for the NodeMode\_hash input object.
-}
type alias NodeMode_hash =
    { eq : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeMode.NodeMode))
    }


{-| Encode a NodeMode\_hash into a value that can be used as an argument.
-}
encodeNodeMode_hash : NodeMode_hash -> Value
encodeNodeMode_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeMode.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildNodeOrder :
    (NodeOrderOptionalFields -> NodeOrderOptionalFields)
    -> NodeOrder
buildNodeOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NodeOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias NodeOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type alias for the `NodeOrder` attributes. Note that this type
needs to use the `NodeOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , desc : OptionalArgument Fractal.Enum.NodeOrderable.NodeOrderable
    , then_ : OptionalArgument NodeOrder
    }


{-| Type for the NodeOrder input object.
-}
type NodeOrder
    = NodeOrder NodeOrderRaw


{-| Encode a NodeOrder into a value that can be used as an argument.
-}
encodeNodeOrder : NodeOrder -> Value
encodeNodeOrder (NodeOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.NodeOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeNodeOrder |> Encode.optional input____.then_ ) ]


buildNodePatch :
    (NodePatchOptionalFields -> NodePatchOptionalFields)
    -> NodePatch
buildNodePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, rootnameid = Absent, source = Absent, name = Absent, about = Absent, skills = Absent, isRoot = Absent, parent = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, visibility = Absent, mode = Absent, rights = Absent, isArchived = Absent, isPersonal = Absent, userCanJoin = Absent, guestCanCreateTension = Absent, watchers = Absent, children = Absent, labels = Absent, roles = Absent, projects = Absent, pinned = Absent, role_ext = Absent, role_type = Absent, color = Absent, first_link = Absent, contracts = Absent, events_history = Absent }
    in
    NodePatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, rootnameid = optionals____.rootnameid, source = optionals____.source, name = optionals____.name, about = optionals____.about, skills = optionals____.skills, isRoot = optionals____.isRoot, parent = optionals____.parent, type_ = optionals____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, visibility = optionals____.visibility, mode = optionals____.mode, rights = optionals____.rights, isArchived = optionals____.isArchived, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, guestCanCreateTension = optionals____.guestCanCreateTension, watchers = optionals____.watchers, children = optionals____.children, labels = optionals____.labels, roles = optionals____.roles, projects = optionals____.projects, pinned = optionals____.pinned, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color, first_link = optionals____.first_link, contracts = optionals____.contracts, events_history = optionals____.events_history }


type alias NodePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , source : OptionalArgument BlobRef
    , name : OptionalArgument String
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , isRoot : OptionalArgument Bool
    , parent : OptionalArgument NodeRef
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type alias for the `NodePatch` attributes. Note that this type
needs to use the `NodePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , source : OptionalArgument BlobRef
    , name : OptionalArgument String
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , isRoot : OptionalArgument Bool
    , parent : OptionalArgument NodeRef
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type for the NodePatch input object.
-}
type NodePatch
    = NodePatch NodePatchRaw


{-| Encode a NodePatch into a value that can be used as an argument.
-}
encodeNodePatch : NodePatch -> Value
encodeNodePatch (NodePatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "rights", Encode.int |> Encode.optional input____.rights ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "guestCanCreateTension", Encode.bool |> Encode.optional input____.guestCanCreateTension ), ( "watchers", (encodeUserRef |> Encode.list) |> Encode.optional input____.watchers ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "roles", (encodeRoleExtRef |> Encode.list) |> Encode.optional input____.roles ), ( "projects", (encodeProjectRef |> Encode.list) |> Encode.optional input____.projects ), ( "pinned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.pinned ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "events_history", (encodeEventRef |> Encode.list) |> Encode.optional input____.events_history ) ]


buildNodeRef :
    (NodeRefOptionalFields -> NodeRefOptionalFields)
    -> NodeRef
buildNodeRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, nameid = Absent, rootnameid = Absent, source = Absent, name = Absent, about = Absent, skills = Absent, isRoot = Absent, parent = Absent, type_ = Absent, tensions_out = Absent, tensions_in = Absent, visibility = Absent, mode = Absent, rights = Absent, isArchived = Absent, isPersonal = Absent, userCanJoin = Absent, guestCanCreateTension = Absent, watchers = Absent, children = Absent, labels = Absent, roles = Absent, projects = Absent, pinned = Absent, role_ext = Absent, role_type = Absent, color = Absent, first_link = Absent, contracts = Absent, events_history = Absent }
    in
    NodeRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, nameid = optionals____.nameid, rootnameid = optionals____.rootnameid, source = optionals____.source, name = optionals____.name, about = optionals____.about, skills = optionals____.skills, isRoot = optionals____.isRoot, parent = optionals____.parent, type_ = optionals____.type_, tensions_out = optionals____.tensions_out, tensions_in = optionals____.tensions_in, visibility = optionals____.visibility, mode = optionals____.mode, rights = optionals____.rights, isArchived = optionals____.isArchived, isPersonal = optionals____.isPersonal, userCanJoin = optionals____.userCanJoin, guestCanCreateTension = optionals____.guestCanCreateTension, watchers = optionals____.watchers, children = optionals____.children, labels = optionals____.labels, roles = optionals____.roles, projects = optionals____.projects, pinned = optionals____.pinned, role_ext = optionals____.role_ext, role_type = optionals____.role_type, color = optionals____.color, first_link = optionals____.first_link, contracts = optionals____.contracts, events_history = optionals____.events_history }


type alias NodeRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , source : OptionalArgument BlobRef
    , name : OptionalArgument String
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , isRoot : OptionalArgument Bool
    , parent : OptionalArgument NodeRef
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type alias for the `NodeRef` attributes. Note that this type
needs to use the `NodeRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NodeRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , nameid : OptionalArgument String
    , rootnameid : OptionalArgument String
    , source : OptionalArgument BlobRef
    , name : OptionalArgument String
    , about : OptionalArgument String
    , skills : OptionalArgument (List String)
    , isRoot : OptionalArgument Bool
    , parent : OptionalArgument NodeRef
    , type_ : OptionalArgument Fractal.Enum.NodeType.NodeType
    , tensions_out : OptionalArgument (List TensionRef)
    , tensions_in : OptionalArgument (List TensionRef)
    , visibility : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , mode : OptionalArgument Fractal.Enum.NodeMode.NodeMode
    , rights : OptionalArgument Int
    , isArchived : OptionalArgument Bool
    , isPersonal : OptionalArgument Bool
    , userCanJoin : OptionalArgument Bool
    , guestCanCreateTension : OptionalArgument Bool
    , watchers : OptionalArgument (List UserRef)
    , children : OptionalArgument (List NodeRef)
    , labels : OptionalArgument (List LabelRef)
    , roles : OptionalArgument (List RoleExtRef)
    , projects : OptionalArgument (List ProjectRef)
    , pinned : OptionalArgument (List TensionRef)
    , role_ext : OptionalArgument RoleExtRef
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , first_link : OptionalArgument UserRef
    , contracts : OptionalArgument (List VoteRef)
    , events_history : OptionalArgument (List EventRef)
    }


{-| Type for the NodeRef input object.
-}
type NodeRef
    = NodeRef NodeRefRaw


{-| Encode a NodeRef into a value that can be used as an argument.
-}
encodeNodeRef : NodeRef -> Value
encodeNodeRef (NodeRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "source", encodeBlobRef |> Encode.optional input____.source ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "isRoot", Encode.bool |> Encode.optional input____.isRoot ), ( "parent", encodeNodeRef |> Encode.optional input____.parent ), ( "type_", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.type_ ), ( "tensions_out", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_out ), ( "tensions_in", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_in ), ( "visibility", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.visibility ), ( "mode", Encode.enum Fractal.Enum.NodeMode.toString |> Encode.optional input____.mode ), ( "rights", Encode.int |> Encode.optional input____.rights ), ( "isArchived", Encode.bool |> Encode.optional input____.isArchived ), ( "isPersonal", Encode.bool |> Encode.optional input____.isPersonal ), ( "userCanJoin", Encode.bool |> Encode.optional input____.userCanJoin ), ( "guestCanCreateTension", Encode.bool |> Encode.optional input____.guestCanCreateTension ), ( "watchers", (encodeUserRef |> Encode.list) |> Encode.optional input____.watchers ), ( "children", (encodeNodeRef |> Encode.list) |> Encode.optional input____.children ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "roles", (encodeRoleExtRef |> Encode.list) |> Encode.optional input____.roles ), ( "projects", (encodeProjectRef |> Encode.list) |> Encode.optional input____.projects ), ( "pinned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.pinned ), ( "role_ext", encodeRoleExtRef |> Encode.optional input____.role_ext ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "first_link", encodeUserRef |> Encode.optional input____.first_link ), ( "contracts", (encodeVoteRef |> Encode.list) |> Encode.optional input____.contracts ), ( "events_history", (encodeEventRef |> Encode.list) |> Encode.optional input____.events_history ) ]


buildNodeType_hash :
    (NodeType_hashOptionalFields -> NodeType_hashOptionalFields)
    -> NodeType_hash
buildNodeType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Type for the NodeType\_hash input object.
-}
type alias NodeType_hash =
    { eq : OptionalArgument Fractal.Enum.NodeType.NodeType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeType.NodeType))
    }


{-| Encode a NodeType\_hash into a value that can be used as an argument.
-}
encodeNodeType_hash : NodeType_hash -> Value
encodeNodeType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildNodeVisibility_hash :
    (NodeVisibility_hashOptionalFields -> NodeVisibility_hashOptionalFields)
    -> NodeVisibility_hash
buildNodeVisibility_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias NodeVisibility_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeVisibility.NodeVisibility))
    }


{-| Type for the NodeVisibility\_hash input object.
-}
type alias NodeVisibility_hash =
    { eq : OptionalArgument Fractal.Enum.NodeVisibility.NodeVisibility
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.NodeVisibility.NodeVisibility))
    }


{-| Encode a NodeVisibility\_hash into a value that can be used as an argument.
-}
encodeNodeVisibility_hash : NodeVisibility_hash -> Value
encodeNodeVisibility_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.NodeVisibility.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildNotifFilter :
    (NotifFilterOptionalFields -> NotifFilterOptionalFields)
    -> NotifFilter
buildNotifFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    NotifFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias NotifFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.NotifHasFilter.NotifHasFilter))
    , and : OptionalArgument (List (Maybe NotifFilter))
    , or : OptionalArgument (List (Maybe NotifFilter))
    , not : OptionalArgument NotifFilter
    }


{-| Type alias for the `NotifFilter` attributes. Note that this type
needs to use the `NotifFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NotifFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.NotifHasFilter.NotifHasFilter))
    , and : OptionalArgument (List (Maybe NotifFilter))
    , or : OptionalArgument (List (Maybe NotifFilter))
    , not : OptionalArgument NotifFilter
    }


{-| Type for the NotifFilter input object.
-}
type NotifFilter
    = NotifFilter NotifFilterRaw


{-| Encode a NotifFilter into a value that can be used as an argument.
-}
encodeNotifFilter : NotifFilter -> Value
encodeNotifFilter (NotifFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "has", (Encode.enum Fractal.Enum.NotifHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeNotifFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeNotifFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeNotifFilter |> Encode.optional input____.not ) ]


buildNotifOrder :
    (NotifOrderOptionalFields -> NotifOrderOptionalFields)
    -> NotifOrder
buildNotifOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    NotifOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias NotifOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.NotifOrderable.NotifOrderable
    , desc : OptionalArgument Fractal.Enum.NotifOrderable.NotifOrderable
    , then_ : OptionalArgument NotifOrder
    }


{-| Type alias for the `NotifOrder` attributes. Note that this type
needs to use the `NotifOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NotifOrderRaw =
    { asc : OptionalArgument Fractal.Enum.NotifOrderable.NotifOrderable
    , desc : OptionalArgument Fractal.Enum.NotifOrderable.NotifOrderable
    , then_ : OptionalArgument NotifOrder
    }


{-| Type for the NotifOrder input object.
-}
type NotifOrder
    = NotifOrder NotifOrderRaw


{-| Encode a NotifOrder into a value that can be used as an argument.
-}
encodeNotifOrder : NotifOrder -> Value
encodeNotifOrder (NotifOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.NotifOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.NotifOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeNotifOrder |> Encode.optional input____.then_ ) ]


buildNotifPatch :
    (NotifPatchOptionalFields -> NotifPatchOptionalFields)
    -> NotifPatch
buildNotifPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension_ = Absent, contract = Absent, link = Absent }
    in
    NotifPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension_ = optionals____.tension_, contract = optionals____.contract, link = optionals____.link }


type alias NotifPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type alias for the `NotifPatch` attributes. Note that this type
needs to use the `NotifPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NotifPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type for the NotifPatch input object.
-}
type NotifPatch
    = NotifPatch NotifPatchRaw


{-| Encode a NotifPatch into a value that can be used as an argument.
-}
encodeNotifPatch : NotifPatch -> Value
encodeNotifPatch (NotifPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension_", encodeTensionRef |> Encode.optional input____.tension_ ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "link", Encode.string |> Encode.optional input____.link ) ]


buildNotifRef :
    (NotifRefOptionalFields -> NotifRefOptionalFields)
    -> NotifRef
buildNotifRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, tension_ = Absent, contract = Absent, link = Absent }
    in
    NotifRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, tension_ = optionals____.tension_, contract = optionals____.contract, link = optionals____.link }


type alias NotifRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type alias for the `NotifRef` attributes. Note that this type
needs to use the `NotifRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias NotifRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , tension_ : OptionalArgument TensionRef
    , contract : OptionalArgument ContractRef
    , link : OptionalArgument String
    }


{-| Type for the NotifRef input object.
-}
type NotifRef
    = NotifRef NotifRefRaw


{-| Encode a NotifRef into a value that can be used as an argument.
-}
encodeNotifRef : NotifRef -> Value
encodeNotifRef (NotifRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "tension_", encodeTensionRef |> Encode.optional input____.tension_ ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "link", Encode.string |> Encode.optional input____.link ) ]


buildPendingUserFilter :
    (PendingUserFilterOptionalFields -> PendingUserFilterOptionalFields)
    -> PendingUserFilter
buildPendingUserFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, username = Absent, email = Absent, email_token = Absent, token = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    PendingUserFilter { id = optionals____.id, username = optionals____.username, email = optionals____.email, email_token = optionals____.email_token, token = optionals____.token, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias PendingUserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , email_token : OptionalArgument StringHashFilter
    , token : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PendingUserHasFilter.PendingUserHasFilter))
    , and : OptionalArgument (List (Maybe PendingUserFilter))
    , or : OptionalArgument (List (Maybe PendingUserFilter))
    , not : OptionalArgument PendingUserFilter
    }


{-| Type alias for the `PendingUserFilter` attributes. Note that this type
needs to use the `PendingUserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter
    , email : OptionalArgument StringHashFilter
    , email_token : OptionalArgument StringHashFilter
    , token : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PendingUserHasFilter.PendingUserHasFilter))
    , and : OptionalArgument (List (Maybe PendingUserFilter))
    , or : OptionalArgument (List (Maybe PendingUserFilter))
    , not : OptionalArgument PendingUserFilter
    }


{-| Type for the PendingUserFilter input object.
-}
type PendingUserFilter
    = PendingUserFilter PendingUserFilterRaw


{-| Encode a PendingUserFilter into a value that can be used as an argument.
-}
encodePendingUserFilter : PendingUserFilter -> Value
encodePendingUserFilter (PendingUserFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "username", encodeStringHashFilter |> Encode.optional input____.username ), ( "email", encodeStringHashFilter |> Encode.optional input____.email ), ( "email_token", encodeStringHashFilter |> Encode.optional input____.email_token ), ( "token", encodeStringHashFilter |> Encode.optional input____.token ), ( "has", (Encode.enum Fractal.Enum.PendingUserHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodePendingUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodePendingUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodePendingUserFilter |> Encode.optional input____.not ) ]


buildPendingUserOrder :
    (PendingUserOrderOptionalFields -> PendingUserOrderOptionalFields)
    -> PendingUserOrder
buildPendingUserOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PendingUserOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias PendingUserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , desc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , then_ : OptionalArgument PendingUserOrder
    }


{-| Type alias for the `PendingUserOrder` attributes. Note that this type
needs to use the `PendingUserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , desc : OptionalArgument Fractal.Enum.PendingUserOrderable.PendingUserOrderable
    , then_ : OptionalArgument PendingUserOrder
    }


{-| Type for the PendingUserOrder input object.
-}
type PendingUserOrder
    = PendingUserOrder PendingUserOrderRaw


{-| Encode a PendingUserOrder into a value that can be used as an argument.
-}
encodePendingUserOrder : PendingUserOrder -> Value
encodePendingUserOrder (PendingUserOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PendingUserOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.PendingUserOrderable.toString |> Encode.optional input____.desc ), ( "then", encodePendingUserOrder |> Encode.optional input____.then_ ) ]


buildPendingUserPatch :
    (PendingUserPatchOptionalFields -> PendingUserPatchOptionalFields)
    -> PendingUserPatch
buildPendingUserPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { updatedAt = Absent, password = Absent, email_token = Absent, token = Absent, contracts = Absent, subscribe = Absent }
    in
    PendingUserPatch { updatedAt = optionals____.updatedAt, password = optionals____.password, email_token = optionals____.email_token, token = optionals____.token, contracts = optionals____.contracts, subscribe = optionals____.subscribe }


type alias PendingUserPatchOptionalFields =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , password : OptionalArgument String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type alias for the `PendingUserPatch` attributes. Note that this type
needs to use the `PendingUserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserPatchRaw =
    { updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , password : OptionalArgument String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type for the PendingUserPatch input object.
-}
type PendingUserPatch
    = PendingUserPatch PendingUserPatchRaw


{-| Encode a PendingUserPatch into a value that can be used as an argument.
-}
encodePendingUserPatch : PendingUserPatch -> Value
encodePendingUserPatch (PendingUserPatch input____) =
    Encode.maybeObject
        [ ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "password", Encode.string |> Encode.optional input____.password ), ( "email_token", Encode.string |> Encode.optional input____.email_token ), ( "token", Encode.string |> Encode.optional input____.token ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribe", Encode.bool |> Encode.optional input____.subscribe ) ]


buildPendingUserRef :
    (PendingUserRefOptionalFields -> PendingUserRefOptionalFields)
    -> PendingUserRef
buildPendingUserRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, updatedAt = Absent, username = Absent, password = Absent, email = Absent, email_token = Absent, token = Absent, contracts = Absent, subscribe = Absent }
    in
    PendingUserRef { id = optionals____.id, updatedAt = optionals____.updatedAt, username = optionals____.username, password = optionals____.password, email = optionals____.email, email_token = optionals____.email_token, token = optionals____.token, contracts = optionals____.contracts, subscribe = optionals____.subscribe }


type alias PendingUserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type alias for the `PendingUserRef` attributes. Note that this type
needs to use the `PendingUserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PendingUserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , password : OptionalArgument String
    , email : OptionalArgument String
    , email_token : OptionalArgument String
    , token : OptionalArgument String
    , contracts : OptionalArgument (List ContractRef)
    , subscribe : OptionalArgument Bool
    }


{-| Type for the PendingUserRef input object.
-}
type PendingUserRef
    = PendingUserRef PendingUserRefRaw


{-| Encode a PendingUserRef into a value that can be used as an argument.
-}
encodePendingUserRef : PendingUserRef -> Value
encodePendingUserRef (PendingUserRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "username", Encode.string |> Encode.optional input____.username ), ( "password", Encode.string |> Encode.optional input____.password ), ( "email", Encode.string |> Encode.optional input____.email ), ( "email_token", Encode.string |> Encode.optional input____.email_token ), ( "token", Encode.string |> Encode.optional input____.token ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribe", Encode.bool |> Encode.optional input____.subscribe ) ]


buildPointGeoFilter :
    (PointGeoFilterOptionalFields -> PointGeoFilterOptionalFields)
    -> PointGeoFilter
buildPointGeoFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { near = Absent, within = Absent }
    in
    { near = optionals____.near, within = optionals____.within }


type alias PointGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Type for the PointGeoFilter input object.
-}
type alias PointGeoFilter =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    }


{-| Encode a PointGeoFilter into a value that can be used as an argument.
-}
encodePointGeoFilter : PointGeoFilter -> Value
encodePointGeoFilter input____ =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input____.near ), ( "within", encodeWithinFilter |> Encode.optional input____.within ) ]


buildPointListRef :
    PointListRefRequiredFields
    -> PointListRef
buildPointListRef required____ =
    { points = required____.points }


type alias PointListRefRequiredFields =
    { points : List PointRef }


{-| Type for the PointListRef input object.
-}
type alias PointListRef =
    { points : List PointRef }


{-| Encode a PointListRef into a value that can be used as an argument.
-}
encodePointListRef : PointListRef -> Value
encodePointListRef input____ =
    Encode.maybeObject
        [ ( "points", (encodePointRef |> Encode.list) input____.points |> Just ) ]


buildPointRef :
    PointRefRequiredFields
    -> PointRef
buildPointRef required____ =
    { longitude = required____.longitude, latitude = required____.latitude }


type alias PointRefRequiredFields =
    { longitude : Float
    , latitude : Float
    }


{-| Type for the PointRef input object.
-}
type alias PointRef =
    { longitude : Float
    , latitude : Float
    }


{-| Encode a PointRef into a value that can be used as an argument.
-}
encodePointRef : PointRef -> Value
encodePointRef input____ =
    Encode.maybeObject
        [ ( "longitude", Encode.float input____.longitude |> Just ), ( "latitude", Encode.float input____.latitude |> Just ) ]


buildPolygonGeoFilter :
    (PolygonGeoFilterOptionalFields -> PolygonGeoFilterOptionalFields)
    -> PolygonGeoFilter
buildPolygonGeoFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { near = Absent, within = Absent, contains = Absent, intersects = Absent }
    in
    { near = optionals____.near, within = optionals____.within, contains = optionals____.contains, intersects = optionals____.intersects }


type alias PolygonGeoFilterOptionalFields =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Type for the PolygonGeoFilter input object.
-}
type alias PolygonGeoFilter =
    { near : OptionalArgument NearFilter
    , within : OptionalArgument WithinFilter
    , contains : OptionalArgument ContainsFilter
    , intersects : OptionalArgument IntersectsFilter
    }


{-| Encode a PolygonGeoFilter into a value that can be used as an argument.
-}
encodePolygonGeoFilter : PolygonGeoFilter -> Value
encodePolygonGeoFilter input____ =
    Encode.maybeObject
        [ ( "near", encodeNearFilter |> Encode.optional input____.near ), ( "within", encodeWithinFilter |> Encode.optional input____.within ), ( "contains", encodeContainsFilter |> Encode.optional input____.contains ), ( "intersects", encodeIntersectsFilter |> Encode.optional input____.intersects ) ]


buildPolygonRef :
    PolygonRefRequiredFields
    -> PolygonRef
buildPolygonRef required____ =
    { coordinates = required____.coordinates }


type alias PolygonRefRequiredFields =
    { coordinates : List PointListRef }


{-| Type for the PolygonRef input object.
-}
type alias PolygonRef =
    { coordinates : List PointListRef }


{-| Encode a PolygonRef into a value that can be used as an argument.
-}
encodePolygonRef : PolygonRef -> Value
encodePolygonRef input____ =
    Encode.maybeObject
        [ ( "coordinates", (encodePointListRef |> Encode.list) input____.coordinates |> Just ) ]


buildPostFilter :
    (PostFilterOptionalFields -> PostFilterOptionalFields)
    -> PostFilter
buildPostFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    PostFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias PostFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type alias for the `PostFilter` attributes. Note that this type
needs to use the `PostFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.PostHasFilter.PostHasFilter))
    , and : OptionalArgument (List (Maybe PostFilter))
    , or : OptionalArgument (List (Maybe PostFilter))
    , not : OptionalArgument PostFilter
    }


{-| Type for the PostFilter input object.
-}
type PostFilter
    = PostFilter PostFilterRaw


{-| Encode a PostFilter into a value that can be used as an argument.
-}
encodePostFilter : PostFilter -> Value
encodePostFilter (PostFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "has", (Encode.enum Fractal.Enum.PostHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodePostFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodePostFilter |> Encode.optional input____.not ) ]


buildPostOrder :
    (PostOrderOptionalFields -> PostOrderOptionalFields)
    -> PostOrder
buildPostOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    PostOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias PostOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type alias for the `PostOrder` attributes. Note that this type
needs to use the `PostOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostOrderRaw =
    { asc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , desc : OptionalArgument Fractal.Enum.PostOrderable.PostOrderable
    , then_ : OptionalArgument PostOrder
    }


{-| Type for the PostOrder input object.
-}
type PostOrder
    = PostOrder PostOrderRaw


{-| Encode a PostOrder into a value that can be used as an argument.
-}
encodePostOrder : PostOrder -> Value
encodePostOrder (PostOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.PostOrderable.toString |> Encode.optional input____.desc ), ( "then", encodePostOrder |> Encode.optional input____.then_ ) ]


buildPostPatch :
    (PostPatchOptionalFields -> PostPatchOptionalFields)
    -> PostPatch
buildPostPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent }
    in
    PostPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message }


type alias PostPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type alias for the `PostPatch` attributes. Note that this type
needs to use the `PostPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias PostPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    }


{-| Type for the PostPatch input object.
-}
type PostPatch
    = PostPatch PostPatchRaw


{-| Encode a PostPatch into a value that can be used as an argument.
-}
encodePostPatch : PostPatch -> Value
encodePostPatch (PostPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ) ]


buildPostRef :
    PostRefRequiredFields
    -> PostRef
buildPostRef required____ =
    { id = required____.id }


type alias PostRefRequiredFields =
    { id : Fractal.ScalarCodecs.Id }


{-| Type for the PostRef input object.
-}
type alias PostRef =
    { id : Fractal.ScalarCodecs.Id }


{-| Encode a PostRef into a value that can be used as an argument.
-}
encodePostRef : PostRef -> Value
encodePostRef input____ =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) input____.id |> Just ) ]


buildProjectColumnFilter :
    (ProjectColumnFilterOptionalFields -> ProjectColumnFilterOptionalFields)
    -> ProjectColumnFilter
buildProjectColumnFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ProjectColumnFilter { id = optionals____.id, name = optionals____.name, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ProjectColumnFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectColumnHasFilter.ProjectColumnHasFilter))
    , and : OptionalArgument (List (Maybe ProjectColumnFilter))
    , or : OptionalArgument (List (Maybe ProjectColumnFilter))
    , not : OptionalArgument ProjectColumnFilter
    }


{-| Type alias for the `ProjectColumnFilter` attributes. Note that this type
needs to use the `ProjectColumnFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectColumnFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , name : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectColumnHasFilter.ProjectColumnHasFilter))
    , and : OptionalArgument (List (Maybe ProjectColumnFilter))
    , or : OptionalArgument (List (Maybe ProjectColumnFilter))
    , not : OptionalArgument ProjectColumnFilter
    }


{-| Type for the ProjectColumnFilter input object.
-}
type ProjectColumnFilter
    = ProjectColumnFilter ProjectColumnFilterRaw


{-| Encode a ProjectColumnFilter into a value that can be used as an argument.
-}
encodeProjectColumnFilter : ProjectColumnFilter -> Value
encodeProjectColumnFilter (ProjectColumnFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "name", encodeStringHashFilter |> Encode.optional input____.name ), ( "has", (Encode.enum Fractal.Enum.ProjectColumnHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeProjectColumnFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeProjectColumnFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeProjectColumnFilter |> Encode.optional input____.not ) ]


buildProjectColumnOrder :
    (ProjectColumnOrderOptionalFields -> ProjectColumnOrderOptionalFields)
    -> ProjectColumnOrder
buildProjectColumnOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ProjectColumnOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ProjectColumnOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ProjectColumnOrderable.ProjectColumnOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectColumnOrderable.ProjectColumnOrderable
    , then_ : OptionalArgument ProjectColumnOrder
    }


{-| Type alias for the `ProjectColumnOrder` attributes. Note that this type
needs to use the `ProjectColumnOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectColumnOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ProjectColumnOrderable.ProjectColumnOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectColumnOrderable.ProjectColumnOrderable
    , then_ : OptionalArgument ProjectColumnOrder
    }


{-| Type for the ProjectColumnOrder input object.
-}
type ProjectColumnOrder
    = ProjectColumnOrder ProjectColumnOrderRaw


{-| Encode a ProjectColumnOrder into a value that can be used as an argument.
-}
encodeProjectColumnOrder : ProjectColumnOrder -> Value
encodeProjectColumnOrder (ProjectColumnOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ProjectColumnOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ProjectColumnOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeProjectColumnOrder |> Encode.optional input____.then_ ) ]


buildProjectColumnPatch :
    (ProjectColumnPatchOptionalFields -> ProjectColumnPatchOptionalFields)
    -> ProjectColumnPatch
buildProjectColumnPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { about = Absent, pos = Absent, tensions = Absent, project = Absent }
    in
    ProjectColumnPatch { about = optionals____.about, pos = optionals____.pos, tensions = optionals____.tensions, project = optionals____.project }


type alias ProjectColumnPatchOptionalFields =
    { about : OptionalArgument String
    , pos : OptionalArgument Int
    , tensions : OptionalArgument (List ProjectTensionRef)
    , project : OptionalArgument ProjectRef
    }


{-| Type alias for the `ProjectColumnPatch` attributes. Note that this type
needs to use the `ProjectColumnPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectColumnPatchRaw =
    { about : OptionalArgument String
    , pos : OptionalArgument Int
    , tensions : OptionalArgument (List ProjectTensionRef)
    , project : OptionalArgument ProjectRef
    }


{-| Type for the ProjectColumnPatch input object.
-}
type ProjectColumnPatch
    = ProjectColumnPatch ProjectColumnPatchRaw


{-| Encode a ProjectColumnPatch into a value that can be used as an argument.
-}
encodeProjectColumnPatch : ProjectColumnPatch -> Value
encodeProjectColumnPatch (ProjectColumnPatch input____) =
    Encode.maybeObject
        [ ( "about", Encode.string |> Encode.optional input____.about ), ( "pos", Encode.int |> Encode.optional input____.pos ), ( "tensions", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "project", encodeProjectRef |> Encode.optional input____.project ) ]


buildProjectColumnRef :
    (ProjectColumnRefOptionalFields -> ProjectColumnRefOptionalFields)
    -> ProjectColumnRef
buildProjectColumnRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, name = Absent, about = Absent, pos = Absent, tensions = Absent, project = Absent }
    in
    ProjectColumnRef { id = optionals____.id, name = optionals____.name, about = optionals____.about, pos = optionals____.pos, tensions = optionals____.tensions, project = optionals____.project }


type alias ProjectColumnRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , about : OptionalArgument String
    , pos : OptionalArgument Int
    , tensions : OptionalArgument (List ProjectTensionRef)
    , project : OptionalArgument ProjectRef
    }


{-| Type alias for the `ProjectColumnRef` attributes. Note that this type
needs to use the `ProjectColumnRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectColumnRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , name : OptionalArgument String
    , about : OptionalArgument String
    , pos : OptionalArgument Int
    , tensions : OptionalArgument (List ProjectTensionRef)
    , project : OptionalArgument ProjectRef
    }


{-| Type for the ProjectColumnRef input object.
-}
type ProjectColumnRef
    = ProjectColumnRef ProjectColumnRefRaw


{-| Encode a ProjectColumnRef into a value that can be used as an argument.
-}
encodeProjectColumnRef : ProjectColumnRef -> Value
encodeProjectColumnRef (ProjectColumnRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "pos", Encode.int |> Encode.optional input____.pos ), ( "tensions", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.tensions ), ( "project", encodeProjectRef |> Encode.optional input____.project ) ]


buildProjectFieldFilter :
    (ProjectFieldFilterOptionalFields -> ProjectFieldFilterOptionalFields)
    -> ProjectFieldFilter
buildProjectFieldFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ProjectFieldFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ProjectFieldFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.ProjectFieldHasFilter.ProjectFieldHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFieldFilter))
    , or : OptionalArgument (List (Maybe ProjectFieldFilter))
    , not : OptionalArgument ProjectFieldFilter
    }


{-| Type alias for the `ProjectFieldFilter` attributes. Note that this type
needs to use the `ProjectFieldFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.ProjectFieldHasFilter.ProjectFieldHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFieldFilter))
    , or : OptionalArgument (List (Maybe ProjectFieldFilter))
    , not : OptionalArgument ProjectFieldFilter
    }


{-| Type for the ProjectFieldFilter input object.
-}
type ProjectFieldFilter
    = ProjectFieldFilter ProjectFieldFilterRaw


{-| Encode a ProjectFieldFilter into a value that can be used as an argument.
-}
encodeProjectFieldFilter : ProjectFieldFilter -> Value
encodeProjectFieldFilter (ProjectFieldFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.ProjectFieldHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeProjectFieldFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeProjectFieldFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeProjectFieldFilter |> Encode.optional input____.not ) ]


buildProjectFieldPatch :
    (ProjectFieldPatchOptionalFields -> ProjectFieldPatchOptionalFields)
    -> ProjectFieldPatch
buildProjectFieldPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { type_ = Absent, isVisible = Absent, values = Absent }
    in
    ProjectFieldPatch { type_ = optionals____.type_, isVisible = optionals____.isVisible, values = optionals____.values }


type alias ProjectFieldPatchOptionalFields =
    { type_ : OptionalArgument Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : OptionalArgument Bool
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type alias for the `ProjectFieldPatch` attributes. Note that this type
needs to use the `ProjectFieldPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldPatchRaw =
    { type_ : OptionalArgument Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : OptionalArgument Bool
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the ProjectFieldPatch input object.
-}
type ProjectFieldPatch
    = ProjectFieldPatch ProjectFieldPatchRaw


{-| Encode a ProjectFieldPatch into a value that can be used as an argument.
-}
encodeProjectFieldPatch : ProjectFieldPatch -> Value
encodeProjectFieldPatch (ProjectFieldPatch input____) =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.ProjectFieldType.toString |> Encode.optional input____.type_ ), ( "isVisible", Encode.bool |> Encode.optional input____.isVisible ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildProjectFieldRef :
    (ProjectFieldRefOptionalFields -> ProjectFieldRefOptionalFields)
    -> ProjectFieldRef
buildProjectFieldRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { type_ = Absent, isVisible = Absent, values = Absent }
    in
    ProjectFieldRef { type_ = optionals____.type_, isVisible = optionals____.isVisible, values = optionals____.values }


type alias ProjectFieldRefOptionalFields =
    { type_ : OptionalArgument Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : OptionalArgument Bool
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type alias for the `ProjectFieldRef` attributes. Note that this type
needs to use the `ProjectFieldRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldRefRaw =
    { type_ : OptionalArgument Fractal.Enum.ProjectFieldType.ProjectFieldType
    , isVisible : OptionalArgument Bool
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the ProjectFieldRef input object.
-}
type ProjectFieldRef
    = ProjectFieldRef ProjectFieldRefRaw


{-| Encode a ProjectFieldRef into a value that can be used as an argument.
-}
encodeProjectFieldRef : ProjectFieldRef -> Value
encodeProjectFieldRef (ProjectFieldRef input____) =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.ProjectFieldType.toString |> Encode.optional input____.type_ ), ( "isVisible", Encode.bool |> Encode.optional input____.isVisible ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildProjectFieldValueFilter :
    (ProjectFieldValueFilterOptionalFields -> ProjectFieldValueFilterOptionalFields)
    -> ProjectFieldValueFilter
buildProjectFieldValueFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ProjectFieldValueFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ProjectFieldValueFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.ProjectFieldValueHasFilter.ProjectFieldValueHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFieldValueFilter))
    , or : OptionalArgument (List (Maybe ProjectFieldValueFilter))
    , not : OptionalArgument ProjectFieldValueFilter
    }


{-| Type alias for the `ProjectFieldValueFilter` attributes. Note that this type
needs to use the `ProjectFieldValueFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldValueFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.ProjectFieldValueHasFilter.ProjectFieldValueHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFieldValueFilter))
    , or : OptionalArgument (List (Maybe ProjectFieldValueFilter))
    , not : OptionalArgument ProjectFieldValueFilter
    }


{-| Type for the ProjectFieldValueFilter input object.
-}
type ProjectFieldValueFilter
    = ProjectFieldValueFilter ProjectFieldValueFilterRaw


{-| Encode a ProjectFieldValueFilter into a value that can be used as an argument.
-}
encodeProjectFieldValueFilter : ProjectFieldValueFilter -> Value
encodeProjectFieldValueFilter (ProjectFieldValueFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.ProjectFieldValueHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeProjectFieldValueFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeProjectFieldValueFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeProjectFieldValueFilter |> Encode.optional input____.not ) ]


buildProjectFieldValueOrder :
    (ProjectFieldValueOrderOptionalFields -> ProjectFieldValueOrderOptionalFields)
    -> ProjectFieldValueOrder
buildProjectFieldValueOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ProjectFieldValueOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ProjectFieldValueOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ProjectFieldValueOrderable.ProjectFieldValueOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectFieldValueOrderable.ProjectFieldValueOrderable
    , then_ : OptionalArgument ProjectFieldValueOrder
    }


{-| Type alias for the `ProjectFieldValueOrder` attributes. Note that this type
needs to use the `ProjectFieldValueOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldValueOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ProjectFieldValueOrderable.ProjectFieldValueOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectFieldValueOrderable.ProjectFieldValueOrderable
    , then_ : OptionalArgument ProjectFieldValueOrder
    }


{-| Type for the ProjectFieldValueOrder input object.
-}
type ProjectFieldValueOrder
    = ProjectFieldValueOrder ProjectFieldValueOrderRaw


{-| Encode a ProjectFieldValueOrder into a value that can be used as an argument.
-}
encodeProjectFieldValueOrder : ProjectFieldValueOrder -> Value
encodeProjectFieldValueOrder (ProjectFieldValueOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ProjectFieldValueOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ProjectFieldValueOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeProjectFieldValueOrder |> Encode.optional input____.then_ ) ]


buildProjectFieldValuePatch :
    (ProjectFieldValuePatchOptionalFields -> ProjectFieldValuePatchOptionalFields)
    -> ProjectFieldValuePatch
buildProjectFieldValuePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { field = Absent, value = Absent }
    in
    ProjectFieldValuePatch { field = optionals____.field, value = optionals____.value }


type alias ProjectFieldValuePatchOptionalFields =
    { field : OptionalArgument ProjectFieldRef
    , value : OptionalArgument String
    }


{-| Type alias for the `ProjectFieldValuePatch` attributes. Note that this type
needs to use the `ProjectFieldValuePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldValuePatchRaw =
    { field : OptionalArgument ProjectFieldRef
    , value : OptionalArgument String
    }


{-| Type for the ProjectFieldValuePatch input object.
-}
type ProjectFieldValuePatch
    = ProjectFieldValuePatch ProjectFieldValuePatchRaw


{-| Encode a ProjectFieldValuePatch into a value that can be used as an argument.
-}
encodeProjectFieldValuePatch : ProjectFieldValuePatch -> Value
encodeProjectFieldValuePatch (ProjectFieldValuePatch input____) =
    Encode.maybeObject
        [ ( "field", encodeProjectFieldRef |> Encode.optional input____.field ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildProjectFieldValueRef :
    (ProjectFieldValueRefOptionalFields -> ProjectFieldValueRefOptionalFields)
    -> ProjectFieldValueRef
buildProjectFieldValueRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { field = Absent, value = Absent }
    in
    ProjectFieldValueRef { field = optionals____.field, value = optionals____.value }


type alias ProjectFieldValueRefOptionalFields =
    { field : OptionalArgument ProjectFieldRef
    , value : OptionalArgument String
    }


{-| Type alias for the `ProjectFieldValueRef` attributes. Note that this type
needs to use the `ProjectFieldValueRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFieldValueRefRaw =
    { field : OptionalArgument ProjectFieldRef
    , value : OptionalArgument String
    }


{-| Type for the ProjectFieldValueRef input object.
-}
type ProjectFieldValueRef
    = ProjectFieldValueRef ProjectFieldValueRefRaw


{-| Encode a ProjectFieldValueRef into a value that can be used as an argument.
-}
encodeProjectFieldValueRef : ProjectFieldValueRef -> Value
encodeProjectFieldValueRef (ProjectFieldValueRef input____) =
    Encode.maybeObject
        [ ( "field", encodeProjectFieldRef |> Encode.optional input____.field ), ( "value", Encode.string |> Encode.optional input____.value ) ]


buildProjectFilter :
    (ProjectFilterOptionalFields -> ProjectFilterOptionalFields)
    -> ProjectFilter
buildProjectFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, rootnameid = Absent, parentnameid = Absent, nameid = Absent, name = Absent, status = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ProjectFilter { id = optionals____.id, createdAt = optionals____.createdAt, rootnameid = optionals____.rootnameid, parentnameid = optionals____.parentnameid, nameid = optionals____.nameid, name = optionals____.name, status = optionals____.status, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ProjectFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , rootnameid : OptionalArgument StringHashFilter
    , parentnameid : OptionalArgument StringHashFilter
    , nameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringFullTextFilter
    , status : OptionalArgument ProjectStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectHasFilter.ProjectHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFilter))
    , or : OptionalArgument (List (Maybe ProjectFilter))
    , not : OptionalArgument ProjectFilter
    }


{-| Type alias for the `ProjectFilter` attributes. Note that this type
needs to use the `ProjectFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , rootnameid : OptionalArgument StringHashFilter
    , parentnameid : OptionalArgument StringHashFilter
    , nameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringFullTextFilter
    , status : OptionalArgument ProjectStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectHasFilter.ProjectHasFilter))
    , and : OptionalArgument (List (Maybe ProjectFilter))
    , or : OptionalArgument (List (Maybe ProjectFilter))
    , not : OptionalArgument ProjectFilter
    }


{-| Type for the ProjectFilter input object.
-}
type ProjectFilter
    = ProjectFilter ProjectFilterRaw


{-| Encode a ProjectFilter into a value that can be used as an argument.
-}
encodeProjectFilter : ProjectFilter -> Value
encodeProjectFilter (ProjectFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input____.rootnameid ), ( "parentnameid", encodeStringHashFilter |> Encode.optional input____.parentnameid ), ( "nameid", encodeStringHashFilter |> Encode.optional input____.nameid ), ( "name", encodeStringFullTextFilter |> Encode.optional input____.name ), ( "status", encodeProjectStatus_hash |> Encode.optional input____.status ), ( "has", (Encode.enum Fractal.Enum.ProjectHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeProjectFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeProjectFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeProjectFilter |> Encode.optional input____.not ) ]


buildProjectOrder :
    (ProjectOrderOptionalFields -> ProjectOrderOptionalFields)
    -> ProjectOrder
buildProjectOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ProjectOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ProjectOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ProjectOrderable.ProjectOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectOrderable.ProjectOrderable
    , then_ : OptionalArgument ProjectOrder
    }


{-| Type alias for the `ProjectOrder` attributes. Note that this type
needs to use the `ProjectOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ProjectOrderable.ProjectOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectOrderable.ProjectOrderable
    , then_ : OptionalArgument ProjectOrder
    }


{-| Type for the ProjectOrder input object.
-}
type ProjectOrder
    = ProjectOrder ProjectOrderRaw


{-| Encode a ProjectOrder into a value that can be used as an argument.
-}
encodeProjectOrder : ProjectOrder -> Value
encodeProjectOrder (ProjectOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ProjectOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ProjectOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeProjectOrder |> Encode.optional input____.then_ ) ]


buildProjectPatch :
    (ProjectPatchOptionalFields -> ProjectPatchOptionalFields)
    -> ProjectPatch
buildProjectPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, rootnameid = Absent, parentnameid = Absent, nameid = Absent, name = Absent, description = Absent, status = Absent, columns = Absent, fields = Absent, leaders = Absent, nodes = Absent }
    in
    ProjectPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, rootnameid = optionals____.rootnameid, parentnameid = optionals____.parentnameid, nameid = optionals____.nameid, name = optionals____.name, description = optionals____.description, status = optionals____.status, columns = optionals____.columns, fields = optionals____.fields, leaders = optionals____.leaders, nodes = optionals____.nodes }


type alias ProjectPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , parentnameid : OptionalArgument String
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , status : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `ProjectPatch` attributes. Note that this type
needs to use the `ProjectPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , parentnameid : OptionalArgument String
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , status : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the ProjectPatch input object.
-}
type ProjectPatch
    = ProjectPatch ProjectPatchRaw


{-| Encode a ProjectPatch into a value that can be used as an argument.
-}
encodeProjectPatch : ProjectPatch -> Value
encodeProjectPatch (ProjectPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "parentnameid", Encode.string |> Encode.optional input____.parentnameid ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "status", Encode.enum Fractal.Enum.ProjectStatus.toString |> Encode.optional input____.status ), ( "columns", (encodeProjectColumnRef |> Encode.list) |> Encode.optional input____.columns ), ( "fields", (encodeProjectFieldRef |> Encode.list) |> Encode.optional input____.fields ), ( "leaders", (encodeNodeRef |> Encode.list) |> Encode.optional input____.leaders ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildProjectRef :
    (ProjectRefOptionalFields -> ProjectRefOptionalFields)
    -> ProjectRef
buildProjectRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, rootnameid = Absent, parentnameid = Absent, nameid = Absent, name = Absent, description = Absent, status = Absent, columns = Absent, fields = Absent, leaders = Absent, nodes = Absent }
    in
    ProjectRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, rootnameid = optionals____.rootnameid, parentnameid = optionals____.parentnameid, nameid = optionals____.nameid, name = optionals____.name, description = optionals____.description, status = optionals____.status, columns = optionals____.columns, fields = optionals____.fields, leaders = optionals____.leaders, nodes = optionals____.nodes }


type alias ProjectRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , parentnameid : OptionalArgument String
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , status : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `ProjectRef` attributes. Note that this type
needs to use the `ProjectRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , rootnameid : OptionalArgument String
    , parentnameid : OptionalArgument String
    , nameid : OptionalArgument String
    , name : OptionalArgument String
    , description : OptionalArgument String
    , status : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , columns : OptionalArgument (List ProjectColumnRef)
    , fields : OptionalArgument (List ProjectFieldRef)
    , leaders : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the ProjectRef input object.
-}
type ProjectRef
    = ProjectRef ProjectRefRaw


{-| Encode a ProjectRef into a value that can be used as an argument.
-}
encodeProjectRef : ProjectRef -> Value
encodeProjectRef (ProjectRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "parentnameid", Encode.string |> Encode.optional input____.parentnameid ), ( "nameid", Encode.string |> Encode.optional input____.nameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "description", Encode.string |> Encode.optional input____.description ), ( "status", Encode.enum Fractal.Enum.ProjectStatus.toString |> Encode.optional input____.status ), ( "columns", (encodeProjectColumnRef |> Encode.list) |> Encode.optional input____.columns ), ( "fields", (encodeProjectFieldRef |> Encode.list) |> Encode.optional input____.fields ), ( "leaders", (encodeNodeRef |> Encode.list) |> Encode.optional input____.leaders ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildProjectStatus_hash :
    (ProjectStatus_hashOptionalFields -> ProjectStatus_hashOptionalFields)
    -> ProjectStatus_hash
buildProjectStatus_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias ProjectStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ProjectStatus.ProjectStatus))
    }


{-| Type for the ProjectStatus\_hash input object.
-}
type alias ProjectStatus_hash =
    { eq : OptionalArgument Fractal.Enum.ProjectStatus.ProjectStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.ProjectStatus.ProjectStatus))
    }


{-| Encode a ProjectStatus\_hash into a value that can be used as an argument.
-}
encodeProjectStatus_hash : ProjectStatus_hash -> Value
encodeProjectStatus_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.ProjectStatus.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.ProjectStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildProjectTensionFilter :
    (ProjectTensionFilterOptionalFields -> ProjectTensionFilterOptionalFields)
    -> ProjectTensionFilter
buildProjectTensionFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ProjectTensionFilter { id = optionals____.id, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ProjectTensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectTensionHasFilter.ProjectTensionHasFilter))
    , and : OptionalArgument (List (Maybe ProjectTensionFilter))
    , or : OptionalArgument (List (Maybe ProjectTensionFilter))
    , not : OptionalArgument ProjectTensionFilter
    }


{-| Type alias for the `ProjectTensionFilter` attributes. Note that this type
needs to use the `ProjectTensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectTensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , has : OptionalArgument (List (Maybe Fractal.Enum.ProjectTensionHasFilter.ProjectTensionHasFilter))
    , and : OptionalArgument (List (Maybe ProjectTensionFilter))
    , or : OptionalArgument (List (Maybe ProjectTensionFilter))
    , not : OptionalArgument ProjectTensionFilter
    }


{-| Type for the ProjectTensionFilter input object.
-}
type ProjectTensionFilter
    = ProjectTensionFilter ProjectTensionFilterRaw


{-| Encode a ProjectTensionFilter into a value that can be used as an argument.
-}
encodeProjectTensionFilter : ProjectTensionFilter -> Value
encodeProjectTensionFilter (ProjectTensionFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "has", (Encode.enum Fractal.Enum.ProjectTensionHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeProjectTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeProjectTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeProjectTensionFilter |> Encode.optional input____.not ) ]


buildProjectTensionOrder :
    (ProjectTensionOrderOptionalFields -> ProjectTensionOrderOptionalFields)
    -> ProjectTensionOrder
buildProjectTensionOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ProjectTensionOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ProjectTensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ProjectTensionOrderable.ProjectTensionOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectTensionOrderable.ProjectTensionOrderable
    , then_ : OptionalArgument ProjectTensionOrder
    }


{-| Type alias for the `ProjectTensionOrder` attributes. Note that this type
needs to use the `ProjectTensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectTensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ProjectTensionOrderable.ProjectTensionOrderable
    , desc : OptionalArgument Fractal.Enum.ProjectTensionOrderable.ProjectTensionOrderable
    , then_ : OptionalArgument ProjectTensionOrder
    }


{-| Type for the ProjectTensionOrder input object.
-}
type ProjectTensionOrder
    = ProjectTensionOrder ProjectTensionOrderRaw


{-| Encode a ProjectTensionOrder into a value that can be used as an argument.
-}
encodeProjectTensionOrder : ProjectTensionOrder -> Value
encodeProjectTensionOrder (ProjectTensionOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ProjectTensionOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ProjectTensionOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeProjectTensionOrder |> Encode.optional input____.then_ ) ]


buildProjectTensionPatch :
    (ProjectTensionPatchOptionalFields -> ProjectTensionPatchOptionalFields)
    -> ProjectTensionPatch
buildProjectTensionPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { tension = Absent, pos = Absent, pc = Absent, values = Absent }
    in
    ProjectTensionPatch { tension = optionals____.tension, pos = optionals____.pos, pc = optionals____.pc, values = optionals____.values }


type alias ProjectTensionPatchOptionalFields =
    { tension : OptionalArgument TensionRef
    , pos : OptionalArgument Int
    , pc : OptionalArgument ProjectColumnRef
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type alias for the `ProjectTensionPatch` attributes. Note that this type
needs to use the `ProjectTensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectTensionPatchRaw =
    { tension : OptionalArgument TensionRef
    , pos : OptionalArgument Int
    , pc : OptionalArgument ProjectColumnRef
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the ProjectTensionPatch input object.
-}
type ProjectTensionPatch
    = ProjectTensionPatch ProjectTensionPatchRaw


{-| Encode a ProjectTensionPatch into a value that can be used as an argument.
-}
encodeProjectTensionPatch : ProjectTensionPatch -> Value
encodeProjectTensionPatch (ProjectTensionPatch input____) =
    Encode.maybeObject
        [ ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "pos", Encode.int |> Encode.optional input____.pos ), ( "pc", encodeProjectColumnRef |> Encode.optional input____.pc ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildProjectTensionRef :
    (ProjectTensionRefOptionalFields -> ProjectTensionRefOptionalFields)
    -> ProjectTensionRef
buildProjectTensionRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, tension = Absent, pos = Absent, pc = Absent, values = Absent }
    in
    ProjectTensionRef { id = optionals____.id, tension = optionals____.tension, pos = optionals____.pos, pc = optionals____.pc, values = optionals____.values }


type alias ProjectTensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , tension : OptionalArgument TensionRef
    , pos : OptionalArgument Int
    , pc : OptionalArgument ProjectColumnRef
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type alias for the `ProjectTensionRef` attributes. Note that this type
needs to use the `ProjectTensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ProjectTensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , tension : OptionalArgument TensionRef
    , pos : OptionalArgument Int
    , pc : OptionalArgument ProjectColumnRef
    , values : OptionalArgument (List ProjectFieldValueRef)
    }


{-| Type for the ProjectTensionRef input object.
-}
type ProjectTensionRef
    = ProjectTensionRef ProjectTensionRefRaw


{-| Encode a ProjectTensionRef into a value that can be used as an argument.
-}
encodeProjectTensionRef : ProjectTensionRef -> Value
encodeProjectTensionRef (ProjectTensionRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "tension", encodeTensionRef |> Encode.optional input____.tension ), ( "pos", Encode.int |> Encode.optional input____.pos ), ( "pc", encodeProjectColumnRef |> Encode.optional input____.pc ), ( "values", (encodeProjectFieldValueRef |> Encode.list) |> Encode.optional input____.values ) ]


buildReactionFilter :
    (ReactionFilterOptionalFields -> ReactionFilterOptionalFields)
    -> ReactionFilter
buildReactionFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, reactionid = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    ReactionFilter { id = optionals____.id, reactionid = optionals____.reactionid, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias ReactionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , reactionid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ReactionHasFilter.ReactionHasFilter))
    , and : OptionalArgument (List (Maybe ReactionFilter))
    , or : OptionalArgument (List (Maybe ReactionFilter))
    , not : OptionalArgument ReactionFilter
    }


{-| Type alias for the `ReactionFilter` attributes. Note that this type
needs to use the `ReactionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ReactionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , reactionid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.ReactionHasFilter.ReactionHasFilter))
    , and : OptionalArgument (List (Maybe ReactionFilter))
    , or : OptionalArgument (List (Maybe ReactionFilter))
    , not : OptionalArgument ReactionFilter
    }


{-| Type for the ReactionFilter input object.
-}
type ReactionFilter
    = ReactionFilter ReactionFilterRaw


{-| Encode a ReactionFilter into a value that can be used as an argument.
-}
encodeReactionFilter : ReactionFilter -> Value
encodeReactionFilter (ReactionFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "reactionid", encodeStringHashFilter |> Encode.optional input____.reactionid ), ( "has", (Encode.enum Fractal.Enum.ReactionHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeReactionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeReactionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeReactionFilter |> Encode.optional input____.not ) ]


buildReactionOrder :
    (ReactionOrderOptionalFields -> ReactionOrderOptionalFields)
    -> ReactionOrder
buildReactionOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    ReactionOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias ReactionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.ReactionOrderable.ReactionOrderable
    , desc : OptionalArgument Fractal.Enum.ReactionOrderable.ReactionOrderable
    , then_ : OptionalArgument ReactionOrder
    }


{-| Type alias for the `ReactionOrder` attributes. Note that this type
needs to use the `ReactionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ReactionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.ReactionOrderable.ReactionOrderable
    , desc : OptionalArgument Fractal.Enum.ReactionOrderable.ReactionOrderable
    , then_ : OptionalArgument ReactionOrder
    }


{-| Type for the ReactionOrder input object.
-}
type ReactionOrder
    = ReactionOrder ReactionOrderRaw


{-| Encode a ReactionOrder into a value that can be used as an argument.
-}
encodeReactionOrder : ReactionOrder -> Value
encodeReactionOrder (ReactionOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.ReactionOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.ReactionOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeReactionOrder |> Encode.optional input____.then_ ) ]


buildReactionPatch :
    (ReactionPatchOptionalFields -> ReactionPatchOptionalFields)
    -> ReactionPatch
buildReactionPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { user = Absent, comment = Absent, type_ = Absent }
    in
    ReactionPatch { user = optionals____.user, comment = optionals____.comment, type_ = optionals____.type_ }


type alias ReactionPatchOptionalFields =
    { user : OptionalArgument UserRef
    , comment : OptionalArgument CommentRef
    , type_ : OptionalArgument Int
    }


{-| Type alias for the `ReactionPatch` attributes. Note that this type
needs to use the `ReactionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ReactionPatchRaw =
    { user : OptionalArgument UserRef
    , comment : OptionalArgument CommentRef
    , type_ : OptionalArgument Int
    }


{-| Type for the ReactionPatch input object.
-}
type ReactionPatch
    = ReactionPatch ReactionPatchRaw


{-| Encode a ReactionPatch into a value that can be used as an argument.
-}
encodeReactionPatch : ReactionPatch -> Value
encodeReactionPatch (ReactionPatch input____) =
    Encode.maybeObject
        [ ( "user", encodeUserRef |> Encode.optional input____.user ), ( "comment", encodeCommentRef |> Encode.optional input____.comment ), ( "type_", Encode.int |> Encode.optional input____.type_ ) ]


buildReactionRef :
    (ReactionRefOptionalFields -> ReactionRefOptionalFields)
    -> ReactionRef
buildReactionRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, reactionid = Absent, user = Absent, comment = Absent, type_ = Absent }
    in
    ReactionRef { id = optionals____.id, reactionid = optionals____.reactionid, user = optionals____.user, comment = optionals____.comment, type_ = optionals____.type_ }


type alias ReactionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , reactionid : OptionalArgument String
    , user : OptionalArgument UserRef
    , comment : OptionalArgument CommentRef
    , type_ : OptionalArgument Int
    }


{-| Type alias for the `ReactionRef` attributes. Note that this type
needs to use the `ReactionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias ReactionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , reactionid : OptionalArgument String
    , user : OptionalArgument UserRef
    , comment : OptionalArgument CommentRef
    , type_ : OptionalArgument Int
    }


{-| Type for the ReactionRef input object.
-}
type ReactionRef
    = ReactionRef ReactionRefRaw


{-| Encode a ReactionRef into a value that can be used as an argument.
-}
encodeReactionRef : ReactionRef -> Value
encodeReactionRef (ReactionRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "reactionid", Encode.string |> Encode.optional input____.reactionid ), ( "user", encodeUserRef |> Encode.optional input____.user ), ( "comment", encodeCommentRef |> Encode.optional input____.comment ), ( "type_", Encode.int |> Encode.optional input____.type_ ) ]


buildRoleExtFilter :
    (RoleExtFilterOptionalFields -> RoleExtFilterOptionalFields)
    -> RoleExtFilter
buildRoleExtFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    RoleExtFilter { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias RoleExtFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.RoleExtHasFilter.RoleExtHasFilter))
    , and : OptionalArgument (List (Maybe RoleExtFilter))
    , or : OptionalArgument (List (Maybe RoleExtFilter))
    , not : OptionalArgument RoleExtFilter
    }


{-| Type alias for the `RoleExtFilter` attributes. Note that this type
needs to use the `RoleExtFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , rootnameid : OptionalArgument StringHashFilter
    , name : OptionalArgument StringHashFilter_StringTermFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.RoleExtHasFilter.RoleExtHasFilter))
    , and : OptionalArgument (List (Maybe RoleExtFilter))
    , or : OptionalArgument (List (Maybe RoleExtFilter))
    , not : OptionalArgument RoleExtFilter
    }


{-| Type for the RoleExtFilter input object.
-}
type RoleExtFilter
    = RoleExtFilter RoleExtFilterRaw


{-| Encode a RoleExtFilter into a value that can be used as an argument.
-}
encodeRoleExtFilter : RoleExtFilter -> Value
encodeRoleExtFilter (RoleExtFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "rootnameid", encodeStringHashFilter |> Encode.optional input____.rootnameid ), ( "name", encodeStringHashFilter_StringTermFilter |> Encode.optional input____.name ), ( "has", (Encode.enum Fractal.Enum.RoleExtHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeRoleExtFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeRoleExtFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeRoleExtFilter |> Encode.optional input____.not ) ]


buildRoleExtOrder :
    (RoleExtOrderOptionalFields -> RoleExtOrderOptionalFields)
    -> RoleExtOrder
buildRoleExtOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    RoleExtOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias RoleExtOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , desc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , then_ : OptionalArgument RoleExtOrder
    }


{-| Type alias for the `RoleExtOrder` attributes. Note that this type
needs to use the `RoleExtOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtOrderRaw =
    { asc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , desc : OptionalArgument Fractal.Enum.RoleExtOrderable.RoleExtOrderable
    , then_ : OptionalArgument RoleExtOrder
    }


{-| Type for the RoleExtOrder input object.
-}
type RoleExtOrder
    = RoleExtOrder RoleExtOrderRaw


{-| Encode a RoleExtOrder into a value that can be used as an argument.
-}
encodeRoleExtOrder : RoleExtOrder -> Value
encodeRoleExtOrder (RoleExtOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.RoleExtOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.RoleExtOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeRoleExtOrder |> Encode.optional input____.then_ ) ]


buildRoleExtPatch :
    (RoleExtPatchOptionalFields -> RoleExtPatchOptionalFields)
    -> RoleExtPatch
buildRoleExtPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { rootnameid = Absent, name = Absent, about = Absent, role_type = Absent, color = Absent, mandate = Absent, roles = Absent, nodes = Absent }
    in
    RoleExtPatch { rootnameid = optionals____.rootnameid, name = optionals____.name, about = optionals____.about, role_type = optionals____.role_type, color = optionals____.color, mandate = optionals____.mandate, roles = optionals____.roles, nodes = optionals____.nodes }


type alias RoleExtPatchOptionalFields =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `RoleExtPatch` attributes. Note that this type
needs to use the `RoleExtPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtPatchRaw =
    { rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the RoleExtPatch input object.
-}
type RoleExtPatch
    = RoleExtPatch RoleExtPatchRaw


{-| Encode a RoleExtPatch into a value that can be used as an argument.
-}
encodeRoleExtPatch : RoleExtPatch -> Value
encodeRoleExtPatch (RoleExtPatch input____) =
    Encode.maybeObject
        [ ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildRoleExtRef :
    (RoleExtRefOptionalFields -> RoleExtRefOptionalFields)
    -> RoleExtRef
buildRoleExtRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, rootnameid = Absent, name = Absent, about = Absent, role_type = Absent, color = Absent, mandate = Absent, roles = Absent, nodes = Absent }
    in
    RoleExtRef { id = optionals____.id, rootnameid = optionals____.rootnameid, name = optionals____.name, about = optionals____.about, role_type = optionals____.role_type, color = optionals____.color, mandate = optionals____.mandate, roles = optionals____.roles, nodes = optionals____.nodes }


type alias RoleExtRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type alias for the `RoleExtRef` attributes. Note that this type
needs to use the `RoleExtRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias RoleExtRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , rootnameid : OptionalArgument String
    , name : OptionalArgument String
    , about : OptionalArgument String
    , role_type : OptionalArgument Fractal.Enum.RoleType.RoleType
    , color : OptionalArgument String
    , mandate : OptionalArgument MandateRef
    , roles : OptionalArgument (List NodeRef)
    , nodes : OptionalArgument (List NodeRef)
    }


{-| Type for the RoleExtRef input object.
-}
type RoleExtRef
    = RoleExtRef RoleExtRefRaw


{-| Encode a RoleExtRef into a value that can be used as an argument.
-}
encodeRoleExtRef : RoleExtRef -> Value
encodeRoleExtRef (RoleExtRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "rootnameid", Encode.string |> Encode.optional input____.rootnameid ), ( "name", Encode.string |> Encode.optional input____.name ), ( "about", Encode.string |> Encode.optional input____.about ), ( "role_type", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.role_type ), ( "color", Encode.string |> Encode.optional input____.color ), ( "mandate", encodeMandateRef |> Encode.optional input____.mandate ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "nodes", (encodeNodeRef |> Encode.list) |> Encode.optional input____.nodes ) ]


buildRoleType_hash :
    (RoleType_hashOptionalFields -> RoleType_hashOptionalFields)
    -> RoleType_hash
buildRoleType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias RoleType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Type for the RoleType\_hash input object.
-}
type alias RoleType_hash =
    { eq : OptionalArgument Fractal.Enum.RoleType.RoleType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.RoleType.RoleType))
    }


{-| Encode a RoleType\_hash into a value that can be used as an argument.
-}
encodeRoleType_hash : RoleType_hash -> Value
encodeRoleType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.RoleType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.RoleType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildStringExactFilter :
    (StringExactFilterOptionalFields -> StringExactFilterOptionalFields)
    -> StringExactFilter
buildStringExactFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, le = Absent, lt = Absent, ge = Absent, gt = Absent, between = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, le = optionals____.le, lt = optionals____.lt, ge = optionals____.ge, gt = optionals____.gt, between = optionals____.between }


type alias StringExactFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Type for the StringExactFilter input object.
-}
type alias StringExactFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , le : OptionalArgument String
    , lt : OptionalArgument String
    , ge : OptionalArgument String
    , gt : OptionalArgument String
    , between : OptionalArgument StringRange
    }


{-| Encode a StringExactFilter into a value that can be used as an argument.
-}
encodeStringExactFilter : StringExactFilter -> Value
encodeStringExactFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "le", Encode.string |> Encode.optional input____.le ), ( "lt", Encode.string |> Encode.optional input____.lt ), ( "ge", Encode.string |> Encode.optional input____.ge ), ( "gt", Encode.string |> Encode.optional input____.gt ), ( "between", encodeStringRange |> Encode.optional input____.between ) ]


buildStringFullTextFilter :
    (StringFullTextFilterOptionalFields -> StringFullTextFilterOptionalFields)
    -> StringFullTextFilter
buildStringFullTextFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { alloftext = Absent, anyoftext = Absent }
    in
    { alloftext = optionals____.alloftext, anyoftext = optionals____.anyoftext }


type alias StringFullTextFilterOptionalFields =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Type for the StringFullTextFilter input object.
-}
type alias StringFullTextFilter =
    { alloftext : OptionalArgument String
    , anyoftext : OptionalArgument String
    }


{-| Encode a StringFullTextFilter into a value that can be used as an argument.
-}
encodeStringFullTextFilter : StringFullTextFilter -> Value
encodeStringFullTextFilter input____ =
    Encode.maybeObject
        [ ( "alloftext", Encode.string |> Encode.optional input____.alloftext ), ( "anyoftext", Encode.string |> Encode.optional input____.anyoftext ) ]


buildStringHashFilter :
    (StringHashFilterOptionalFields -> StringHashFilterOptionalFields)
    -> StringHashFilter
buildStringHashFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias StringHashFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Type for the StringHashFilter input object.
-}
type alias StringHashFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    }


{-| Encode a StringHashFilter into a value that can be used as an argument.
-}
encodeStringHashFilter : StringHashFilter -> Value
encodeStringHashFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildStringHashFilter_StringRegExpFilter :
    (StringHashFilter_StringRegExpFilterOptionalFields -> StringHashFilter_StringRegExpFilterOptionalFields)
    -> StringHashFilter_StringRegExpFilter
buildStringHashFilter_StringRegExpFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, regexp = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, regexp = optionals____.regexp }


type alias StringHashFilter_StringRegExpFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringRegExpFilter input object.
-}
type alias StringHashFilter_StringRegExpFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , regexp : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringRegExpFilter : StringHashFilter_StringRegExpFilter -> Value
encodeStringHashFilter_StringRegExpFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "regexp", Encode.string |> Encode.optional input____.regexp ) ]


buildStringHashFilter_StringTermFilter :
    (StringHashFilter_StringTermFilterOptionalFields -> StringHashFilter_StringTermFilterOptionalFields)
    -> StringHashFilter_StringTermFilter
buildStringHashFilter_StringTermFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent, allofterms = Absent, anyofterms = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_, allofterms = optionals____.allofterms, anyofterms = optionals____.anyofterms }


type alias StringHashFilter_StringTermFilterOptionalFields =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringHashFilter\_StringTermFilter input object.
-}
type alias StringHashFilter_StringTermFilter =
    { eq : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringHashFilter\_StringTermFilter into a value that can be used as an argument.
-}
encodeStringHashFilter_StringTermFilter : StringHashFilter_StringTermFilter -> Value
encodeStringHashFilter_StringTermFilter input____ =
    Encode.maybeObject
        [ ( "eq", Encode.string |> Encode.optional input____.eq ), ( "in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ), ( "allofterms", Encode.string |> Encode.optional input____.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input____.anyofterms ) ]


buildStringRange :
    StringRangeRequiredFields
    -> StringRange
buildStringRange required____ =
    { min = required____.min, max = required____.max }


type alias StringRangeRequiredFields =
    { min : String
    , max : String
    }


{-| Type for the StringRange input object.
-}
type alias StringRange =
    { min : String
    , max : String
    }


{-| Encode a StringRange into a value that can be used as an argument.
-}
encodeStringRange : StringRange -> Value
encodeStringRange input____ =
    Encode.maybeObject
        [ ( "min", Encode.string input____.min |> Just ), ( "max", Encode.string input____.max |> Just ) ]


buildStringRegExpFilter :
    (StringRegExpFilterOptionalFields -> StringRegExpFilterOptionalFields)
    -> StringRegExpFilter
buildStringRegExpFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { regexp = Absent }
    in
    { regexp = optionals____.regexp }


type alias StringRegExpFilterOptionalFields =
    { regexp : OptionalArgument String }


{-| Type for the StringRegExpFilter input object.
-}
type alias StringRegExpFilter =
    { regexp : OptionalArgument String }


{-| Encode a StringRegExpFilter into a value that can be used as an argument.
-}
encodeStringRegExpFilter : StringRegExpFilter -> Value
encodeStringRegExpFilter input____ =
    Encode.maybeObject
        [ ( "regexp", Encode.string |> Encode.optional input____.regexp ) ]


buildStringTermFilter :
    (StringTermFilterOptionalFields -> StringTermFilterOptionalFields)
    -> StringTermFilter
buildStringTermFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { allofterms = Absent, anyofterms = Absent }
    in
    { allofterms = optionals____.allofterms, anyofterms = optionals____.anyofterms }


type alias StringTermFilterOptionalFields =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Type for the StringTermFilter input object.
-}
type alias StringTermFilter =
    { allofterms : OptionalArgument String
    , anyofterms : OptionalArgument String
    }


{-| Encode a StringTermFilter into a value that can be used as an argument.
-}
encodeStringTermFilter : StringTermFilter -> Value
encodeStringTermFilter input____ =
    Encode.maybeObject
        [ ( "allofterms", Encode.string |> Encode.optional input____.allofterms ), ( "anyofterms", Encode.string |> Encode.optional input____.anyofterms ) ]


buildTensionEvent_hash :
    (TensionEvent_hashOptionalFields -> TensionEvent_hashOptionalFields)
    -> TensionEvent_hash
buildTensionEvent_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionEvent_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Type for the TensionEvent\_hash input object.
-}
type alias TensionEvent_hash =
    { eq : OptionalArgument Fractal.Enum.TensionEvent.TensionEvent
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionEvent.TensionEvent))
    }


{-| Encode a TensionEvent\_hash into a value that can be used as an argument.
-}
encodeTensionEvent_hash : TensionEvent_hash -> Value
encodeTensionEvent_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionEvent.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildTensionFilter :
    (TensionFilterOptionalFields -> TensionFilterOptionalFields)
    -> TensionFilter
buildTensionFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, emitterid = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    TensionFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, emitterid = optionals____.emitterid, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias TensionFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type alias for the `TensionFilter` attributes. Note that this type
needs to use the `TensionFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , emitterid : OptionalArgument StringHashFilter_StringRegExpFilter
    , receiverid : OptionalArgument StringHashFilter_StringRegExpFilter
    , title : OptionalArgument StringFullTextFilter
    , type_ : OptionalArgument TensionType_hash
    , status : OptionalArgument TensionStatus_hash
    , has : OptionalArgument (List (Maybe Fractal.Enum.TensionHasFilter.TensionHasFilter))
    , and : OptionalArgument (List (Maybe TensionFilter))
    , or : OptionalArgument (List (Maybe TensionFilter))
    , not : OptionalArgument TensionFilter
    }


{-| Type for the TensionFilter input object.
-}
type TensionFilter
    = TensionFilter TensionFilterRaw


{-| Encode a TensionFilter into a value that can be used as an argument.
-}
encodeTensionFilter : TensionFilter -> Value
encodeTensionFilter (TensionFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "emitterid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.emitterid ), ( "receiverid", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.receiverid ), ( "title", encodeStringFullTextFilter |> Encode.optional input____.title ), ( "type_", encodeTensionType_hash |> Encode.optional input____.type_ ), ( "status", encodeTensionStatus_hash |> Encode.optional input____.status ), ( "has", (Encode.enum Fractal.Enum.TensionHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeTensionFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeTensionFilter |> Encode.optional input____.not ) ]


buildTensionOrder :
    (TensionOrderOptionalFields -> TensionOrderOptionalFields)
    -> TensionOrder
buildTensionOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    TensionOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias TensionOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type alias for the `TensionOrder` attributes. Note that this type
needs to use the `TensionOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionOrderRaw =
    { asc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , desc : OptionalArgument Fractal.Enum.TensionOrderable.TensionOrderable
    , then_ : OptionalArgument TensionOrder
    }


{-| Type for the TensionOrder input object.
-}
type TensionOrder
    = TensionOrder TensionOrderRaw


{-| Encode a TensionOrder into a value that can be used as an argument.
-}
encodeTensionOrder : TensionOrder -> Value
encodeTensionOrder (TensionOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.TensionOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeTensionOrder |> Encode.optional input____.then_ ) ]


buildTensionPatch :
    (TensionPatchOptionalFields -> TensionPatchOptionalFields)
    -> TensionPatch
buildTensionPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, action = Absent, assignees = Absent, labels = Absent, comments = Absent, blobs = Absent, history = Absent, mentions = Absent, contracts = Absent, subscribers = Absent, projects = Absent, n_comments = Absent }
    in
    TensionPatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = optionals____.emitter, emitterid = optionals____.emitterid, receiver = optionals____.receiver, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, action = optionals____.action, assignees = optionals____.assignees, labels = optionals____.labels, comments = optionals____.comments, blobs = optionals____.blobs, history = optionals____.history, mentions = optionals____.mentions, contracts = optionals____.contracts, subscribers = optionals____.subscribers, projects = optionals____.projects, n_comments = optionals____.n_comments }


type alias TensionPatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionPatch` attributes. Note that this type
needs to use the `TensionPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionPatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionPatch input object.
-}
type TensionPatch
    = TensionPatch TensionPatchRaw


{-| Encode a TensionPatch into a value that can be used as an argument.
-}
encodeTensionPatch : TensionPatch -> Value
encodeTensionPatch (TensionPatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef |> Encode.optional input____.emitter ), ( "emitterid", Encode.string |> Encode.optional input____.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input____.receiver ), ( "receiverid", Encode.string |> Encode.optional input____.receiverid ), ( "title", Encode.string |> Encode.optional input____.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input____.history ), ( "mentions", (encodeEventRef |> Encode.list) |> Encode.optional input____.mentions ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.subscribers ), ( "projects", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.projects ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ) ]


buildTensionRef :
    (TensionRefOptionalFields -> TensionRefOptionalFields)
    -> TensionRef
buildTensionRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, emitter = Absent, emitterid = Absent, receiver = Absent, receiverid = Absent, title = Absent, type_ = Absent, status = Absent, action = Absent, assignees = Absent, labels = Absent, comments = Absent, blobs = Absent, history = Absent, mentions = Absent, contracts = Absent, subscribers = Absent, projects = Absent, n_comments = Absent }
    in
    TensionRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, emitter = optionals____.emitter, emitterid = optionals____.emitterid, receiver = optionals____.receiver, receiverid = optionals____.receiverid, title = optionals____.title, type_ = optionals____.type_, status = optionals____.status, action = optionals____.action, assignees = optionals____.assignees, labels = optionals____.labels, comments = optionals____.comments, blobs = optionals____.blobs, history = optionals____.history, mentions = optionals____.mentions, contracts = optionals____.contracts, subscribers = optionals____.subscribers, projects = optionals____.projects, n_comments = optionals____.n_comments }


type alias TensionRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type alias for the `TensionRef` attributes. Note that this type
needs to use the `TensionRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias TensionRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , emitter : OptionalArgument NodeRef
    , emitterid : OptionalArgument String
    , receiver : OptionalArgument NodeRef
    , receiverid : OptionalArgument String
    , title : OptionalArgument String
    , type_ : OptionalArgument Fractal.Enum.TensionType.TensionType
    , status : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , action : OptionalArgument Fractal.Enum.TensionAction.TensionAction
    , assignees : OptionalArgument (List UserRef)
    , labels : OptionalArgument (List LabelRef)
    , comments : OptionalArgument (List CommentRef)
    , blobs : OptionalArgument (List BlobRef)
    , history : OptionalArgument (List EventRef)
    , mentions : OptionalArgument (List EventRef)
    , contracts : OptionalArgument (List ContractRef)
    , subscribers : OptionalArgument (List UserRef)
    , projects : OptionalArgument (List ProjectTensionRef)
    , n_comments : OptionalArgument Int
    }


{-| Type for the TensionRef input object.
-}
type TensionRef
    = TensionRef TensionRefRaw


{-| Encode a TensionRef into a value that can be used as an argument.
-}
encodeTensionRef : TensionRef -> Value
encodeTensionRef (TensionRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "emitter", encodeNodeRef |> Encode.optional input____.emitter ), ( "emitterid", Encode.string |> Encode.optional input____.emitterid ), ( "receiver", encodeNodeRef |> Encode.optional input____.receiver ), ( "receiverid", Encode.string |> Encode.optional input____.receiverid ), ( "title", Encode.string |> Encode.optional input____.title ), ( "type_", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.type_ ), ( "status", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.status ), ( "action", Encode.enum Fractal.Enum.TensionAction.toString |> Encode.optional input____.action ), ( "assignees", (encodeUserRef |> Encode.list) |> Encode.optional input____.assignees ), ( "labels", (encodeLabelRef |> Encode.list) |> Encode.optional input____.labels ), ( "comments", (encodeCommentRef |> Encode.list) |> Encode.optional input____.comments ), ( "blobs", (encodeBlobRef |> Encode.list) |> Encode.optional input____.blobs ), ( "history", (encodeEventRef |> Encode.list) |> Encode.optional input____.history ), ( "mentions", (encodeEventRef |> Encode.list) |> Encode.optional input____.mentions ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "subscribers", (encodeUserRef |> Encode.list) |> Encode.optional input____.subscribers ), ( "projects", (encodeProjectTensionRef |> Encode.list) |> Encode.optional input____.projects ), ( "n_comments", Encode.int |> Encode.optional input____.n_comments ) ]


buildTensionStatus_hash :
    (TensionStatus_hashOptionalFields -> TensionStatus_hashOptionalFields)
    -> TensionStatus_hash
buildTensionStatus_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionStatus_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Type for the TensionStatus\_hash input object.
-}
type alias TensionStatus_hash =
    { eq : OptionalArgument Fractal.Enum.TensionStatus.TensionStatus
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionStatus.TensionStatus))
    }


{-| Encode a TensionStatus\_hash into a value that can be used as an argument.
-}
encodeTensionStatus_hash : TensionStatus_hash -> Value
encodeTensionStatus_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionStatus.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildTensionType_hash :
    (TensionType_hashOptionalFields -> TensionType_hashOptionalFields)
    -> TensionType_hash
buildTensionType_hash fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq = Absent, in_ = Absent }
    in
    { eq = optionals____.eq, in_ = optionals____.in_ }


type alias TensionType_hashOptionalFields =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Type for the TensionType\_hash input object.
-}
type alias TensionType_hash =
    { eq : OptionalArgument Fractal.Enum.TensionType.TensionType
    , in_ : OptionalArgument (List (Maybe Fractal.Enum.TensionType.TensionType))
    }


{-| Encode a TensionType\_hash into a value that can be used as an argument.
-}
encodeTensionType_hash : TensionType_hash -> Value
encodeTensionType_hash input____ =
    Encode.maybeObject
        [ ( "eq", Encode.enum Fractal.Enum.TensionType.toString |> Encode.optional input____.eq ), ( "in", (Encode.enum Fractal.Enum.TensionType.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.in_ ) ]


buildUpdateBlobInput :
    UpdateBlobInputRequiredFields
    -> (UpdateBlobInputOptionalFields -> UpdateBlobInputOptionalFields)
    -> UpdateBlobInput
buildUpdateBlobInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateBlobInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateBlobInputRequiredFields =
    { filter : BlobFilter }


type alias UpdateBlobInputOptionalFields =
    { set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type alias for the `UpdateBlobInput` attributes. Note that this type
needs to use the `UpdateBlobInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateBlobInputRaw =
    { filter : BlobFilter
    , set : OptionalArgument BlobPatch
    , remove : OptionalArgument BlobPatch
    }


{-| Type for the UpdateBlobInput input object.
-}
type UpdateBlobInput
    = UpdateBlobInput UpdateBlobInputRaw


{-| Encode a UpdateBlobInput into a value that can be used as an argument.
-}
encodeUpdateBlobInput : UpdateBlobInput -> Value
encodeUpdateBlobInput (UpdateBlobInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeBlobFilter input____.filter |> Just ), ( "set", encodeBlobPatch |> Encode.optional input____.set ), ( "remove", encodeBlobPatch |> Encode.optional input____.remove ) ]


buildUpdateCommentInput :
    UpdateCommentInputRequiredFields
    -> (UpdateCommentInputOptionalFields -> UpdateCommentInputOptionalFields)
    -> UpdateCommentInput
buildUpdateCommentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateCommentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateCommentInputRequiredFields =
    { filter : CommentFilter }


type alias UpdateCommentInputOptionalFields =
    { set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type alias for the `UpdateCommentInput` attributes. Note that this type
needs to use the `UpdateCommentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateCommentInputRaw =
    { filter : CommentFilter
    , set : OptionalArgument CommentPatch
    , remove : OptionalArgument CommentPatch
    }


{-| Type for the UpdateCommentInput input object.
-}
type UpdateCommentInput
    = UpdateCommentInput UpdateCommentInputRaw


{-| Encode a UpdateCommentInput into a value that can be used as an argument.
-}
encodeUpdateCommentInput : UpdateCommentInput -> Value
encodeUpdateCommentInput (UpdateCommentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeCommentFilter input____.filter |> Just ), ( "set", encodeCommentPatch |> Encode.optional input____.set ), ( "remove", encodeCommentPatch |> Encode.optional input____.remove ) ]


buildUpdateContractInput :
    UpdateContractInputRequiredFields
    -> (UpdateContractInputOptionalFields -> UpdateContractInputOptionalFields)
    -> UpdateContractInput
buildUpdateContractInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateContractInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateContractInputRequiredFields =
    { filter : ContractFilter }


type alias UpdateContractInputOptionalFields =
    { set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type alias for the `UpdateContractInput` attributes. Note that this type
needs to use the `UpdateContractInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateContractInputRaw =
    { filter : ContractFilter
    , set : OptionalArgument ContractPatch
    , remove : OptionalArgument ContractPatch
    }


{-| Type for the UpdateContractInput input object.
-}
type UpdateContractInput
    = UpdateContractInput UpdateContractInputRaw


{-| Encode a UpdateContractInput into a value that can be used as an argument.
-}
encodeUpdateContractInput : UpdateContractInput -> Value
encodeUpdateContractInput (UpdateContractInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeContractFilter input____.filter |> Just ), ( "set", encodeContractPatch |> Encode.optional input____.set ), ( "remove", encodeContractPatch |> Encode.optional input____.remove ) ]


buildUpdateEventCountInput :
    UpdateEventCountInputRequiredFields
    -> (UpdateEventCountInputOptionalFields -> UpdateEventCountInputOptionalFields)
    -> UpdateEventCountInput
buildUpdateEventCountInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateEventCountInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateEventCountInputRequiredFields =
    { filter : EventCountFilter }


type alias UpdateEventCountInputOptionalFields =
    { set : OptionalArgument EventCountPatch
    , remove : OptionalArgument EventCountPatch
    }


{-| Type alias for the `UpdateEventCountInput` attributes. Note that this type
needs to use the `UpdateEventCountInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventCountInputRaw =
    { filter : EventCountFilter
    , set : OptionalArgument EventCountPatch
    , remove : OptionalArgument EventCountPatch
    }


{-| Type for the UpdateEventCountInput input object.
-}
type UpdateEventCountInput
    = UpdateEventCountInput UpdateEventCountInputRaw


{-| Encode a UpdateEventCountInput into a value that can be used as an argument.
-}
encodeUpdateEventCountInput : UpdateEventCountInput -> Value
encodeUpdateEventCountInput (UpdateEventCountInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeEventCountFilter input____.filter |> Just ), ( "set", encodeEventCountPatch |> Encode.optional input____.set ), ( "remove", encodeEventCountPatch |> Encode.optional input____.remove ) ]


buildUpdateEventFragmentInput :
    UpdateEventFragmentInputRequiredFields
    -> (UpdateEventFragmentInputOptionalFields -> UpdateEventFragmentInputOptionalFields)
    -> UpdateEventFragmentInput
buildUpdateEventFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateEventFragmentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateEventFragmentInputRequiredFields =
    { filter : EventFragmentFilter }


type alias UpdateEventFragmentInputOptionalFields =
    { set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type alias for the `UpdateEventFragmentInput` attributes. Note that this type
needs to use the `UpdateEventFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventFragmentInputRaw =
    { filter : EventFragmentFilter
    , set : OptionalArgument EventFragmentPatch
    , remove : OptionalArgument EventFragmentPatch
    }


{-| Type for the UpdateEventFragmentInput input object.
-}
type UpdateEventFragmentInput
    = UpdateEventFragmentInput UpdateEventFragmentInputRaw


{-| Encode a UpdateEventFragmentInput into a value that can be used as an argument.
-}
encodeUpdateEventFragmentInput : UpdateEventFragmentInput -> Value
encodeUpdateEventFragmentInput (UpdateEventFragmentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeEventFragmentFilter input____.filter |> Just ), ( "set", encodeEventFragmentPatch |> Encode.optional input____.set ), ( "remove", encodeEventFragmentPatch |> Encode.optional input____.remove ) ]


buildUpdateEventInput :
    UpdateEventInputRequiredFields
    -> (UpdateEventInputOptionalFields -> UpdateEventInputOptionalFields)
    -> UpdateEventInput
buildUpdateEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateEventInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateEventInputRequiredFields =
    { filter : EventFilter }


type alias UpdateEventInputOptionalFields =
    { set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type alias for the `UpdateEventInput` attributes. Note that this type
needs to use the `UpdateEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateEventInputRaw =
    { filter : EventFilter
    , set : OptionalArgument EventPatch
    , remove : OptionalArgument EventPatch
    }


{-| Type for the UpdateEventInput input object.
-}
type UpdateEventInput
    = UpdateEventInput UpdateEventInputRaw


{-| Encode a UpdateEventInput into a value that can be used as an argument.
-}
encodeUpdateEventInput : UpdateEventInput -> Value
encodeUpdateEventInput (UpdateEventInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeEventFilter input____.filter |> Just ), ( "set", encodeEventPatch |> Encode.optional input____.set ), ( "remove", encodeEventPatch |> Encode.optional input____.remove ) ]


buildUpdateLabelInput :
    UpdateLabelInputRequiredFields
    -> (UpdateLabelInputOptionalFields -> UpdateLabelInputOptionalFields)
    -> UpdateLabelInput
buildUpdateLabelInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateLabelInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateLabelInputRequiredFields =
    { filter : LabelFilter }


type alias UpdateLabelInputOptionalFields =
    { set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type alias for the `UpdateLabelInput` attributes. Note that this type
needs to use the `UpdateLabelInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateLabelInputRaw =
    { filter : LabelFilter
    , set : OptionalArgument LabelPatch
    , remove : OptionalArgument LabelPatch
    }


{-| Type for the UpdateLabelInput input object.
-}
type UpdateLabelInput
    = UpdateLabelInput UpdateLabelInputRaw


{-| Encode a UpdateLabelInput into a value that can be used as an argument.
-}
encodeUpdateLabelInput : UpdateLabelInput -> Value
encodeUpdateLabelInput (UpdateLabelInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeLabelFilter input____.filter |> Just ), ( "set", encodeLabelPatch |> Encode.optional input____.set ), ( "remove", encodeLabelPatch |> Encode.optional input____.remove ) ]


buildUpdateMandateInput :
    UpdateMandateInputRequiredFields
    -> (UpdateMandateInputOptionalFields -> UpdateMandateInputOptionalFields)
    -> UpdateMandateInput
buildUpdateMandateInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateMandateInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateMandateInputRequiredFields =
    { filter : MandateFilter }


type alias UpdateMandateInputOptionalFields =
    { set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type alias for the `UpdateMandateInput` attributes. Note that this type
needs to use the `UpdateMandateInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateMandateInputRaw =
    { filter : MandateFilter
    , set : OptionalArgument MandatePatch
    , remove : OptionalArgument MandatePatch
    }


{-| Type for the UpdateMandateInput input object.
-}
type UpdateMandateInput
    = UpdateMandateInput UpdateMandateInputRaw


{-| Encode a UpdateMandateInput into a value that can be used as an argument.
-}
encodeUpdateMandateInput : UpdateMandateInput -> Value
encodeUpdateMandateInput (UpdateMandateInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeMandateFilter input____.filter |> Just ), ( "set", encodeMandatePatch |> Encode.optional input____.set ), ( "remove", encodeMandatePatch |> Encode.optional input____.remove ) ]


buildUpdateNodeFragmentInput :
    UpdateNodeFragmentInputRequiredFields
    -> (UpdateNodeFragmentInputOptionalFields -> UpdateNodeFragmentInputOptionalFields)
    -> UpdateNodeFragmentInput
buildUpdateNodeFragmentInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateNodeFragmentInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateNodeFragmentInputRequiredFields =
    { filter : NodeFragmentFilter }


type alias UpdateNodeFragmentInputOptionalFields =
    { set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type alias for the `UpdateNodeFragmentInput` attributes. Note that this type
needs to use the `UpdateNodeFragmentInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeFragmentInputRaw =
    { filter : NodeFragmentFilter
    , set : OptionalArgument NodeFragmentPatch
    , remove : OptionalArgument NodeFragmentPatch
    }


{-| Type for the UpdateNodeFragmentInput input object.
-}
type UpdateNodeFragmentInput
    = UpdateNodeFragmentInput UpdateNodeFragmentInputRaw


{-| Encode a UpdateNodeFragmentInput into a value that can be used as an argument.
-}
encodeUpdateNodeFragmentInput : UpdateNodeFragmentInput -> Value
encodeUpdateNodeFragmentInput (UpdateNodeFragmentInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFragmentFilter input____.filter |> Just ), ( "set", encodeNodeFragmentPatch |> Encode.optional input____.set ), ( "remove", encodeNodeFragmentPatch |> Encode.optional input____.remove ) ]


buildUpdateNodeInput :
    UpdateNodeInputRequiredFields
    -> (UpdateNodeInputOptionalFields -> UpdateNodeInputOptionalFields)
    -> UpdateNodeInput
buildUpdateNodeInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateNodeInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateNodeInputRequiredFields =
    { filter : NodeFilter }


type alias UpdateNodeInputOptionalFields =
    { set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type alias for the `UpdateNodeInput` attributes. Note that this type
needs to use the `UpdateNodeInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNodeInputRaw =
    { filter : NodeFilter
    , set : OptionalArgument NodePatch
    , remove : OptionalArgument NodePatch
    }


{-| Type for the UpdateNodeInput input object.
-}
type UpdateNodeInput
    = UpdateNodeInput UpdateNodeInputRaw


{-| Encode a UpdateNodeInput into a value that can be used as an argument.
-}
encodeUpdateNodeInput : UpdateNodeInput -> Value
encodeUpdateNodeInput (UpdateNodeInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeNodeFilter input____.filter |> Just ), ( "set", encodeNodePatch |> Encode.optional input____.set ), ( "remove", encodeNodePatch |> Encode.optional input____.remove ) ]


buildUpdateNotifInput :
    UpdateNotifInputRequiredFields
    -> (UpdateNotifInputOptionalFields -> UpdateNotifInputOptionalFields)
    -> UpdateNotifInput
buildUpdateNotifInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateNotifInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateNotifInputRequiredFields =
    { filter : NotifFilter }


type alias UpdateNotifInputOptionalFields =
    { set : OptionalArgument NotifPatch
    , remove : OptionalArgument NotifPatch
    }


{-| Type alias for the `UpdateNotifInput` attributes. Note that this type
needs to use the `UpdateNotifInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateNotifInputRaw =
    { filter : NotifFilter
    , set : OptionalArgument NotifPatch
    , remove : OptionalArgument NotifPatch
    }


{-| Type for the UpdateNotifInput input object.
-}
type UpdateNotifInput
    = UpdateNotifInput UpdateNotifInputRaw


{-| Encode a UpdateNotifInput into a value that can be used as an argument.
-}
encodeUpdateNotifInput : UpdateNotifInput -> Value
encodeUpdateNotifInput (UpdateNotifInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeNotifFilter input____.filter |> Just ), ( "set", encodeNotifPatch |> Encode.optional input____.set ), ( "remove", encodeNotifPatch |> Encode.optional input____.remove ) ]


buildUpdatePendingUserInput :
    UpdatePendingUserInputRequiredFields
    -> (UpdatePendingUserInputOptionalFields -> UpdatePendingUserInputOptionalFields)
    -> UpdatePendingUserInput
buildUpdatePendingUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdatePendingUserInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdatePendingUserInputRequiredFields =
    { filter : PendingUserFilter }


type alias UpdatePendingUserInputOptionalFields =
    { set : OptionalArgument PendingUserPatch
    , remove : OptionalArgument PendingUserPatch
    }


{-| Type alias for the `UpdatePendingUserInput` attributes. Note that this type
needs to use the `UpdatePendingUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePendingUserInputRaw =
    { filter : PendingUserFilter
    , set : OptionalArgument PendingUserPatch
    , remove : OptionalArgument PendingUserPatch
    }


{-| Type for the UpdatePendingUserInput input object.
-}
type UpdatePendingUserInput
    = UpdatePendingUserInput UpdatePendingUserInputRaw


{-| Encode a UpdatePendingUserInput into a value that can be used as an argument.
-}
encodeUpdatePendingUserInput : UpdatePendingUserInput -> Value
encodeUpdatePendingUserInput (UpdatePendingUserInput input____) =
    Encode.maybeObject
        [ ( "filter", encodePendingUserFilter input____.filter |> Just ), ( "set", encodePendingUserPatch |> Encode.optional input____.set ), ( "remove", encodePendingUserPatch |> Encode.optional input____.remove ) ]


buildUpdatePostInput :
    UpdatePostInputRequiredFields
    -> (UpdatePostInputOptionalFields -> UpdatePostInputOptionalFields)
    -> UpdatePostInput
buildUpdatePostInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdatePostInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdatePostInputRequiredFields =
    { filter : PostFilter }


type alias UpdatePostInputOptionalFields =
    { set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type alias for the `UpdatePostInput` attributes. Note that this type
needs to use the `UpdatePostInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdatePostInputRaw =
    { filter : PostFilter
    , set : OptionalArgument PostPatch
    , remove : OptionalArgument PostPatch
    }


{-| Type for the UpdatePostInput input object.
-}
type UpdatePostInput
    = UpdatePostInput UpdatePostInputRaw


{-| Encode a UpdatePostInput into a value that can be used as an argument.
-}
encodeUpdatePostInput : UpdatePostInput -> Value
encodeUpdatePostInput (UpdatePostInput input____) =
    Encode.maybeObject
        [ ( "filter", encodePostFilter input____.filter |> Just ), ( "set", encodePostPatch |> Encode.optional input____.set ), ( "remove", encodePostPatch |> Encode.optional input____.remove ) ]


buildUpdateProjectColumnInput :
    UpdateProjectColumnInputRequiredFields
    -> (UpdateProjectColumnInputOptionalFields -> UpdateProjectColumnInputOptionalFields)
    -> UpdateProjectColumnInput
buildUpdateProjectColumnInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateProjectColumnInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateProjectColumnInputRequiredFields =
    { filter : ProjectColumnFilter }


type alias UpdateProjectColumnInputOptionalFields =
    { set : OptionalArgument ProjectColumnPatch
    , remove : OptionalArgument ProjectColumnPatch
    }


{-| Type alias for the `UpdateProjectColumnInput` attributes. Note that this type
needs to use the `UpdateProjectColumnInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateProjectColumnInputRaw =
    { filter : ProjectColumnFilter
    , set : OptionalArgument ProjectColumnPatch
    , remove : OptionalArgument ProjectColumnPatch
    }


{-| Type for the UpdateProjectColumnInput input object.
-}
type UpdateProjectColumnInput
    = UpdateProjectColumnInput UpdateProjectColumnInputRaw


{-| Encode a UpdateProjectColumnInput into a value that can be used as an argument.
-}
encodeUpdateProjectColumnInput : UpdateProjectColumnInput -> Value
encodeUpdateProjectColumnInput (UpdateProjectColumnInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeProjectColumnFilter input____.filter |> Just ), ( "set", encodeProjectColumnPatch |> Encode.optional input____.set ), ( "remove", encodeProjectColumnPatch |> Encode.optional input____.remove ) ]


buildUpdateProjectFieldInput :
    UpdateProjectFieldInputRequiredFields
    -> (UpdateProjectFieldInputOptionalFields -> UpdateProjectFieldInputOptionalFields)
    -> UpdateProjectFieldInput
buildUpdateProjectFieldInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateProjectFieldInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateProjectFieldInputRequiredFields =
    { filter : ProjectFieldFilter }


type alias UpdateProjectFieldInputOptionalFields =
    { set : OptionalArgument ProjectFieldPatch
    , remove : OptionalArgument ProjectFieldPatch
    }


{-| Type alias for the `UpdateProjectFieldInput` attributes. Note that this type
needs to use the `UpdateProjectFieldInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateProjectFieldInputRaw =
    { filter : ProjectFieldFilter
    , set : OptionalArgument ProjectFieldPatch
    , remove : OptionalArgument ProjectFieldPatch
    }


{-| Type for the UpdateProjectFieldInput input object.
-}
type UpdateProjectFieldInput
    = UpdateProjectFieldInput UpdateProjectFieldInputRaw


{-| Encode a UpdateProjectFieldInput into a value that can be used as an argument.
-}
encodeUpdateProjectFieldInput : UpdateProjectFieldInput -> Value
encodeUpdateProjectFieldInput (UpdateProjectFieldInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeProjectFieldFilter input____.filter |> Just ), ( "set", encodeProjectFieldPatch |> Encode.optional input____.set ), ( "remove", encodeProjectFieldPatch |> Encode.optional input____.remove ) ]


buildUpdateProjectFieldValueInput :
    UpdateProjectFieldValueInputRequiredFields
    -> (UpdateProjectFieldValueInputOptionalFields -> UpdateProjectFieldValueInputOptionalFields)
    -> UpdateProjectFieldValueInput
buildUpdateProjectFieldValueInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateProjectFieldValueInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateProjectFieldValueInputRequiredFields =
    { filter : ProjectFieldValueFilter }


type alias UpdateProjectFieldValueInputOptionalFields =
    { set : OptionalArgument ProjectFieldValuePatch
    , remove : OptionalArgument ProjectFieldValuePatch
    }


{-| Type alias for the `UpdateProjectFieldValueInput` attributes. Note that this type
needs to use the `UpdateProjectFieldValueInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateProjectFieldValueInputRaw =
    { filter : ProjectFieldValueFilter
    , set : OptionalArgument ProjectFieldValuePatch
    , remove : OptionalArgument ProjectFieldValuePatch
    }


{-| Type for the UpdateProjectFieldValueInput input object.
-}
type UpdateProjectFieldValueInput
    = UpdateProjectFieldValueInput UpdateProjectFieldValueInputRaw


{-| Encode a UpdateProjectFieldValueInput into a value that can be used as an argument.
-}
encodeUpdateProjectFieldValueInput : UpdateProjectFieldValueInput -> Value
encodeUpdateProjectFieldValueInput (UpdateProjectFieldValueInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeProjectFieldValueFilter input____.filter |> Just ), ( "set", encodeProjectFieldValuePatch |> Encode.optional input____.set ), ( "remove", encodeProjectFieldValuePatch |> Encode.optional input____.remove ) ]


buildUpdateProjectInput :
    UpdateProjectInputRequiredFields
    -> (UpdateProjectInputOptionalFields -> UpdateProjectInputOptionalFields)
    -> UpdateProjectInput
buildUpdateProjectInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateProjectInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateProjectInputRequiredFields =
    { filter : ProjectFilter }


type alias UpdateProjectInputOptionalFields =
    { set : OptionalArgument ProjectPatch
    , remove : OptionalArgument ProjectPatch
    }


{-| Type alias for the `UpdateProjectInput` attributes. Note that this type
needs to use the `UpdateProjectInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateProjectInputRaw =
    { filter : ProjectFilter
    , set : OptionalArgument ProjectPatch
    , remove : OptionalArgument ProjectPatch
    }


{-| Type for the UpdateProjectInput input object.
-}
type UpdateProjectInput
    = UpdateProjectInput UpdateProjectInputRaw


{-| Encode a UpdateProjectInput into a value that can be used as an argument.
-}
encodeUpdateProjectInput : UpdateProjectInput -> Value
encodeUpdateProjectInput (UpdateProjectInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeProjectFilter input____.filter |> Just ), ( "set", encodeProjectPatch |> Encode.optional input____.set ), ( "remove", encodeProjectPatch |> Encode.optional input____.remove ) ]


buildUpdateProjectTensionInput :
    UpdateProjectTensionInputRequiredFields
    -> (UpdateProjectTensionInputOptionalFields -> UpdateProjectTensionInputOptionalFields)
    -> UpdateProjectTensionInput
buildUpdateProjectTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateProjectTensionInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateProjectTensionInputRequiredFields =
    { filter : ProjectTensionFilter }


type alias UpdateProjectTensionInputOptionalFields =
    { set : OptionalArgument ProjectTensionPatch
    , remove : OptionalArgument ProjectTensionPatch
    }


{-| Type alias for the `UpdateProjectTensionInput` attributes. Note that this type
needs to use the `UpdateProjectTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateProjectTensionInputRaw =
    { filter : ProjectTensionFilter
    , set : OptionalArgument ProjectTensionPatch
    , remove : OptionalArgument ProjectTensionPatch
    }


{-| Type for the UpdateProjectTensionInput input object.
-}
type UpdateProjectTensionInput
    = UpdateProjectTensionInput UpdateProjectTensionInputRaw


{-| Encode a UpdateProjectTensionInput into a value that can be used as an argument.
-}
encodeUpdateProjectTensionInput : UpdateProjectTensionInput -> Value
encodeUpdateProjectTensionInput (UpdateProjectTensionInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeProjectTensionFilter input____.filter |> Just ), ( "set", encodeProjectTensionPatch |> Encode.optional input____.set ), ( "remove", encodeProjectTensionPatch |> Encode.optional input____.remove ) ]


buildUpdateReactionInput :
    UpdateReactionInputRequiredFields
    -> (UpdateReactionInputOptionalFields -> UpdateReactionInputOptionalFields)
    -> UpdateReactionInput
buildUpdateReactionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateReactionInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateReactionInputRequiredFields =
    { filter : ReactionFilter }


type alias UpdateReactionInputOptionalFields =
    { set : OptionalArgument ReactionPatch
    , remove : OptionalArgument ReactionPatch
    }


{-| Type alias for the `UpdateReactionInput` attributes. Note that this type
needs to use the `UpdateReactionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateReactionInputRaw =
    { filter : ReactionFilter
    , set : OptionalArgument ReactionPatch
    , remove : OptionalArgument ReactionPatch
    }


{-| Type for the UpdateReactionInput input object.
-}
type UpdateReactionInput
    = UpdateReactionInput UpdateReactionInputRaw


{-| Encode a UpdateReactionInput into a value that can be used as an argument.
-}
encodeUpdateReactionInput : UpdateReactionInput -> Value
encodeUpdateReactionInput (UpdateReactionInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeReactionFilter input____.filter |> Just ), ( "set", encodeReactionPatch |> Encode.optional input____.set ), ( "remove", encodeReactionPatch |> Encode.optional input____.remove ) ]


buildUpdateRoleExtInput :
    UpdateRoleExtInputRequiredFields
    -> (UpdateRoleExtInputOptionalFields -> UpdateRoleExtInputOptionalFields)
    -> UpdateRoleExtInput
buildUpdateRoleExtInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateRoleExtInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateRoleExtInputRequiredFields =
    { filter : RoleExtFilter }


type alias UpdateRoleExtInputOptionalFields =
    { set : OptionalArgument RoleExtPatch
    , remove : OptionalArgument RoleExtPatch
    }


{-| Type alias for the `UpdateRoleExtInput` attributes. Note that this type
needs to use the `UpdateRoleExtInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateRoleExtInputRaw =
    { filter : RoleExtFilter
    , set : OptionalArgument RoleExtPatch
    , remove : OptionalArgument RoleExtPatch
    }


{-| Type for the UpdateRoleExtInput input object.
-}
type UpdateRoleExtInput
    = UpdateRoleExtInput UpdateRoleExtInputRaw


{-| Encode a UpdateRoleExtInput into a value that can be used as an argument.
-}
encodeUpdateRoleExtInput : UpdateRoleExtInput -> Value
encodeUpdateRoleExtInput (UpdateRoleExtInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeRoleExtFilter input____.filter |> Just ), ( "set", encodeRoleExtPatch |> Encode.optional input____.set ), ( "remove", encodeRoleExtPatch |> Encode.optional input____.remove ) ]


buildUpdateTensionInput :
    UpdateTensionInputRequiredFields
    -> (UpdateTensionInputOptionalFields -> UpdateTensionInputOptionalFields)
    -> UpdateTensionInput
buildUpdateTensionInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateTensionInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateTensionInputRequiredFields =
    { filter : TensionFilter }


type alias UpdateTensionInputOptionalFields =
    { set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type alias for the `UpdateTensionInput` attributes. Note that this type
needs to use the `UpdateTensionInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateTensionInputRaw =
    { filter : TensionFilter
    , set : OptionalArgument TensionPatch
    , remove : OptionalArgument TensionPatch
    }


{-| Type for the UpdateTensionInput input object.
-}
type UpdateTensionInput
    = UpdateTensionInput UpdateTensionInputRaw


{-| Encode a UpdateTensionInput into a value that can be used as an argument.
-}
encodeUpdateTensionInput : UpdateTensionInput -> Value
encodeUpdateTensionInput (UpdateTensionInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeTensionFilter input____.filter |> Just ), ( "set", encodeTensionPatch |> Encode.optional input____.set ), ( "remove", encodeTensionPatch |> Encode.optional input____.remove ) ]


buildUpdateUserEventInput :
    UpdateUserEventInputRequiredFields
    -> (UpdateUserEventInputOptionalFields -> UpdateUserEventInputOptionalFields)
    -> UpdateUserEventInput
buildUpdateUserEventInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserEventInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserEventInputRequiredFields =
    { filter : UserEventFilter }


type alias UpdateUserEventInputOptionalFields =
    { set : OptionalArgument UserEventPatch
    , remove : OptionalArgument UserEventPatch
    }


{-| Type alias for the `UpdateUserEventInput` attributes. Note that this type
needs to use the `UpdateUserEventInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserEventInputRaw =
    { filter : UserEventFilter
    , set : OptionalArgument UserEventPatch
    , remove : OptionalArgument UserEventPatch
    }


{-| Type for the UpdateUserEventInput input object.
-}
type UpdateUserEventInput
    = UpdateUserEventInput UpdateUserEventInputRaw


{-| Encode a UpdateUserEventInput into a value that can be used as an argument.
-}
encodeUpdateUserEventInput : UpdateUserEventInput -> Value
encodeUpdateUserEventInput (UpdateUserEventInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserEventFilter input____.filter |> Just ), ( "set", encodeUserEventPatch |> Encode.optional input____.set ), ( "remove", encodeUserEventPatch |> Encode.optional input____.remove ) ]


buildUpdateUserInput :
    UpdateUserInputRequiredFields
    -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields)
    -> UpdateUserInput
buildUpdateUserInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserInputRequiredFields =
    { filter : UserFilter }


type alias UpdateUserInputOptionalFields =
    { set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type alias for the `UpdateUserInput` attributes. Note that this type
needs to use the `UpdateUserInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserInputRaw =
    { filter : UserFilter
    , set : OptionalArgument UserPatch
    , remove : OptionalArgument UserPatch
    }


{-| Type for the UpdateUserInput input object.
-}
type UpdateUserInput
    = UpdateUserInput UpdateUserInputRaw


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput (UpdateUserInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserFilter input____.filter |> Just ), ( "set", encodeUserPatch |> Encode.optional input____.set ), ( "remove", encodeUserPatch |> Encode.optional input____.remove ) ]


buildUpdateUserRightsInput :
    UpdateUserRightsInputRequiredFields
    -> (UpdateUserRightsInputOptionalFields -> UpdateUserRightsInputOptionalFields)
    -> UpdateUserRightsInput
buildUpdateUserRightsInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateUserRightsInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateUserRightsInputRequiredFields =
    { filter : UserRightsFilter }


type alias UpdateUserRightsInputOptionalFields =
    { set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type alias for the `UpdateUserRightsInput` attributes. Note that this type
needs to use the `UpdateUserRightsInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateUserRightsInputRaw =
    { filter : UserRightsFilter
    , set : OptionalArgument UserRightsPatch
    , remove : OptionalArgument UserRightsPatch
    }


{-| Type for the UpdateUserRightsInput input object.
-}
type UpdateUserRightsInput
    = UpdateUserRightsInput UpdateUserRightsInputRaw


{-| Encode a UpdateUserRightsInput into a value that can be used as an argument.
-}
encodeUpdateUserRightsInput : UpdateUserRightsInput -> Value
encodeUpdateUserRightsInput (UpdateUserRightsInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeUserRightsFilter input____.filter |> Just ), ( "set", encodeUserRightsPatch |> Encode.optional input____.set ), ( "remove", encodeUserRightsPatch |> Encode.optional input____.remove ) ]


buildUpdateVoteInput :
    UpdateVoteInputRequiredFields
    -> (UpdateVoteInputOptionalFields -> UpdateVoteInputOptionalFields)
    -> UpdateVoteInput
buildUpdateVoteInput required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set = Absent, remove = Absent }
    in
    UpdateVoteInput { filter = required____.filter, set = optionals____.set, remove = optionals____.remove }


type alias UpdateVoteInputRequiredFields =
    { filter : VoteFilter }


type alias UpdateVoteInputOptionalFields =
    { set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type alias for the `UpdateVoteInput` attributes. Note that this type
needs to use the `UpdateVoteInput` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UpdateVoteInputRaw =
    { filter : VoteFilter
    , set : OptionalArgument VotePatch
    , remove : OptionalArgument VotePatch
    }


{-| Type for the UpdateVoteInput input object.
-}
type UpdateVoteInput
    = UpdateVoteInput UpdateVoteInputRaw


{-| Encode a UpdateVoteInput into a value that can be used as an argument.
-}
encodeUpdateVoteInput : UpdateVoteInput -> Value
encodeUpdateVoteInput (UpdateVoteInput input____) =
    Encode.maybeObject
        [ ( "filter", encodeVoteFilter input____.filter |> Just ), ( "set", encodeVotePatch |> Encode.optional input____.set ), ( "remove", encodeVotePatch |> Encode.optional input____.remove ) ]


buildUserEventFilter :
    (UserEventFilterOptionalFields -> UserEventFilterOptionalFields)
    -> UserEventFilter
buildUserEventFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, isRead = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserEventFilter { id = optionals____.id, createdAt = optionals____.createdAt, isRead = optionals____.isRead, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserEventFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , isRead : OptionalArgument Bool
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserEventHasFilter.UserEventHasFilter))
    , and : OptionalArgument (List (Maybe UserEventFilter))
    , or : OptionalArgument (List (Maybe UserEventFilter))
    , not : OptionalArgument UserEventFilter
    }


{-| Type alias for the `UserEventFilter` attributes. Note that this type
needs to use the `UserEventFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , isRead : OptionalArgument Bool
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserEventHasFilter.UserEventHasFilter))
    , and : OptionalArgument (List (Maybe UserEventFilter))
    , or : OptionalArgument (List (Maybe UserEventFilter))
    , not : OptionalArgument UserEventFilter
    }


{-| Type for the UserEventFilter input object.
-}
type UserEventFilter
    = UserEventFilter UserEventFilterRaw


{-| Encode a UserEventFilter into a value that can be used as an argument.
-}
encodeUserEventFilter : UserEventFilter -> Value
encodeUserEventFilter (UserEventFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "has", (Encode.enum Fractal.Enum.UserEventHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserEventFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserEventFilter |> Encode.optional input____.not ) ]


buildUserEventOrder :
    (UserEventOrderOptionalFields -> UserEventOrderOptionalFields)
    -> UserEventOrder
buildUserEventOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserEventOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserEventOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , desc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , then_ : OptionalArgument UserEventOrder
    }


{-| Type alias for the `UserEventOrder` attributes. Note that this type
needs to use the `UserEventOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , desc : OptionalArgument Fractal.Enum.UserEventOrderable.UserEventOrderable
    , then_ : OptionalArgument UserEventOrder
    }


{-| Type for the UserEventOrder input object.
-}
type UserEventOrder
    = UserEventOrder UserEventOrderRaw


{-| Encode a UserEventOrder into a value that can be used as an argument.
-}
encodeUserEventOrder : UserEventOrder -> Value
encodeUserEventOrder (UserEventOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserEventOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserEventOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserEventOrder |> Encode.optional input____.then_ ) ]


buildUserEventPatch :
    (UserEventPatchOptionalFields -> UserEventPatchOptionalFields)
    -> UserEventPatch
buildUserEventPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, isRead = Absent, user = Absent, event = Absent }
    in
    UserEventPatch { createdAt = optionals____.createdAt, isRead = optionals____.isRead, user = optionals____.user, event = optionals____.event }


type alias UserEventPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument (List EventKindRef)
    }


{-| Type alias for the `UserEventPatch` attributes. Note that this type
needs to use the `UserEventPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument (List EventKindRef)
    }


{-| Type for the UserEventPatch input object.
-}
type UserEventPatch
    = UserEventPatch UserEventPatchRaw


{-| Encode a UserEventPatch into a value that can be used as an argument.
-}
encodeUserEventPatch : UserEventPatch -> Value
encodeUserEventPatch (UserEventPatch input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "user", encodeUserRef |> Encode.optional input____.user ), ( "event", (encodeEventKindRef |> Encode.list) |> Encode.optional input____.event ) ]


buildUserEventRef :
    (UserEventRefOptionalFields -> UserEventRefOptionalFields)
    -> UserEventRef
buildUserEventRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, isRead = Absent, user = Absent, event = Absent }
    in
    UserEventRef { id = optionals____.id, createdAt = optionals____.createdAt, isRead = optionals____.isRead, user = optionals____.user, event = optionals____.event }


type alias UserEventRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument (List EventKindRef)
    }


{-| Type alias for the `UserEventRef` attributes. Note that this type
needs to use the `UserEventRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserEventRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , isRead : OptionalArgument Bool
    , user : OptionalArgument UserRef
    , event : OptionalArgument (List EventKindRef)
    }


{-| Type for the UserEventRef input object.
-}
type UserEventRef
    = UserEventRef UserEventRefRaw


{-| Encode a UserEventRef into a value that can be used as an argument.
-}
encodeUserEventRef : UserEventRef -> Value
encodeUserEventRef (UserEventRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "isRead", Encode.bool |> Encode.optional input____.isRead ), ( "user", encodeUserRef |> Encode.optional input____.user ), ( "event", (encodeEventKindRef |> Encode.list) |> Encode.optional input____.event ) ]


buildUserFilter :
    (UserFilterOptionalFields -> UserFilterOptionalFields)
    -> UserFilter
buildUserFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, username = Absent, name = Absent, email = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserFilter { id = optionals____.id, username = optionals____.username, name = optionals____.name, email = optionals____.email, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringRegExpFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type alias for the `UserFilter` attributes. Note that this type
needs to use the `UserFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , username : OptionalArgument StringHashFilter_StringRegExpFilter
    , name : OptionalArgument StringRegExpFilter
    , email : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.UserHasFilter.UserHasFilter))
    , and : OptionalArgument (List (Maybe UserFilter))
    , or : OptionalArgument (List (Maybe UserFilter))
    , not : OptionalArgument UserFilter
    }


{-| Type for the UserFilter input object.
-}
type UserFilter
    = UserFilter UserFilterRaw


{-| Encode a UserFilter into a value that can be used as an argument.
-}
encodeUserFilter : UserFilter -> Value
encodeUserFilter (UserFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "username", encodeStringHashFilter_StringRegExpFilter |> Encode.optional input____.username ), ( "name", encodeStringRegExpFilter |> Encode.optional input____.name ), ( "email", encodeStringHashFilter |> Encode.optional input____.email ), ( "has", (Encode.enum Fractal.Enum.UserHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserFilter |> Encode.optional input____.not ) ]


buildUserOrder :
    (UserOrderOptionalFields -> UserOrderOptionalFields)
    -> UserOrder
buildUserOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type alias for the `UserOrder` attributes. Note that this type
needs to use the `UserOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , desc : OptionalArgument Fractal.Enum.UserOrderable.UserOrderable
    , then_ : OptionalArgument UserOrder
    }


{-| Type for the UserOrder input object.
-}
type UserOrder
    = UserOrder UserOrderRaw


{-| Encode a UserOrder into a value that can be used as an argument.
-}
encodeUserOrder : UserOrder -> Value
encodeUserOrder (UserOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserOrder |> Encode.optional input____.then_ ) ]


buildUserPatch :
    (UserPatchOptionalFields -> UserPatchOptionalFields)
    -> UserPatch
buildUserPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdAt = Absent, lastAck = Absent, name = Absent, password = Absent, bio = Absent, location = Absent, utc = Absent, links = Absent, skills = Absent, notifyByEmail = Absent, lang = Absent, subscriptions = Absent, watching = Absent, rights = Absent, roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, reactions = Absent, events = Absent, markAllAsRead = Absent, event_count = Absent }
    in
    UserPatch { createdAt = optionals____.createdAt, lastAck = optionals____.lastAck, name = optionals____.name, password = optionals____.password, bio = optionals____.bio, location = optionals____.location, utc = optionals____.utc, links = optionals____.links, skills = optionals____.skills, notifyByEmail = optionals____.notifyByEmail, lang = optionals____.lang, subscriptions = optionals____.subscriptions, watching = optionals____.watching, rights = optionals____.rights, roles = optionals____.roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, reactions = optionals____.reactions, events = optionals____.events, markAllAsRead = optionals____.markAllAsRead, event_count = optionals____.event_count }


type alias UserPatchOptionalFields =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , notifyByEmail : OptionalArgument Bool
    , lang : OptionalArgument Fractal.Enum.Lang.Lang
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type alias for the `UserPatch` attributes. Note that this type
needs to use the `UserPatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserPatchRaw =
    { createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , name : OptionalArgument String
    , password : OptionalArgument String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , notifyByEmail : OptionalArgument Bool
    , lang : OptionalArgument Fractal.Enum.Lang.Lang
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type for the UserPatch input object.
-}
type UserPatch
    = UserPatch UserPatchRaw


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch (UserPatch input____) =
    Encode.maybeObject
        [ ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lastAck ), ( "name", Encode.string |> Encode.optional input____.name ), ( "password", Encode.string |> Encode.optional input____.password ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "location", Encode.string |> Encode.optional input____.location ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "links", (Encode.string |> Encode.list) |> Encode.optional input____.links ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "notifyByEmail", Encode.bool |> Encode.optional input____.notifyByEmail ), ( "lang", Encode.enum Fractal.Enum.Lang.toString |> Encode.optional input____.lang ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "watching", (encodeNodeRef |> Encode.list) |> Encode.optional input____.watching ), ( "rights", encodeUserRightsRef |> Encode.optional input____.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ), ( "markAllAsRead", Encode.string |> Encode.optional input____.markAllAsRead ), ( "event_count", encodeEventCountRef |> Encode.optional input____.event_count ) ]


buildUserRef :
    (UserRefOptionalFields -> UserRefOptionalFields)
    -> UserRef
buildUserRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, lastAck = Absent, username = Absent, name = Absent, email = Absent, password = Absent, bio = Absent, location = Absent, utc = Absent, links = Absent, skills = Absent, notifyByEmail = Absent, lang = Absent, subscriptions = Absent, watching = Absent, rights = Absent, roles = Absent, tensions_created = Absent, tensions_assigned = Absent, contracts = Absent, reactions = Absent, events = Absent, markAllAsRead = Absent, event_count = Absent }
    in
    UserRef { id = optionals____.id, createdAt = optionals____.createdAt, lastAck = optionals____.lastAck, username = optionals____.username, name = optionals____.name, email = optionals____.email, password = optionals____.password, bio = optionals____.bio, location = optionals____.location, utc = optionals____.utc, links = optionals____.links, skills = optionals____.skills, notifyByEmail = optionals____.notifyByEmail, lang = optionals____.lang, subscriptions = optionals____.subscriptions, watching = optionals____.watching, rights = optionals____.rights, roles = optionals____.roles, tensions_created = optionals____.tensions_created, tensions_assigned = optionals____.tensions_assigned, contracts = optionals____.contracts, reactions = optionals____.reactions, events = optionals____.events, markAllAsRead = optionals____.markAllAsRead, event_count = optionals____.event_count }


type alias UserRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , email : OptionalArgument String
    , password : OptionalArgument String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , notifyByEmail : OptionalArgument Bool
    , lang : OptionalArgument Fractal.Enum.Lang.Lang
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type alias for the `UserRef` attributes. Note that this type
needs to use the `UserRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , lastAck : OptionalArgument Fractal.ScalarCodecs.DateTime
    , username : OptionalArgument String
    , name : OptionalArgument String
    , email : OptionalArgument String
    , password : OptionalArgument String
    , bio : OptionalArgument String
    , location : OptionalArgument String
    , utc : OptionalArgument String
    , links : OptionalArgument (List String)
    , skills : OptionalArgument (List String)
    , notifyByEmail : OptionalArgument Bool
    , lang : OptionalArgument Fractal.Enum.Lang.Lang
    , subscriptions : OptionalArgument (List TensionRef)
    , watching : OptionalArgument (List NodeRef)
    , rights : OptionalArgument UserRightsRef
    , roles : OptionalArgument (List NodeRef)
    , tensions_created : OptionalArgument (List TensionRef)
    , tensions_assigned : OptionalArgument (List TensionRef)
    , contracts : OptionalArgument (List ContractRef)
    , reactions : OptionalArgument (List ReactionRef)
    , events : OptionalArgument (List UserEventRef)
    , markAllAsRead : OptionalArgument String
    , event_count : OptionalArgument EventCountRef
    }


{-| Type for the UserRef input object.
-}
type UserRef
    = UserRef UserRefRaw


{-| Encode a UserRef into a value that can be used as an argument.
-}
encodeUserRef : UserRef -> Value
encodeUserRef (UserRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "lastAck", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.lastAck ), ( "username", Encode.string |> Encode.optional input____.username ), ( "name", Encode.string |> Encode.optional input____.name ), ( "email", Encode.string |> Encode.optional input____.email ), ( "password", Encode.string |> Encode.optional input____.password ), ( "bio", Encode.string |> Encode.optional input____.bio ), ( "location", Encode.string |> Encode.optional input____.location ), ( "utc", Encode.string |> Encode.optional input____.utc ), ( "links", (Encode.string |> Encode.list) |> Encode.optional input____.links ), ( "skills", (Encode.string |> Encode.list) |> Encode.optional input____.skills ), ( "notifyByEmail", Encode.bool |> Encode.optional input____.notifyByEmail ), ( "lang", Encode.enum Fractal.Enum.Lang.toString |> Encode.optional input____.lang ), ( "subscriptions", (encodeTensionRef |> Encode.list) |> Encode.optional input____.subscriptions ), ( "watching", (encodeNodeRef |> Encode.list) |> Encode.optional input____.watching ), ( "rights", encodeUserRightsRef |> Encode.optional input____.rights ), ( "roles", (encodeNodeRef |> Encode.list) |> Encode.optional input____.roles ), ( "tensions_created", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_created ), ( "tensions_assigned", (encodeTensionRef |> Encode.list) |> Encode.optional input____.tensions_assigned ), ( "contracts", (encodeContractRef |> Encode.list) |> Encode.optional input____.contracts ), ( "reactions", (encodeReactionRef |> Encode.list) |> Encode.optional input____.reactions ), ( "events", (encodeUserEventRef |> Encode.list) |> Encode.optional input____.events ), ( "markAllAsRead", Encode.string |> Encode.optional input____.markAllAsRead ), ( "event_count", encodeEventCountRef |> Encode.optional input____.event_count ) ]


buildUserRightsFilter :
    (UserRightsFilterOptionalFields -> UserRightsFilterOptionalFields)
    -> UserRightsFilter
buildUserRightsFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { has = Absent, and = Absent, or = Absent, not = Absent }
    in
    UserRightsFilter { has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias UserRightsFilterOptionalFields =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type alias for the `UserRightsFilter` attributes. Note that this type
needs to use the `UserRightsFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsFilterRaw =
    { has : OptionalArgument (List (Maybe Fractal.Enum.UserRightsHasFilter.UserRightsHasFilter))
    , and : OptionalArgument (List (Maybe UserRightsFilter))
    , or : OptionalArgument (List (Maybe UserRightsFilter))
    , not : OptionalArgument UserRightsFilter
    }


{-| Type for the UserRightsFilter input object.
-}
type UserRightsFilter
    = UserRightsFilter UserRightsFilterRaw


{-| Encode a UserRightsFilter into a value that can be used as an argument.
-}
encodeUserRightsFilter : UserRightsFilter -> Value
encodeUserRightsFilter (UserRightsFilter input____) =
    Encode.maybeObject
        [ ( "has", (Encode.enum Fractal.Enum.UserRightsHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeUserRightsFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeUserRightsFilter |> Encode.optional input____.not ) ]


buildUserRightsOrder :
    (UserRightsOrderOptionalFields -> UserRightsOrderOptionalFields)
    -> UserRightsOrder
buildUserRightsOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    UserRightsOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias UserRightsOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type alias for the `UserRightsOrder` attributes. Note that this type
needs to use the `UserRightsOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias UserRightsOrderRaw =
    { asc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , desc : OptionalArgument Fractal.Enum.UserRightsOrderable.UserRightsOrderable
    , then_ : OptionalArgument UserRightsOrder
    }


{-| Type for the UserRightsOrder input object.
-}
type UserRightsOrder
    = UserRightsOrder UserRightsOrderRaw


{-| Encode a UserRightsOrder into a value that can be used as an argument.
-}
encodeUserRightsOrder : UserRightsOrder -> Value
encodeUserRightsOrder (UserRightsOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.UserRightsOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeUserRightsOrder |> Encode.optional input____.then_ ) ]


buildUserRightsPatch :
    (UserRightsPatchOptionalFields -> UserRightsPatchOptionalFields)
    -> UserRightsPatch
buildUserRightsPatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { type_ = Absent, canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, maxPrivateOrga = Absent, hasEmailNotifications = Absent }
    in
    { type_ = optionals____.type_, canLogin = optionals____.canLogin, canCreateRoot = optionals____.canCreateRoot, maxPublicOrga = optionals____.maxPublicOrga, maxPrivateOrga = optionals____.maxPrivateOrga, hasEmailNotifications = optionals____.hasEmailNotifications }


type alias UserRightsPatchOptionalFields =
    { type_ : OptionalArgument Fractal.Enum.UserType.UserType
    , canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , maxPrivateOrga : OptionalArgument Int
    , hasEmailNotifications : OptionalArgument Bool
    }


{-| Type for the UserRightsPatch input object.
-}
type alias UserRightsPatch =
    { type_ : OptionalArgument Fractal.Enum.UserType.UserType
    , canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , maxPrivateOrga : OptionalArgument Int
    , hasEmailNotifications : OptionalArgument Bool
    }


{-| Encode a UserRightsPatch into a value that can be used as an argument.
-}
encodeUserRightsPatch : UserRightsPatch -> Value
encodeUserRightsPatch input____ =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input____.type_ ), ( "canLogin", Encode.bool |> Encode.optional input____.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input____.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input____.maxPublicOrga ), ( "maxPrivateOrga", Encode.int |> Encode.optional input____.maxPrivateOrga ), ( "hasEmailNotifications", Encode.bool |> Encode.optional input____.hasEmailNotifications ) ]


buildUserRightsRef :
    (UserRightsRefOptionalFields -> UserRightsRefOptionalFields)
    -> UserRightsRef
buildUserRightsRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { type_ = Absent, canLogin = Absent, canCreateRoot = Absent, maxPublicOrga = Absent, maxPrivateOrga = Absent, hasEmailNotifications = Absent }
    in
    { type_ = optionals____.type_, canLogin = optionals____.canLogin, canCreateRoot = optionals____.canCreateRoot, maxPublicOrga = optionals____.maxPublicOrga, maxPrivateOrga = optionals____.maxPrivateOrga, hasEmailNotifications = optionals____.hasEmailNotifications }


type alias UserRightsRefOptionalFields =
    { type_ : OptionalArgument Fractal.Enum.UserType.UserType
    , canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , maxPrivateOrga : OptionalArgument Int
    , hasEmailNotifications : OptionalArgument Bool
    }


{-| Type for the UserRightsRef input object.
-}
type alias UserRightsRef =
    { type_ : OptionalArgument Fractal.Enum.UserType.UserType
    , canLogin : OptionalArgument Bool
    , canCreateRoot : OptionalArgument Bool
    , maxPublicOrga : OptionalArgument Int
    , maxPrivateOrga : OptionalArgument Int
    , hasEmailNotifications : OptionalArgument Bool
    }


{-| Encode a UserRightsRef into a value that can be used as an argument.
-}
encodeUserRightsRef : UserRightsRef -> Value
encodeUserRightsRef input____ =
    Encode.maybeObject
        [ ( "type_", Encode.enum Fractal.Enum.UserType.toString |> Encode.optional input____.type_ ), ( "canLogin", Encode.bool |> Encode.optional input____.canLogin ), ( "canCreateRoot", Encode.bool |> Encode.optional input____.canCreateRoot ), ( "maxPublicOrga", Encode.int |> Encode.optional input____.maxPublicOrga ), ( "maxPrivateOrga", Encode.int |> Encode.optional input____.maxPrivateOrga ), ( "hasEmailNotifications", Encode.bool |> Encode.optional input____.hasEmailNotifications ) ]


buildVoteFilter :
    (VoteFilterOptionalFields -> VoteFilterOptionalFields)
    -> VoteFilter
buildVoteFilter fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdAt = Absent, message = Absent, voteid = Absent, has = Absent, and = Absent, or = Absent, not = Absent }
    in
    VoteFilter { id = optionals____.id, createdAt = optionals____.createdAt, message = optionals____.message, voteid = optionals____.voteid, has = optionals____.has, and = optionals____.and, or = optionals____.or, not = optionals____.not }


type alias VoteFilterOptionalFields =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type alias for the `VoteFilter` attributes. Note that this type
needs to use the `VoteFilter` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteFilterRaw =
    { id : OptionalArgument (List Fractal.ScalarCodecs.Id)
    , createdAt : OptionalArgument DateTimeFilter
    , message : OptionalArgument StringFullTextFilter
    , voteid : OptionalArgument StringHashFilter
    , has : OptionalArgument (List (Maybe Fractal.Enum.VoteHasFilter.VoteHasFilter))
    , and : OptionalArgument (List (Maybe VoteFilter))
    , or : OptionalArgument (List (Maybe VoteFilter))
    , not : OptionalArgument VoteFilter
    }


{-| Type for the VoteFilter input object.
-}
type VoteFilter
    = VoteFilter VoteFilterRaw


{-| Encode a VoteFilter into a value that can be used as an argument.
-}
encodeVoteFilter : VoteFilter -> Value
encodeVoteFilter (VoteFilter input____) =
    Encode.maybeObject
        [ ( "id", ((Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.list) |> Encode.optional input____.id ), ( "createdAt", encodeDateTimeFilter |> Encode.optional input____.createdAt ), ( "message", encodeStringFullTextFilter |> Encode.optional input____.message ), ( "voteid", encodeStringHashFilter |> Encode.optional input____.voteid ), ( "has", (Encode.enum Fractal.Enum.VoteHasFilter.toString |> Encode.maybe |> Encode.list) |> Encode.optional input____.has ), ( "and", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.and ), ( "or", (encodeVoteFilter |> Encode.maybe |> Encode.list) |> Encode.optional input____.or ), ( "not", encodeVoteFilter |> Encode.optional input____.not ) ]


buildVoteOrder :
    (VoteOrderOptionalFields -> VoteOrderOptionalFields)
    -> VoteOrder
buildVoteOrder fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { asc = Absent, desc = Absent, then_ = Absent }
    in
    VoteOrder { asc = optionals____.asc, desc = optionals____.desc, then_ = optionals____.then_ }


type alias VoteOrderOptionalFields =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type alias for the `VoteOrder` attributes. Note that this type
needs to use the `VoteOrder` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteOrderRaw =
    { asc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , desc : OptionalArgument Fractal.Enum.VoteOrderable.VoteOrderable
    , then_ : OptionalArgument VoteOrder
    }


{-| Type for the VoteOrder input object.
-}
type VoteOrder
    = VoteOrder VoteOrderRaw


{-| Encode a VoteOrder into a value that can be used as an argument.
-}
encodeVoteOrder : VoteOrder -> Value
encodeVoteOrder (VoteOrder input____) =
    Encode.maybeObject
        [ ( "asc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input____.asc ), ( "desc", Encode.enum Fractal.Enum.VoteOrderable.toString |> Encode.optional input____.desc ), ( "then", encodeVoteOrder |> Encode.optional input____.then_ ) ]


buildVotePatch :
    (VotePatchOptionalFields -> VotePatchOptionalFields)
    -> VotePatch
buildVotePatch fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VotePatch { createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, contract = optionals____.contract, node = optionals____.node, data = optionals____.data }


type alias VotePatchOptionalFields =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VotePatch` attributes. Note that this type
needs to use the `VotePatch` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VotePatchRaw =
    { createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VotePatch input object.
-}
type VotePatch
    = VotePatch VotePatchRaw


{-| Encode a VotePatch into a value that can be used as an argument.
-}
encodeVotePatch : VotePatch -> Value
encodeVotePatch (VotePatch input____) =
    Encode.maybeObject
        [ ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "node", encodeNodeRef |> Encode.optional input____.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input____.data ) ]


buildVoteRef :
    (VoteRefOptionalFields -> VoteRefOptionalFields)
    -> VoteRef
buildVoteRef fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, createdBy = Absent, createdAt = Absent, updatedAt = Absent, message = Absent, voteid = Absent, contract = Absent, node = Absent, data = Absent }
    in
    VoteRef { id = optionals____.id, createdBy = optionals____.createdBy, createdAt = optionals____.createdAt, updatedAt = optionals____.updatedAt, message = optionals____.message, voteid = optionals____.voteid, contract = optionals____.contract, node = optionals____.node, data = optionals____.data }


type alias VoteRefOptionalFields =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type alias for the `VoteRef` attributes. Note that this type
needs to use the `VoteRef` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias VoteRefRaw =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , createdBy : OptionalArgument UserRef
    , createdAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , updatedAt : OptionalArgument Fractal.ScalarCodecs.DateTime
    , message : OptionalArgument String
    , voteid : OptionalArgument String
    , contract : OptionalArgument ContractRef
    , node : OptionalArgument NodeRef
    , data : OptionalArgument (List Int)
    }


{-| Type for the VoteRef input object.
-}
type VoteRef
    = VoteRef VoteRefRaw


{-| Encode a VoteRef into a value that can be used as an argument.
-}
encodeVoteRef : VoteRef -> Value
encodeVoteRef (VoteRef input____) =
    Encode.maybeObject
        [ ( "id", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) |> Encode.optional input____.id ), ( "createdBy", encodeUserRef |> Encode.optional input____.createdBy ), ( "createdAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.createdAt ), ( "updatedAt", (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecDateTime) |> Encode.optional input____.updatedAt ), ( "message", Encode.string |> Encode.optional input____.message ), ( "voteid", Encode.string |> Encode.optional input____.voteid ), ( "contract", encodeContractRef |> Encode.optional input____.contract ), ( "node", encodeNodeRef |> Encode.optional input____.node ), ( "data", (Encode.int |> Encode.list) |> Encode.optional input____.data ) ]


buildWithinFilter :
    WithinFilterRequiredFields
    -> WithinFilter
buildWithinFilter required____ =
    { polygon = required____.polygon }


type alias WithinFilterRequiredFields =
    { polygon : PolygonRef }


{-| Type for the WithinFilter input object.
-}
type alias WithinFilter =
    { polygon : PolygonRef }


{-| Encode a WithinFilter into a value that can be used as an argument.
-}
encodeWithinFilter : WithinFilter -> Value
encodeWithinFilter input____ =
    Encode.maybeObject
        [ ( "polygon", encodePolygonRef input____.polygon |> Just ) ]
