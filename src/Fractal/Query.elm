-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.Query exposing (..)

import Fractal.InputObject
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias GetNodeOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , nameid : OptionalArgument String
    }


getNode :
    (GetNodeOptionalArguments -> GetNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
getNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, nameid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "nameid" filledInOptionals____.nameid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryNodeOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryNode :
    (QueryNodeOptionalArguments -> QueryNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateNodeOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


aggregateNode :
    (AggregateNodeOptionalArguments -> AggregateNodeOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateNode fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateNode" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetNodeFragmentRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getNodeFragment :
    GetNodeFragmentRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.NodeFragment
    -> SelectionSet (Maybe decodesTo) RootQuery
getNodeFragment requiredArgs____ object____ =
    Object.selectionForCompositeField "getNodeFragment" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryNodeFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFragmentFilter
    , order : OptionalArgument Fractal.InputObject.NodeFragmentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryNodeFragment :
    (QueryNodeFragmentOptionalArguments -> QueryNodeFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeFragment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryNodeFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFragmentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeFragmentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryNodeFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateNodeFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFragmentFilter }


aggregateNodeFragment :
    (AggregateNodeFragmentOptionalArguments -> AggregateNodeFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeFragmentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateNodeFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFragmentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateNodeFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetMandateRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getMandate :
    GetMandateRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Mandate
    -> SelectionSet (Maybe decodesTo) RootQuery
getMandate requiredArgs____ object____ =
    Object.selectionForCompositeField "getMandate" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryMandateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.MandateFilter
    , order : OptionalArgument Fractal.InputObject.MandateOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryMandate :
    (QueryMandateOptionalArguments -> QueryMandateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Mandate
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryMandate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeMandateFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeMandateOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryMandate" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateMandateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.MandateFilter }


aggregateMandate :
    (AggregateMandateOptionalArguments -> AggregateMandateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.MandateAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateMandate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeMandateFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateMandate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetLabelRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getLabel :
    GetLabelRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Label
    -> SelectionSet (Maybe decodesTo) RootQuery
getLabel requiredArgs____ object____ =
    Object.selectionForCompositeField "getLabel" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryLabelOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.LabelFilter
    , order : OptionalArgument Fractal.InputObject.LabelOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryLabel :
    (QueryLabelOptionalArguments -> QueryLabelOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Label
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryLabel fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeLabelFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeLabelOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryLabel" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateLabelOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.LabelFilter }


aggregateLabel :
    (AggregateLabelOptionalArguments -> AggregateLabelOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.LabelAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateLabel fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeLabelFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateLabel" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetRoleExtRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getRoleExt :
    GetRoleExtRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.RoleExt
    -> SelectionSet (Maybe decodesTo) RootQuery
getRoleExt requiredArgs____ object____ =
    Object.selectionForCompositeField "getRoleExt" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryRoleExtOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.RoleExtFilter
    , order : OptionalArgument Fractal.InputObject.RoleExtOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryRoleExt :
    (QueryRoleExtOptionalArguments -> QueryRoleExtOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.RoleExt
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryRoleExt fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeRoleExtFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeRoleExtOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryRoleExt" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateRoleExtOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.RoleExtFilter }


aggregateRoleExt :
    (AggregateRoleExtOptionalArguments -> AggregateRoleExtOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.RoleExtAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateRoleExt fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeRoleExtFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateRoleExt" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetProjectRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getProject :
    GetProjectRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Project
    -> SelectionSet (Maybe decodesTo) RootQuery
getProject requiredArgs____ object____ =
    Object.selectionForCompositeField "getProject" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFilter
    , order : OptionalArgument Fractal.InputObject.ProjectOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProject :
    (QueryProjectOptionalArguments -> QueryProjectOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Project
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProject fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeProjectOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProject" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFilter }


aggregateProject :
    (AggregateProjectOptionalArguments -> AggregateProjectOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProject fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProject" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetProjectColumnRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getProjectColumn :
    GetProjectColumnRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.ProjectColumn
    -> SelectionSet (Maybe decodesTo) RootQuery
getProjectColumn requiredArgs____ object____ =
    Object.selectionForCompositeField "getProjectColumn" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectColumnOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectColumnFilter
    , order : OptionalArgument Fractal.InputObject.ProjectColumnOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProjectColumn :
    (QueryProjectColumnOptionalArguments -> QueryProjectColumnOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectColumn
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProjectColumn fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectColumnFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeProjectColumnOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProjectColumn" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectColumnOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectColumnFilter }


aggregateProjectColumn :
    (AggregateProjectColumnOptionalArguments -> AggregateProjectColumnOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectColumnAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProjectColumn fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectColumnFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProjectColumn" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetProjectCardRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getProjectCard :
    GetProjectCardRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.ProjectCard
    -> SelectionSet (Maybe decodesTo) RootQuery
getProjectCard requiredArgs____ object____ =
    Object.selectionForCompositeField "getProjectCard" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectCardOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectCardFilter
    , order : OptionalArgument Fractal.InputObject.ProjectCardOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProjectCard :
    (QueryProjectCardOptionalArguments -> QueryProjectCardOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectCard
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProjectCard fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectCardFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeProjectCardOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProjectCard" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectCardOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectCardFilter }


aggregateProjectCard :
    (AggregateProjectCardOptionalArguments -> AggregateProjectCardOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectCardAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProjectCard fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectCardFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProjectCard" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectFieldOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFieldFilter
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProjectField :
    (QueryProjectFieldOptionalArguments -> QueryProjectFieldOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectField
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProjectField fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFieldFilter, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProjectField" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectFieldOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFieldFilter }


aggregateProjectField :
    (AggregateProjectFieldOptionalArguments -> AggregateProjectFieldOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectFieldAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProjectField fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFieldFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProjectField" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectFieldValueOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFieldValueFilter
    , order : OptionalArgument Fractal.InputObject.ProjectFieldValueOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProjectFieldValue :
    (QueryProjectFieldValueOptionalArguments -> QueryProjectFieldValueOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectFieldValue
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProjectFieldValue fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFieldValueFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeProjectFieldValueOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProjectFieldValue" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectFieldValueOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectFieldValueFilter }


aggregateProjectFieldValue :
    (AggregateProjectFieldValueOptionalArguments -> AggregateProjectFieldValueOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectFieldValueAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProjectFieldValue fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectFieldValueFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProjectFieldValue" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetPostRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getPost :
    GetPostRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Post
    -> SelectionSet (Maybe decodesTo) RootQuery
getPost requiredArgs____ object____ =
    Object.selectionForCompositeField "getPost" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryPostOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PostFilter
    , order : OptionalArgument Fractal.InputObject.PostOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryPost :
    (QueryPostOptionalArguments -> QueryPostOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Post
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryPost fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePostFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodePostOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryPost" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregatePostOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PostFilter }


aggregatePost :
    (AggregatePostOptionalArguments -> AggregatePostOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PostAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregatePost fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePostFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregatePost" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetProjectDraftRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getProjectDraft :
    GetProjectDraftRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.ProjectDraft
    -> SelectionSet (Maybe decodesTo) RootQuery
getProjectDraft requiredArgs____ object____ =
    Object.selectionForCompositeField "getProjectDraft" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryProjectDraftOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectDraftFilter
    , order : OptionalArgument Fractal.InputObject.ProjectDraftOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryProjectDraft :
    (QueryProjectDraftOptionalArguments -> QueryProjectDraftOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectDraft
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryProjectDraft fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectDraftFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeProjectDraftOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryProjectDraft" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateProjectDraftOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ProjectDraftFilter }


aggregateProjectDraft :
    (AggregateProjectDraftOptionalArguments -> AggregateProjectDraftOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ProjectDraftAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateProjectDraft fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeProjectDraftFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateProjectDraft" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetTensionRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getTension :
    GetTensionRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe decodesTo) RootQuery
getTension requiredArgs____ object____ =
    Object.selectionForCompositeField "getTension" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryTensionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryTension :
    (QueryTensionOptionalArguments -> QueryTensionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryTension fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryTension" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateTensionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


aggregateTension :
    (AggregateTensionOptionalArguments -> AggregateTensionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateTension fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateTension" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetCommentRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getComment :
    GetCommentRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Comment
    -> SelectionSet (Maybe decodesTo) RootQuery
getComment requiredArgs____ object____ =
    Object.selectionForCompositeField "getComment" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryCommentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.CommentFilter
    , order : OptionalArgument Fractal.InputObject.CommentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryComment :
    (QueryCommentOptionalArguments -> QueryCommentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Comment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryComment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeCommentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeCommentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryComment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateCommentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.CommentFilter }


aggregateComment :
    (AggregateCommentOptionalArguments -> AggregateCommentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.CommentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateComment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeCommentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateComment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetReactionOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , reactionid : OptionalArgument String
    }


getReaction :
    (GetReactionOptionalArguments -> GetReactionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Reaction
    -> SelectionSet (Maybe decodesTo) RootQuery
getReaction fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, reactionid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "reactionid" filledInOptionals____.reactionid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getReaction" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryReactionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ReactionFilter
    , order : OptionalArgument Fractal.InputObject.ReactionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryReaction :
    (QueryReactionOptionalArguments -> QueryReactionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Reaction
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryReaction fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeReactionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeReactionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryReaction" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateReactionOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ReactionFilter }


aggregateReaction :
    (AggregateReactionOptionalArguments -> AggregateReactionOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ReactionAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateReaction fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeReactionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateReaction" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetBlobRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getBlob :
    GetBlobRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Blob
    -> SelectionSet (Maybe decodesTo) RootQuery
getBlob requiredArgs____ object____ =
    Object.selectionForCompositeField "getBlob" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryBlobOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.BlobFilter
    , order : OptionalArgument Fractal.InputObject.BlobOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryBlob :
    (QueryBlobOptionalArguments -> QueryBlobOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Blob
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryBlob fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeBlobFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeBlobOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryBlob" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateBlobOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.BlobFilter }


aggregateBlob :
    (AggregateBlobOptionalArguments -> AggregateBlobOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.BlobAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateBlob fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeBlobFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateBlob" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetEventRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getEvent :
    GetEventRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Event
    -> SelectionSet (Maybe decodesTo) RootQuery
getEvent requiredArgs____ object____ =
    Object.selectionForCompositeField "getEvent" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFilter
    , order : OptionalArgument Fractal.InputObject.EventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryEvent :
    (QueryEventOptionalArguments -> QueryEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Event
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFilter }


aggregateEvent :
    (AggregateEventOptionalArguments -> AggregateEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryEventFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFragmentFilter
    , order : OptionalArgument Fractal.InputObject.EventFragmentOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryEventFragment :
    (QueryEventFragmentOptionalArguments -> QueryEventFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventFragment
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryEventFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFragmentFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeEventFragmentOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryEventFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateEventFragmentOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventFragmentFilter }


aggregateEventFragment :
    (AggregateEventFragmentOptionalArguments -> AggregateEventFragmentOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventFragmentAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateEventFragment fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventFragmentFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateEventFragment" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetContractOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , contractid : OptionalArgument String
    }


getContract :
    (GetContractOptionalArguments -> GetContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe decodesTo) RootQuery
getContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, contractid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "contractid" filledInOptionals____.contractid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryContractOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter
    , order : OptionalArgument Fractal.InputObject.ContractOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryContract :
    (QueryContractOptionalArguments -> QueryContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeContractOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateContractOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter }


aggregateContract :
    (AggregateContractOptionalArguments -> AggregateContractOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ContractAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateContract fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateContract" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetVoteOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , voteid : OptionalArgument String
    }


getVote :
    (GetVoteOptionalArguments -> GetVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Vote
    -> SelectionSet (Maybe decodesTo) RootQuery
getVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, voteid = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "voteid" filledInOptionals____.voteid Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryVoteOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.VoteFilter
    , order : OptionalArgument Fractal.InputObject.VoteOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryVote :
    (QueryVoteOptionalArguments -> QueryVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Vote
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeVoteFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeVoteOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateVoteOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.VoteFilter }


aggregateVote :
    (AggregateVoteOptionalArguments -> AggregateVoteOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.VoteAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateVote fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeVoteFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateVote" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetUserOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , username : OptionalArgument String
    , email : OptionalArgument String
    }


getUser :
    (GetUserOptionalArguments -> GetUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
getUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, username = Absent, email = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "username" filledInOptionals____.username Encode.string, Argument.optional "email" filledInOptionals____.email Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserFilter
    , order : OptionalArgument Fractal.InputObject.UserOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUser :
    (QueryUserOptionalArguments -> QueryUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.User
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserFilter }


aggregateUser :
    (AggregateUserOptionalArguments -> AggregateUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetPendingUserOptionalArguments =
    { id : OptionalArgument Fractal.ScalarCodecs.Id
    , username : OptionalArgument String
    , email : OptionalArgument String
    }


getPendingUser :
    (GetPendingUserOptionalArguments -> GetPendingUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PendingUser
    -> SelectionSet (Maybe decodesTo) RootQuery
getPendingUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, username = Absent, email = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId), Argument.optional "username" filledInOptionals____.username Encode.string, Argument.optional "email" filledInOptionals____.email Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "getPendingUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryPendingUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PendingUserFilter
    , order : OptionalArgument Fractal.InputObject.PendingUserOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryPendingUser :
    (QueryPendingUserOptionalArguments -> QueryPendingUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PendingUser
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryPendingUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePendingUserFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodePendingUserOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryPendingUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregatePendingUserOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.PendingUserFilter }


aggregatePendingUser :
    (AggregatePendingUserOptionalArguments -> AggregatePendingUserOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.PendingUserAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregatePendingUser fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodePendingUserFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregatePendingUser" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryUserRightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter
    , order : OptionalArgument Fractal.InputObject.UserRightsOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUserRights :
    (QueryUserRightsOptionalArguments -> QueryUserRightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRights
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUserRights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserRightsOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUserRights" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserRightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter }


aggregateUserRights :
    (AggregateUserRightsOptionalArguments -> AggregateUserRightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRightsAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUserRights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUserRights" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetUserEventRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getUserEvent :
    GetUserEventRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.UserEvent
    -> SelectionSet (Maybe decodesTo) RootQuery
getUserEvent requiredArgs____ object____ =
    Object.selectionForCompositeField "getUserEvent" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryUserEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter
    , order : OptionalArgument Fractal.InputObject.UserEventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryUserEvent :
    (QueryUserEventOptionalArguments -> QueryUserEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEvent
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryUserEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryUserEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateUserEventOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter }


aggregateUserEvent :
    (AggregateUserEventOptionalArguments -> AggregateUserEventOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEventAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateUserEvent fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateUserEvent" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias GetNotifRequiredArguments =
    { id : Fractal.ScalarCodecs.Id }


getNotif :
    GetNotifRequiredArguments
    -> SelectionSet decodesTo Fractal.Object.Notif
    -> SelectionSet (Maybe decodesTo) RootQuery
getNotif requiredArgs____ object____ =
    Object.selectionForCompositeField "getNotif" [ Argument.required "id" requiredArgs____.id (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias QueryNotifOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NotifFilter
    , order : OptionalArgument Fractal.InputObject.NotifOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryNotif :
    (QueryNotifOptionalArguments -> QueryNotifOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Notif
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryNotif fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNotifFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNotifOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryNotif" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateNotifOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NotifFilter }


aggregateNotif :
    (AggregateNotifOptionalArguments -> AggregateNotifOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NotifAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateNotif fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNotifFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateNotif" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias QueryEventCountOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventCountFilter
    , order : OptionalArgument Fractal.InputObject.EventCountOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


queryEventCount :
    (QueryEventCountOptionalArguments -> QueryEventCountOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventCount
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
queryEventCount fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventCountFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeEventCountOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "queryEventCount" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias AggregateEventCountOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventCountFilter }


aggregateEventCount :
    (AggregateEventCountOptionalArguments -> AggregateEventCountOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventCountAggregateResult
    -> SelectionSet (Maybe decodesTo) RootQuery
aggregateEventCount fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventCountFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "aggregateEventCount" optionalArgs____ object____ (Basics.identity >> Decode.nullable)
