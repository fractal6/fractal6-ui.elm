-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Fractal.Object.User exposing (..)

import Fractal.Enum.Lang
import Fractal.InputObject
import Fractal.Interface
import Fractal.Object
import Fractal.Scalar
import Fractal.ScalarCodecs
import Fractal.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


id : SelectionSet Fractal.ScalarCodecs.Id Fractal.Object.User
id =
    Object.selectionForField "ScalarCodecs.Id" "id" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecId |> .decoder)


createdAt : SelectionSet Fractal.ScalarCodecs.DateTime Fractal.Object.User
createdAt =
    Object.selectionForField "ScalarCodecs.DateTime" "createdAt" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


lastAck : SelectionSet Fractal.ScalarCodecs.DateTime Fractal.Object.User
lastAck =
    Object.selectionForField "ScalarCodecs.DateTime" "lastAck" [] (Fractal.ScalarCodecs.codecs |> Fractal.Scalar.unwrapCodecs |> .codecDateTime |> .decoder)


username : SelectionSet String Fractal.Object.User
username =
    Object.selectionForField "String" "username" [] Decode.string


name : SelectionSet (Maybe String) Fractal.Object.User
name =
    Object.selectionForField "(Maybe String)" "name" [] (Decode.string |> Decode.nullable)


email : SelectionSet String Fractal.Object.User
email =
    Object.selectionForField "String" "email" [] Decode.string


password : SelectionSet String Fractal.Object.User
password =
    Object.selectionForField "String" "password" [] Decode.string


bio : SelectionSet (Maybe String) Fractal.Object.User
bio =
    Object.selectionForField "(Maybe String)" "bio" [] (Decode.string |> Decode.nullable)


location : SelectionSet (Maybe String) Fractal.Object.User
location =
    Object.selectionForField "(Maybe String)" "location" [] (Decode.string |> Decode.nullable)


utc : SelectionSet (Maybe String) Fractal.Object.User
utc =
    Object.selectionForField "(Maybe String)" "utc" [] (Decode.string |> Decode.nullable)


links : SelectionSet (Maybe (List String)) Fractal.Object.User
links =
    Object.selectionForField "(Maybe (List String))" "links" [] (Decode.string |> Decode.list |> Decode.nullable)


skills : SelectionSet (Maybe (List String)) Fractal.Object.User
skills =
    Object.selectionForField "(Maybe (List String))" "skills" [] (Decode.string |> Decode.list |> Decode.nullable)


notifyByEmail : SelectionSet Bool Fractal.Object.User
notifyByEmail =
    Object.selectionForField "Bool" "notifyByEmail" [] Decode.bool


lang : SelectionSet Fractal.Enum.Lang.Lang Fractal.Object.User
lang =
    Object.selectionForField "Enum.Lang.Lang" "lang" [] Fractal.Enum.Lang.decoder


type alias SubscriptionsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


subscriptions :
    (SubscriptionsOptionalArguments -> SubscriptionsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
subscriptions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "subscriptions" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias WatchingOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


watching :
    (WatchingOptionalArguments -> WatchingOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
watching fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "watching" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias RightsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserRightsFilter }


rights :
    (RightsOptionalArguments -> RightsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserRights
    -> SelectionSet decodesTo Fractal.Object.User
rights fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserRightsFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rights" optionalArgs____ object____ Basics.identity


type alias RolesOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter
    , order : OptionalArgument Fractal.InputObject.NodeOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


roles :
    (RolesOptionalArguments -> RolesOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Node
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
roles fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeNodeOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "roles" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias TensionsCreatedOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


tensions_created :
    (TensionsCreatedOptionalArguments -> TensionsCreatedOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
tensions_created fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_created" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias TensionsAssignedOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter
    , order : OptionalArgument Fractal.InputObject.TensionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


tensions_assigned :
    (TensionsAssignedOptionalArguments -> TensionsAssignedOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Tension
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
tensions_assigned fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeTensionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_assigned" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias ContractsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter
    , order : OptionalArgument Fractal.InputObject.ContractOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


contracts :
    (ContractsOptionalArguments -> ContractsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Contract
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
contracts fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeContractOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contracts" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias ReactionsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ReactionFilter
    , order : OptionalArgument Fractal.InputObject.ReactionOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


reactions :
    (ReactionsOptionalArguments -> ReactionsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.Reaction
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
reactions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeReactionFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeReactionOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "reactions" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias EventsOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter
    , order : OptionalArgument Fractal.InputObject.UserEventOrder
    , first : OptionalArgument Int
    , offset : OptionalArgument Int
    }


events :
    (EventsOptionalArguments -> EventsOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEvent
    -> SelectionSet (Maybe (List decodesTo)) Fractal.Object.User
events fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent, order = Absent, first = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter, Argument.optional "order" filledInOptionals____.order Fractal.InputObject.encodeUserEventOrder, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "events" optionalArgs____ object____ (Basics.identity >> Decode.list >> Decode.nullable)


markAllAsRead : SelectionSet (Maybe String) Fractal.Object.User
markAllAsRead =
    Object.selectionForField "(Maybe String)" "markAllAsRead" [] (Decode.string |> Decode.nullable)


type alias EventCountOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.EventCountFilter }


event_count :
    (EventCountOptionalArguments -> EventCountOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.EventCount
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
event_count fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeEventCountFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "event_count" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias SubscriptionsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


subscriptionsAggregate :
    (SubscriptionsAggregateOptionalArguments -> SubscriptionsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
subscriptionsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "subscriptionsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias WatchingAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


watchingAggregate :
    (WatchingAggregateOptionalArguments -> WatchingAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
watchingAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "watchingAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias RolesAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.NodeFilter }


rolesAggregate :
    (RolesAggregateOptionalArguments -> RolesAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.NodeAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
rolesAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeNodeFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rolesAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias TensionsCreatedAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


tensions_createdAggregate :
    (TensionsCreatedAggregateOptionalArguments -> TensionsCreatedAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
tensions_createdAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_createdAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias TensionsAssignedAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.TensionFilter }


tensions_assignedAggregate :
    (TensionsAssignedAggregateOptionalArguments -> TensionsAssignedAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.TensionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
tensions_assignedAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeTensionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tensions_assignedAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ContractsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ContractFilter }


contractsAggregate :
    (ContractsAggregateOptionalArguments -> ContractsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ContractAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
contractsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeContractFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "contractsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ReactionsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.ReactionFilter }


reactionsAggregate :
    (ReactionsAggregateOptionalArguments -> ReactionsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.ReactionAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
reactionsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeReactionFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "reactionsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias EventsAggregateOptionalArguments =
    { filter : OptionalArgument Fractal.InputObject.UserEventFilter }


eventsAggregate :
    (EventsAggregateOptionalArguments -> EventsAggregateOptionalArguments)
    -> SelectionSet decodesTo Fractal.Object.UserEventAggregateResult
    -> SelectionSet (Maybe decodesTo) Fractal.Object.User
eventsAggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { filter = Absent }

        optionalArgs____ =
            [ Argument.optional "filter" filledInOptionals____.filter Fractal.InputObject.encodeUserEventFilter ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "eventsAggregate" optionalArgs____ object____ (Basics.identity >> Decode.nullable)
